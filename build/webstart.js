/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lezer-python/dist/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/lezer-python/dist/index.cjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezer = __webpack_require__(/*! lezer */ "./node_modules/lezer/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  printKeyword = 1,
  newline = 164,
  newlineBracketed = 165,
  newlineEmpty = 166,
  eof = 167,
  continueBody = 168,
  endBody = 169,
  ParenthesizedExpression = 21,
  TupleExpression = 48,
  ComprehensionExpression = 49,
  ArrayExpression = 53,
  ArrayComprehensionExpression = 56,
  DictionaryExpression = 57,
  DictionaryComprehensionExpression = 60,
  SetExpression = 61,
  SetComprehensionExpression = 62,
  compoundStatement = 231;

const newline$1 = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46;

const bracketed = [
  ParenthesizedExpression, TupleExpression, ComprehensionExpression, ArrayExpression, ArrayComprehensionExpression,
  DictionaryExpression, DictionaryComprehensionExpression, SetExpression, SetComprehensionExpression
], parentStatement = [compoundStatement];

const caches = new WeakMap;

// Per-input-stream indentation cache. `prev` maps indentation depths
// to the last position at which a statement indented to that depth
// was seen. There's an extra set of slots for the _current_
// indentation, since that needs to be available alongside a previous
// indentation position at the same level.
class Cache {
  constructor() {
    this.last = this.lastIndent = -1;
    this.prev = [];
  }

  get(pos) {
    if (this.last == pos) return this.lastIndent
    for (let i = 0; i < this.prev.length; i++) if (this.prev[i] == pos) return i
    return -1
  }

  set(pos, indent) {
    if (pos == this.last) return
    if (this.last > -1) this.setPrev(this.last, this.lastIndent);
    this.last = pos;
    this.lastIndent = indent;
  }

  setPrev(pos, indent) {
    while (this.prev.length < indent) this.prev.push(-1);
    this.prev[indent] = pos;
  }

  static for(input) {
    let found = caches.get(input);
    if (!found) caches.set(input, found = new Cache);
    return found
  }
}

const maxIndent = 50;

function getIndent(input, pos) {
  let cache = Cache.for(input), found = cache.get(pos);
  if (found > -1) return found

  // This shouldn't happen very often (or even at all) in normal
  // parsing, since the indentations are stored by the newline
  // tokenizer ahead of time. But it's kind of tricky to prove whether
  // that always happens in incremental parsing scenarios, so here's a
  // fallback anyway.
  let before = input.read(Math.max(0, pos - maxIndent), pos);
  let count = 0, start = before.length;
  for (; start > 0; start--) {
    let next = before.charCodeAt(start - 1);
    if (next == newline$1 || next == carriageReturn) break
  }
  for (let i = start; i < before.length; i++) {
    let ch = before.charCodeAt(i);
    if (ch == space) count++;
    else if (ch == tab) count += 8 - (count % 8);
    else break
  }
  cache.setPrev(pos, count);
  return count
}

const newlines = new lezer.ExternalTokenizer((input, token, stack) => {
  let next = input.get(token.start);
  if (next < 0) {
    token.accept(eof, token.start);
    return
  }
  if (next != newline$1 && next != carriageReturn) return
  if (stack.startOf(bracketed) != null) {
    token.accept(newlineBracketed, token.start + 1);
    return
  }
  let scan = token.start + 1, indent = 0;
  for (; scan < input.length; scan++) {
    let ch = input.get(scan);
    if (ch == space) indent++;
    else if (ch == tab) indent += 8 - (indent % 8);
    else if (ch == newline$1 || indent == carriageReturn || ch == hash) {
      token.accept(newlineEmpty, token.start + 1);
      return
    } else {
      break
    }
  }
  token.accept(newline, token.start + 1);
  Cache.for(input).set(scan, indent);
}, {contextual: true, fallback: true});

const bodyContinue = new lezer.ExternalTokenizer((input, token, stack) => {
  let parent = stack.startOf(parentStatement);
  let parentIndent = parent == null ? 0 : getIndent(input, parent);
  let indentHere = getIndent(input, token.start);
  token.accept(indentHere <= parentIndent ? endBody : continueBody, token.start);
}, {contextual: true, fallback: true});

const legacyPrint = new lezer.ExternalTokenizer((input, token) => {
  let pos = token.start;
  for (let print = "print", i = 0; i < print.length; i++, pos++)
    if (input.get(pos) != print.charCodeAt(i)) return
  let end = pos;
  if (/\w/.test(String.fromCharCode(input.get(pos)))) return
  for (;; pos++) {
    let next = input.get(pos);
    if (next == space || next == tab) continue
    if (next != parenOpen && next != dot && next != newline$1 && next != carriageReturn && next != hash)
      token.accept(printKeyword, end);
    return
  }
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,await:40, or:48, and:50, in:54, not:56, is:58, if:64, else:66, lambda:70, self:74, yield:90, from:92, async:100, for:102, None:154, True:156, False:156, del:170, pass:174, break:178, continue:182, return:186, raise:194, import:198, as:200, global:204, nonlocal:206, assert:210, elif:220, while:224, try:230, except:232, finally:234, with:238, def:242, class:252};
const parser = lezer.Parser.deserialize({
  version: 13,
  states: "!;[O`Q!LTOOO%fQ!LUO'#GcOOQ!LQ'#Cm'#CmOOQ!LQ'#Cn'#CnO'UQ!LSO'#ClO(zQ!LUO'#GbOOQ!LQ'#Gc'#GcOOQ!LQ'#DS'#DSOOQ!LQ'#Gb'#GbO)hQ!LSO'#CqO)xQ!LSO'#DcO*YQ!LSO'#DgOOQ!LQ'#Dt'#DtO*mOWO'#DtO*uO`O'#DtO*}OpO'#DuO+YO!bO'#DuO+eO#tO'#DuO+pO&jO'#DuO-rQ!LUO'#GSOOQ!LQ'#GS'#GSO'UQ!LSO'#GRO/UQ!LUO'#GROOQ!LQ'#E^'#E^O/mQ!LSO'#E_OOQ!LQ'#GQ'#GQO/wQ!LSO'#GPOOQ&FV'#GP'#GPO0SQ!LSO'#FQOOQ!LQ'#Ft'#FtO0XQ!LSO'#FPOOQ&FV'#H]'#H]OOQ&FV'#GO'#GOOOQ!LR'#FS'#FSQ`Q!LTOOO'UQ!LSO'#CoO0gQ!LSO'#CzO0nQ!LSO'#DOO1PQ!LSO'#GgO1aQ!LUO'#ERO'UQ!LSO'#ESOOQ!LQ'#EU'#EUOOQ!LQ'#EW'#EWOOQ!LQ'#EY'#EYO1uQ!LSO'#E[O2]Q!LSO'#E`O0SQ!LSO'#EbO2pQ!LUO'#EbO0SQ!LSO'#EeO/mQ!LSO'#EhO/mQ!LSO'#ElO/mQ!LSO'#EoO2{Q!LSO'#EqO3SQ!LSO'#EvO3_Q!LSO'#ErO/mQ!LSO'#EvO0SQ!LSO'#ExO0SQ!LSO'#E}OOQ!LQ'#Cc'#CcOOQ!LQ'#Cd'#CdOOQ!LQ'#Ce'#CeOOQ!LQ'#Cf'#CfOOQ!LQ'#Cg'#CgOOQ!LQ'#Ch'#ChOOQ!LQ'#Cj'#CjO'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O3dQ!LSO'#DnOOQ!LQ,5:X,5:XO3wQ!LSO,5:[O4UQ#)WO,5:[O4ZQ!LUO,59WO0gQ!LSO,59_O0gQ!LSO,59_O0gQ!LSO,59_O6yQ!LSO,59_O7OQ!LSO,59_O7VQ!LSO,59gO7^Q!LSO'#GbO8dQ!LSO'#GaOOQ!LQ'#Ga'#GaOOQ!LQ'#DY'#DYO8{Q!LSO,59]O'UQ!LSO,59]O9ZQ!LSO,59]O9`Q!LSO,5:QO'UQ!LSO,5:QOOQ!LQ,59},59}O9nQ!LSO,59}O9sQ!LSO,5:WO'UQ!LSO,5:WO'UQ!LSO,5:UOOQ!LQ,5:R,5:RO:UQ!LSO,5:RO:ZQ!LSO,5:VOOOO'#F]'#F]O:`OWO,5:`OOQ!LQ,5:`,5:`OOOO'#F^'#F^O:hO`O,5:`O:pQ!LSO'#DvOOOO'#F_'#F_O;QOpO,5:aOOQ!LQ,5:a,5:aOOOO'#Fb'#FbO;]O!bO,5:aOOOO'#Fc'#FcO;hO#tO,5:aOOOO'#Fd'#FdO;sO&jO,5:aOOQ!LQ'#Fe'#FeO<OQ!LUO,5:eO>pQ!LUO,5<mO?ZQ#4^O'#FfO?}Q!LUO,5<mOOQ!LQ,5:y,5:yO@fQ!LTO'#FmOAuQ!LSO,5;UOOQ&FV,5<k,5<kOBQQ!LUO'#HYOBiQ!LSO,5;lOOQ!LQ-E9r-E9rOOQ&FV,5;k,5;kO3YQ!LSO'#ExOOQ!LR-E9Q-E9QOBqQ!LUO,59ZODxQ!LUO,59fOEcQ!LSO'#GdOEnQ!LSO'#GdO0SQ!LSO'#GdOEyQ!LSO'#DQOFRQ!LSO,59jOFWQ!LSO'#GhO'UQ!LSO'#GhO/mQ!LSO,5=ROOQ!LQ,5=R,5=RO/mQ!LSO'#D}OOQ!LQ'#EO'#EOOFuQ!LSO'#FgOGVQ!LSO,58zOGeQ!LSO,58zO)kQ!LSO,5:kOGjQ!LUO'#GjOOQ!LQ,5:n,5:nOOQ!LQ,5:v,5:vOG}Q!LSO,5:zOH`Q!LSO,5:|OOQ!LQ'#Fj'#FjOHnQ!LUO,5:|OH|Q!LSO,5:|OIRQ!LSO'#H[OOQ!LQ,5;P,5;POIaQ!LSO'#HXOOQ!LQ,5;S,5;SO3_Q!LSO,5;WO3_Q!LSO,5;ZOIrQ!LUO'#H^O'UQ!LSO'#H^OI|Q!LSO,5;]O2{Q!LSO,5;]O/mQ!LSO,5;bO0SQ!LSO,5;dOJRQ!LTO'#EmOK[Q&FXO,5;^ONsQ!LSO'#H_O3_Q!LSO,5;bO! OQ!LSO,5;dO! TQ!LSO,5;iO!#xQ!LUO1G.hO!$PQ!LUO1G.hO!&pQ!LUO1G.hO!&zQ!LUO1G.hO!)eQ!LUO1G.hO!)xQ!LUO1G.hO!*]Q!LUO1G.hO!,{Q!LSO'#GpO!-ZQ!LUO'#GSO/mQ!LSO'#GpO!-eQ!LSO'#GoOOQ!LQ,5:Y,5:YO!-mQ!LSO,5:YO!-rQ!LSO'#GqO!-}Q!LSO'#GqO!.bQ!LSO1G/vOOQ!LQ'#Dr'#DrOOQ!LQ1G/v1G/vOOQ!LQ1G.y1G.yO!/bQ!LUO1G.yO!/iQ!LUO1G.yO0gQ!LSO1G.yO!0UQ!LSO1G/ROOQ!LQ'#DX'#DXO/mQ!LSO,59rOOQ!LQ1G.w1G.wO!0]Q!LSO1G/dO!0mQ!LSO1G/dO!0uQ!LSO1G/eO'UQ!LSO'#GiO!0zQ!LSO'#GiO!1PQ!LUO1G.wO!1aQ!LSO,59fO!2gQ!LSO'#FXO!2zQ!LSO,5=XO!3SQ!LSO1G/lO!3XQ!LUO1G/lOOQ!LQ1G/i1G/iO!3iQ!LSO'#FUO!4cQ!LSO,5=SO/mQ!LSO1G/pO!5QQ!LSO1G/rO!5VQ!LUO1G/rO!5gQ!LUO1G/pOOQ!LQ1G/m1G/mOOQ!LQ1G/q1G/qOOOO-E9Z-E9ZOOQ!LQ1G/z1G/zOOOO-E9[-E9[O!5wQ!LSO'#G|O/mQ!LSO'#G|O!6VQ!LSO,5:bOOOO-E9]-E9]OOQ!LQ1G/{1G/{OOOO-E9`-E9`OOOO-E9a-E9aOOOO-E9b-E9bOOQ!LQ-E9c-E9cO!6bQ!LUO1G2XO'UQ!LSO,5<QOOQ!LQ,5<Q,5<QOOQ!LQ-E9d-E9dOOQ!LQ,5<X,5<XOOQ!LQ-E9k-E9kOOQ&FV1G0p1G0pO0SQ!LSO'#FiO!6yQ!LUO,5=tOOQ!LQ1G1W1G1WO!7bQ!LSO1G1WOOQ!LQ'#DT'#DTO/mQ!LSO,5=OOOQ!LQ,5=O,5=OO!7gQ!LSO'#FTO!7uQ!LSO,59lO!7}Q!LSO1G/UO!8XQ!LUO,5=SOOQ!LQ1G2m1G2mOOQ!LQ,5:i,5:iO!8xQ!LSO'#GROOQ!LQ,5<R,5<ROOQ!LQ-E9e-E9eO!9ZQ!LSO1G.fOOQ!LQ1G0V1G0VO!9iQ!LSO'#FWO!9|Q!LSO,5=UO/mQ!LSO1G0fO/mQ!LSO1G0fO0SQ!LSO1G0hOOQ!LQ-E9h-E9hO!:_Q!LSO1G0hO!:jQ!LSO1G0hO!:oQ!LSO'#FlO!;QQ!LSO,5=vO!;`Q!LSO'#FhO!;yQ!LSO,5=sO!<[Q&FXO1G0rO!?pQ&FXO1G0uO!CRQ!LSO'#FpO!C`Q!LSO,5=xO!ChQ!LUO,5=xO/mQ!LSO1G0wO!CrQ!LSO1G0wO3_Q!LSO1G0|O! OQ!LSO1G1OOOQ&FV,5;X,5;XO!CwQ!LTO,5;XO!EjQ&FXO1G0xO!IRQ!LSO'#FqO3_Q!LSO1G0xO3_Q!LSO1G0xO!I`Q!LSO'#FrO!IpQ!LSO,5=yO0SQ!LSO,5=yOOQ&FV1G0|1G0|O!JZQ!LSO'#EzO!JbQ#)WO1G1OOOQ&FV1G1T1G1TO3_Q!LSO1G1TOOQ!LQ,5=[,5=[OOQ!LQ'#Do'#DoO/mQ!LSO,5=[O!JjQ!LSO'#FZO!KQQ!LSO,5=ZOOQ!LQ1G/t1G/tO!KYQ!LSO'#F[O!KmQ!LSO,5=]O!KuQ!LSO,5=]O!LYQ!LSO,5=]O!LjQ!LSO,5=]OOQ!LQ7+%b7+%bOOQ!LQ7+$e7+$eO!7}Q!LSO7+$mO!N]Q!LSO1G.yO!NdQ!LSO1G.yOOQ!LQ1G/^1G/^OOQ!LQ,5;q,5;qO'UQ!LSO,5;qOOQ!LQ7+%O7+%OO!NkQ!LSO7+%OOOQ!LQ-E9T-E9TOOQ!LQ7+%P7+%PO!N{Q!LSO,5=TO'UQ!LSO,5=TOOQ!LQ7+$c7+$cO# QQ!LSO7+%OO# YQ!LSO7+%POOQ!LQ,5;s,5;sO'UQ!LSO,5;sOOQ!LQ-E9V-E9VOOQ!LQ7+%W7+%WO# _Q!LSO1G2sO# gQ!LSO7+%WOOQ!LQ,5;p,5;pO'UQ!LSO,5;pOOQ!LQ-E9S-E9SO# lQ!LSO7+%[OOQ!LQ7+%^7+%^O# zQ!LSO1G2nO#!iQ!LSO7+%^O#!nQ!LSO'#FYO##RQ!LSO1G2tO##ZQ!LSO7+%[O##`Q!LSO'#F`O##yQ!LSO,5=hO##yQ!LSO,5=hO#$XOMhO'#DxO#$dOQO'#G}OOOO1G/|1G/|O#$iQ!LSO1G/|O#$qQ!LUO1G1lOOQ!LQ,5<T,5<TOOQ!LQ-E9g-E9gOOQ!LQ7+&r7+&rOOQ!LQ1G2j1G2jOOQ!LQ,5;o,5;oOOQ!LQ-E9R-E9ROOQ!LQ7+$p7+$pO#%[Q!LSO'#FfO#%xQ!LSO,5<mO#&ZQ!LUO,5;rOOQ!LQ-E9U-E9UOOQ!LQ7+&Q7+&QO#&nQ!LSO7+&QOOQ!LQ7+&S7+&SO#&|Q!LSO'#HZO0SQ!LSO7+&SO#'bQ!LSO7+&SOOQ!LQ,5<W,5<WOOQ!LQ-E9j-E9jOOQ!LQ,5<S,5<SOOQ!LQ-E9f-E9fO#'mQ&FXO7+&^O!IRQ!LSO'#FoO3_Q!LSO7+&^O3_Q!LSO7+&aO#+RQ!LUO,5<[O'UQ!LSO,5<[OOQ!LQ-E9n-E9nO#+]Q!LSO1G3dO3_Q!LSO7+&cO/mQ!LSO7+&cOOQ&FV7+&h7+&hO!JbQ#)WO7+&jO#+eQ&FWO1G0sOOQ&FV-E9o-E9oO3_Q!LSO7+&dO3_Q!LSO7+&dOOQ&FV,5<],5<]O#+pQ!LSO,5<]OOQ&FV7+&d7+&dO#+{Q&FXO7+&dO#/^Q!LSO,5<^OOQ!LQ-E9p-E9pO#/iQ!LSO1G3eO#/qQ!LSO'#HaO#0PQ!LSO'#HaO0SQ!LSO'#HaOOQ!LQ'#Ha'#HaO#0[Q!LSO'#H`OOQ!LQ,5;f,5;fO#0dQ!LSO,5;fO/mQ!LSO'#E|OOQ&FV7+&j7+&jO3_Q!LSO7+&jOOQ&FV7+&o7+&oOOQ!LQ1G2v1G2vOOQ!LQ,5;u,5;uOOQ!LQ-E9X-E9XO#0iQ!LSO,5;vO#0tQ!LSO,5;vOOQ!LQ-E9Y-E9YO#1XQ!LSO1G2wO#1aQ!LSO1G2wO#1qQ!LSO1G2wO#1XQ!LSO1G2wOOQ!LQ<<HX<<HXO#1|Q!LUO1G1]OOQ!LQ<<Hj<<HjP#2WQ!LSO'#FVO7VQ!LSO1G2oO#2eQ!LSO1G2oO#2jQ!LSO<<HjOOQ!LQ<<Hk<<HkO#2zQ!LUO1G1_OOQ!LQ<<Hr<<HrO#3UQ!LUO1G1[O#3uQ!LSO7+(`O#3}Q!LSO<<HvOOQ!LQ<<Hx<<HxO#4SQ!LSO,5;tO'UQ!LSO,5;tOOQ!LQ-E9W-E9WOOQ!LQ<<Hv<<HvOOQ!LQ,5;z,5;zO/mQ!LSO,5;zOOQ!LQ-E9^-E9^O#4XQ!LSO1G3SOOOO'#Fa'#FaO#4gOMhO,5:dOOOO,5=i,5=iOOOO7+%h7+%hO#4rQ!LSO1G2XO/mQ!LSO<<IlO#5TQ!LSO'#FkO#5iQ!LSO,5=uO0SQ!LSO,5=uO#5zQ!LSO<<InOOQ!LQ<<In<<InO0SQ!LSO<<InOOQ&FV-E9m-E9mO3_Q!LSO<<IxOOQ&FV,5<Z,5<ZO3_Q!LSO,5<ZOOQ&FV<<Ix<<IxOOQ&FV<<I{<<I{O#6PQ!LUO1G1vO#6ZQ&FXO<<I}O3_Q!LSO<<I}OOQ&FV<<JU<<JUO3_Q!LSO<<JUO!CwQ!LTO'#FnO#9lQ&FWO7+&_OOQ&FV7+&_7+&_OOQ&FV<<JO<<JOO#9wQ&FXO<<JOOOQ&FV1G1w1G1wO0SQ!LSO1G1wO3_Q!LSO<<JOO0SQ!LSO1G1xO#=YQ!LSO7+)POOQ!LQ'#E{'#E{O/mQ!LSO,5={O#=bQ!LSO,5={OOQ!LQ,5={,5={O#=mQ!LSO'#FsO#=wQ!LSO,5=zOOQ!LQ1G1Q1G1QOOQ!LQ,5;h,5;hO#>PQ!LSO1G1bO#>dQ!LSO1G1bO#>tQ!LSO1G1bO#?PQ!LSO7+(cO#?PQ!LSO7+(cO#?XQ!LSO7+(cO#?iQ!LSO7+(ZO7VQ!LSO7+(ZOOQ!LQAN>UAN>UOOQ!LQAN>bAN>bO/mQ!LSO1G1`O#@SQ!LUO1G1`OOQ!LQ1G1f1G1fOOOO-E9_-E9_OOQ!LQAN?WAN?WO#@^Q!LSO,5<VOOQ!LQ-E9i-E9iO#@rQ!LSO1G3aOOQ!LQAN?YAN?YO#ATQ!LSOAN?YOOQ&FVAN?dAN?dOOQ&FV1G1u1G1uO3_Q!LSOAN?iO#AYQ&FXOAN?iOOQ&FVAN?pAN?pOOQ&FU,5<Y,5<YOOQ&FU-E9l-E9lOOQ&FV<<Iy<<IyO3_Q!LSOAN?jO3_Q!LSO7+'cOOQ&FVAN?jAN?jOOQ!LQ7+'d7+'dOOQ!LQ1G3g1G3gO/mQ!LSO1G3gOOQ!LQ,5<_,5<_OOQ!LQ-E9q-E9qO#DkQ!LSO7+&|O#D{Q!LSO7+&|OOQ!LQ7+&|7+&|O#EWQ!LSO<<K}O#EWQ!LSO<<K}O#E`Q!LSO'#GkOOQ!LQ<<Ku<<KuO#EjQ!LSO<<KuOOQ!LQ7+&z7+&zO0SQ!LSO1G1qO#FTQ!LSO7+({OOQ!LQG24tG24tOOQ&FVG25TG25TO3_Q!LSOG25TOOQ&FVG25UG25UOOQ&FV<<J}<<J}OOQ!LQ7+)R7+)ROOQ!LQ<<Jh<<JhO#FfQ!LSO<<JhO#FvQ!LSOANAiO#GOQ!LSO'#GlOOQ!LQ'#Gl'#GlO0nQ!LSO'#DbO#GiQ!LSO,5=VOOQ!LQANAaANAaOOQ!LQ7+']7+']OOQ&FVLD*oLD*oOOQ!LQAN@SAN@SO#HQQ!LSO,59|OOQ!LQ1G2q1G2qO#E`Q!LSO1G/hOOQ!LQ7+%S7+%SO7VQ!LSO'#CzO7VQ!LSO,59_O7VQ!LSO,59_O7VQ!LSO,59_O#HVQ!LUO,5<mO7VQ!LSO1G.yO/mQ!LSO1G/UO/mQ!LSO7+$mO'UQ!LSO'#GRO#HjQ!LSO,59_O#HoQ!LSO,59_O#HvQ!LSO,59jO#H{Q!LSO1G/RO0nQ!LSO'#DOO7VQ!LSO,59g",
  stateData: "#I^~O$qOS$lOS$kOSQOS~OPhOTeOdsOfXOltOp!SOsuOudO}vO!O!PO!S!VO!T!UO!WYO![ZO!gdO!ndO!odO!pdO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO$jqO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$w![O$x!]O$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aO~Oh%VXi%VXj%VXk%VXl%VXm%VXp%VXx%VXy%VX!t%VX#_%VX$j%VX$m%VX%X%VX!P%VX!S%VX!T%VX%Y%VX!X%VX!]%VX!O%VX#W%VXq%VX!k%VX~P$bOdsOfXOudO!WYO![ZO!gdO!ndO!odO!pdO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~Ox%UXy%UX#_%UX$j%UX$m%UX%X%UX~Oh!pOi!qOj!oOk!oOl!rOm!sOp!tO!t%UX~P(fOT!zOl,qOs-OO}vO~P'UOT!}Ol,qOs-OO!X#OO~P'UOT#RO_#SOl,qOs-OO!]#TO~P'UO%i#WO%j#YO~O%l#ZO%m#YO~O![#]O%o#^O%s#`O~O![#]O%u#aO%v#`O~O![#]O%j#`O%x#cO~O![#]O%m#`O%z#eO~OT$vX]$vX_$vXf$vXh$vXi$vXj$vXk$vXl$vXm$vXp$vXx$vX!W$vX!e$vX$w$vX$x$vX$y$vX$z$vX${$vX$|$vX$}$vX%O$vX%P$vX%Q$vX!P$vX!S$vX!T$vX~O%g[O%h]O%k^O%n_O%t`O%waO%ybOy$vX!t$vX#_$vX$j$vX$m$vX%X$vX%Y$vX!X$vX!]$vX!O$vX#W$vXq$vX!k$vX~P+{Ox#jOy$uX!t$uX#_$uX$j$uX$m$uX%X$uX~Ol,qOs-OO~P'UO#_#mO$j#oO$m#oO~O%SVO~O!S#tO#m!YO#r!ZO#ulO~OltO~P'UOT#yO_#zOu#xO%SVOytP~OT$OOl,qOs-OO!O$PO~P'UOy$RO!t$WO%X$SO#_!uX$j!uX$m!uX~OT$OOl,qOs-OO#_#OX$j#OX$m#OX~P'UOl,qOs-OO#_#SX$j#SX$m#SX~P'UO!e$^O!n$^O%SVO~OT$hO~P'UO!T$jO#k$kO#m$lO~Oy$mO~OT$|O_$|Ol,qOs-OO!P%OO~P'UOl,qOs-OOy%RO~P'UO%f%TO~O_!bOf!jO!W!lO!e!mOT`a]`ah`ai`aj`ak`al`am`ap`ax`ay`a!t`a#_`a$j`a$m`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%P`a%Q`a%X`a!P`a!S`a!T`a%Y`a!X`a!]`a!O`a#W`aq`a!k`a~Ok%YO~Ol%YO~P'UOl,qO~P'UOh,sOi,tOj,rOk,rOl,zOm,{Op-PO!P%UX!S%UX!T%UX%Y%UX!X%UX!]%UX!O%UX#W%UX!k%UX~P(fO%Y%[Ox%TX!P%TX!S%TX!T%TX!X%TXy%TX~Ox%_O!P%^O!S%cO!T%bO~O!P%^O~Ox%fO!S%cO!T%bO!X%aX~O!X%jO~Ox%kOy%mO!S%cO!T%bO!]%[X~O!]%qO~O!]%rO~O%i#WO%j%tO~O%l#ZO%m%tO~OT%wOl,qOs-OO}vO~P'UO![#]O%o#^O%s%zO~O![#]O%u#aO%v%zO~O![#]O%j%zO%x#cO~O![#]O%m%zO%z#eO~OT!ma]!ma_!maf!mah!mai!maj!mak!mal!mam!map!max!may!ma!W!ma!e!ma!t!ma#_!ma$j!ma$m!ma$w!ma$x!ma$y!ma$z!ma${!ma$|!ma$}!ma%O!ma%P!ma%Q!ma%X!ma!P!ma!S!ma!T!ma%Y!ma!X!ma!]!ma!O!ma#W!maq!ma!k!ma~P#yOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~P$bOT&QOltOsuOx$YXy$YX!t$YX#_$YX$j$YX$m$YX%X$YX~P'UOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#_$aX$j$aX$m$aX~P'UO#_#mO$j&VO$m&VO~O!e&WOf%|X$j%|X#W%|X#_%|X$m%|X#V%|X~Of!jO$j&YO~Ohcaicajcakcalcamcapcaxcayca!tca#_ca$jca$mca%Xca!Pca!Sca!Tca%Yca!Xca!]ca!Oca#Wcaqca!kca~P$bOpnaxnayna#_na$jna$mna%Xna~Oh!pOi!qOj!oOk!oOl!rOm!sO!tna~PDaO%X&[Ox%WXy%WX~O%SVOx%WXy%WX~Ox&_OytX~Oy&aO~Ox%kO#_%[X$j%[X$m%[X!P%[Xy%[X!]%[X!k%[X%X%[X~OT,yOl,qOs-OO}vO~P'UO%X$SO#_Sa$jSa$mSa~O%X$SO~Ox&jO#_%^X$j%^X$m%^Xk%^X~P$bOx&mO!O&lO#_#Sa$j#Sa$m#Sa~O#W&nO#_#Ua$j#Ua$m#Ua~O!e$^O!n$^O#V&pO%SVO~O#V&pO~Ox&rO#_&OX$j&OX$m&OX~Ox&tO#_%{X$j%{X$m%{Xy%{X~Ox&xOk&QX~P$bOk&{O~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO$j'QO~P'UOq'UO#h'SO#i'TOP#faT#fad#faf#fal#fap#fas#fau#fa}#fa!O#fa!S#fa!T#fa!W#fa![#fa!g#fa!n#fa!o#fa!p#fa!w#fa!y#fa!{#fa!}#fa#P#fa#T#fa#V#fa#Y#fa#Z#fa#]#fa#d#fa#g#fa#k#fa#m#fa#r#fa#u#fa$i#fa$j#fa$|#fa$}#fa%R#fa%S#fa%g#fa%h#fa%k#fa%n#fa%t#fa%w#fa%y#fa$m#fa$n#fa$o#fa~Ox'VO#W'XOy&RX~Of'ZO~Of!jOy$mO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$x!]O~P! ]O$xUi~P! ]OT!aO]!aO_!bOf!jO!W!lO!e!mO$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$z!_O${!_O~P!$WO$zUi${Ui~P!$WO_!bOf!jO!W!lO!e!mOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~OT!aO]!aO%O!aO%P!aO%Q!aO~P!'UOTUi]Ui%OUi%PUi%QUi~P!'UOf!jO!W!lO!e!mOTUi]Ui_UihUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%OUi%PUi%QUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O!S%cO!T%bOx%dX!P%dX~O%X'`O%Y'`O~P+{Ox'bO!P%cX~O!P'dO~Ox'eOy'gO!X%eX~Ol,qOs-OOx'eOy'hO!X%eX~P'UO!X'jO~Oj!oOk!oOl!rOm!sOhgipgixgiygi!tgi#_gi$jgi$mgi%Xgi~Oi!qO~P!.gOigi~P!.gOh,sOi,tOj,rOk,rOl,zOm,{O~Oq'lO~P!/pOT'qOl,qOs-OO!P'rO~P'UOx'sO!P'rO~O!P'uO~O!T'wO~Ox'sO!P'xO!S%cO!T%bO~P$bOh,sOi,tOj,rOk,rOl,zOm,{O!Pna!Sna!Tna%Yna!Xna!]na!Ona#Wnaqna!kna~PDaOT'|Ol,qOs-OOx#{X!X#{X~P'UOx%fO!X%aa~O!X(OO~Ox%fO!S%cO!T%bO!X%aa~P$bOT(SOl,qOs-OOx#xX!]#xX#_#xX$j#xX$m#xX!P#xXy#xX!k#xX%X#xX~P'UOx%kO!]%[a#_%[a$j%[a$m%[a!P%[ay%[a!k%[a%X%[a~O!](VO~Ox%kO!S%cO!T%bO!]%[a~P$bOx(YO!S%cO!T%bO!]%ba~P$bOx(]Oy%pX!]%pX!k%pX~Oy(`O!](bO!k(cO~Ox#jOy$ui!t$ui#_$ui$j$ui$m$ui%X$ui~O!e&WOf%|a$j%|a#W%|a#_%|a$m%|a#V%|a~O$j(gO~OT#yO_#zOu#xO%SVO~Ox&_Oyta~OltOsuO~P'UOx%kO#_%[a$j%[a$m%[a!P%[ay%[a!]%[a!k%[a%X%[a~P$bOx(lO#_$uX$j$uX$m$uX%X$uX~O%X$SO#_Si$jSi$mSi~Ox#zX#_#zX$j#zX$m#zXk#zX~P'UOx&jO#_%^a$j%^a$m%^ak%^a~OT(rOf(tO%SVO~O#V(uO~O%SVOx$`X#_$`X$j$`X$m$`X~Ox&rO#_&Oa$j&Oa$m&Oa~Ol,qOs-OOx$[X#_$[X$j$[X$m$[Xy$[X~P'UOx&tO#_%{a$j%{a$m%{ay%{a~Oq(|O#b({OP#`iT#`id#`if#`il#`ip#`is#`iu#`i}#`i!O#`i!S#`i!T#`i!W#`i![#`i!g#`i!n#`i!o#`i!p#`i!w#`i!y#`i!{#`i!}#`i#P#`i#T#`i#V#`i#Y#`i#Z#`i#]#`i#d#`i#g#`i#k#`i#m#`i#r#`i#u#`i$i#`i$j#`i$|#`i$}#`i%R#`i%S#`i%g#`i%h#`i%k#`i%n#`i%t#`i%w#`i%y#`i$m#`i$n#`i$o#`i~Oq(}OP#ciT#cid#cif#cil#cip#cis#ciu#ci}#ci!O#ci!S#ci!T#ci!W#ci![#ci!g#ci!n#ci!o#ci!p#ci!w#ci!y#ci!{#ci!}#ci#P#ci#T#ci#V#ci#Y#ci#Z#ci#]#ci#d#ci#g#ci#k#ci#m#ci#r#ci#u#ci$i#ci$j#ci$|#ci$}#ci%R#ci%S#ci%g#ci%h#ci%k#ci%n#ci%t#ci%w#ci%y#ci$m#ci$n#ci$o#ci~OT)POk$dXx$dX~P'UOx&xOk&Qa~Ox&xOk&Qa~P$bOk)TO~OPhOTeOltOp!SOsuO}vO!O!PO!S!VO!T!UO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO~P'UOq)ZO#h'SO#i)YOP#fiT#fid#fif#fil#fip#fis#fiu#fi}#fi!O#fi!S#fi!T#fi!W#fi![#fi!g#fi!n#fi!o#fi!p#fi!w#fi!y#fi!{#fi!}#fi#P#fi#T#fi#V#fi#Y#fi#Z#fi#]#fi#d#fi#g#fi#k#fi#m#fi#r#fi#u#fi$i#fi$j#fi$|#fi$}#fi%R#fi%S#fi%g#fi%h#fi%k#fi%n#fi%t#fi%w#fi%y#fi$m#fi$n#fi$o#fi~Ol,qOs-OOy$mO~P'UOl,qOs-OOx$fXy$fX~P'UOx'VOy&Ra~OT)dO_)eOu)cO%O)fO%SVO~O!P)hO~P!IxOy$mO&U)jO~OT$|O_$|Ol,qOs-OOx#}X!P#}X~P'UOx'bO!P%ca~Ol,qOs-OOy)rOx$OX!X$OX~P'UOx'eO!X%ea~Ol,qOs-OOx'eOy)uO!X%ea~P'UOl,qOs-OOx'eO!X%ea~P'UOx'eOy)uO!X%ea~Oj,rOk,rOl,zOm,{Ohgipgixgi!Pgi!Sgi!Tgi%Ygi!Xgiygi!]gi#_gi$jgi$mgi!Ogi#Wgiqgi!kgi%Xgi~Oi,tO~P!LuOigi~P!LuOT'qOl,qOs-OO!P)zO~P'UOk)|O~Ox*OO!P)zO~O!P*PO~Ox%fO!X%ai~O!X*RO~Ox(YO!S%cO!T%bO!]%bi~Ox%kO!]%[i#_%[i$j%[i$m%[i!P%[iy%[i!k%[i%X%[i~O!]*VO~O_*XOl,qOs-OOx#|X!]#|X~P'UOx(YO!]%bi~O!]*ZO~OT*]Ol,qOs-OOx$SXy$SX!]$SX!k$SX~P'UOx(]Oy%pa!]%pa!k%pa~O![#]O%r*`O!]!lX~O!]*bO~Oy(`O!]*cO~Ox$Yiy$Yi!t$Yi#_$Yi$j$Yi$m$Yi%X$Yi~P$bOT&QOl,qOs-OOx$YX#_$YX$j$YX$m$YX%X$YX~P'UOx(lO#_$ua$j$ua$m$ua%X$ua~Ox#za#_#za$j#za$m#zak#za~P$bOx*eO#_#Sq$j#Sq$m#Sq~Ox*fO#W*hO#_%}X$j%}X$m%}X!P%}X~OT*jOf*kO%SVO~Oq*mO#b({OP#`qT#`qd#`qf#`ql#`qp#`qs#`qu#`q}#`q!O#`q!S#`q!T#`q!W#`q![#`q!g#`q!n#`q!o#`q!p#`q!w#`q!y#`q!{#`q!}#`q#P#`q#T#`q#V#`q#Y#`q#Z#`q#]#`q#d#`q#g#`q#k#`q#m#`q#r#`q#u#`q$i#`q$j#`q$|#`q$}#`q%R#`q%S#`q%g#`q%h#`q%k#`q%n#`q%t#`q%w#`q%y#`q$m#`q$n#`q$o#`q~Ok$dax$da~P$bOx&xOk&Qi~O$m*yO$n*wO$o*yO~Ox*}Oy$mO#W*}O~O#i+OOP#fqT#fqd#fqf#fql#fqp#fqs#fqu#fq}#fq!O#fq!S#fq!T#fq!W#fq![#fq!g#fq!n#fq!o#fq!p#fq!w#fq!y#fq!{#fq!}#fq#P#fq#T#fq#V#fq#Y#fq#Z#fq#]#fq#d#fq#g#fq#k#fq#m#fq#r#fq#u#fq$i#fq$j#fq$|#fq$}#fq%R#fq%S#fq%g#fq%h#fq%k#fq%n#fq%t#fq%w#fq%y#fq$m#fq$n#fq$o#fq~O#W+POx$fay$fa~Ox'VOy&Ri~Oy$RO%X+ROx&TX!P&TX~O%SVOx&TX!P&TX~Ox+VO!P&SX~O!P+XO~Oy+ZOx$Oa!X$Oa~Ol,qOs-OOy+[Ox$Oa!X$Oa~P'UOx'eO!X%ei~Ol,qOs-OOx'eO!X%ei~P'UOx'eOy+`O!X%ei~Ox#yi!P#yi~P$bOT'qOl,qOs-OO~P'UOk+bO~OT'qOl,qOs-OO!P+cO~P'UOx#{i!X#{i~P$bOx#xi!]#xi#_#xi$j#xi$m#xi!P#xiy#xi!k#xi%X#xi~P$bOx(YO!]%bq~O!]+dO~Oy+eO~Ox(]Oy%pi!]%pi!k%pi~O![#]O%r*`O!]!la~Ox(lO#_$ui$j$ui$m$ui%X$ui~O%SVOx$_X#_$_X$j$_X$m$_X!P$_X~Ox*fO#_%}a$j%}a$m%}a!P%}a~O!P+mO~Ok$dix$di~P$bOq+qOP#eyT#eyd#eyf#eyl#eyp#eys#eyu#ey}#ey!O#ey!S#ey!T#ey!W#ey![#ey!g#ey!n#ey!o#ey!p#ey!w#ey!y#ey!{#ey!}#ey#P#ey#T#ey#V#ey#Y#ey#Z#ey#]#ey#d#ey#g#ey#k#ey#m#ey#r#ey#u#ey$i#ey$j#ey$|#ey$}#ey%R#ey%S#ey%g#ey%h#ey%k#ey%n#ey%t#ey%w#ey%y#ey$m#ey$n#ey$o#ey~O$m+vO$n*wO$o+vO~O#i+wOP#fyT#fyd#fyf#fyl#fyp#fys#fyu#fy}#fy!O#fy!S#fy!T#fy!W#fy![#fy!g#fy!n#fy!o#fy!p#fy!w#fy!y#fy!{#fy!}#fy#P#fy#T#fy#V#fy#Y#fy#Z#fy#]#fy#d#fy#g#fy#k#fy#m#fy#r#fy#u#fy$i#fy$j#fy$|#fy$}#fy%R#fy%S#fy%g#fy%h#fy%k#fy%n#fy%t#fy%w#fy%y#fy$m#fy$n#fy$o#fy~Ox'VOy&Rq~O%X+ROx&Ta!P&Ta~Ox$gX!P$gX~P!IxOx+VO!P&Sa~Ol,qOs-OOy,POx$Oi!X$Oi~P'UOl,qOs-OOx$Oi!X$Oi~P'UOy,POx$Oi!X$Oi~Ox'eO!X%eq~Ol,qOs-OOx'eO!X%eq~P'UOp,UO!S%cO!T%bO!P%]q!X%]q!]%]qx%]q~P!/pOx#|i!]#|i~P$bO#W,YOx$_a#_$_a$j$_a$m$_a!P$_a~Ox*fO#_%}i$j%}i$m%}i!P%}i~O!P,[O~Oq,^OP#e!RT#e!Rd#e!Rf#e!Rl#e!Rp#e!Rs#e!Ru#e!R}#e!R!O#e!R!S#e!R!T#e!R!W#e!R![#e!R!g#e!R!n#e!R!o#e!R!p#e!R!w#e!R!y#e!R!{#e!R!}#e!R#P#e!R#T#e!R#V#e!R#Y#e!R#Z#e!R#]#e!R#d#e!R#g#e!R#k#e!R#m#e!R#r#e!R#u#e!R$i#e!R$j#e!R$|#e!R$}#e!R%R#e!R%S#e!R%g#e!R%h#e!R%k#e!R%n#e!R%t#e!R%w#e!R%y#e!R$m#e!R$n#e!R$o#e!R~Ol,qOs-OOx$Oq!X$Oq~P'UOy,cOx$Oq!X$Oq~Ox'eO!X%ey~Ol,qOs,gO~P'UOp,UO!S%cO!T%bO!P%]y!X%]y!]%]yx%]y~P!/pOx*fO#_%}q$j%}q$m%}q!P%}q~Ol,qOs-OOx$Oy!X$Oy~P'UOx'eO!X%e!R~Op%`X!P%`X!S%`X!T%`X!X%`X!]%`Xx%`X~P!/pOp,UO!S%cO!T%bO!P%_a!X%_a!]%_ax%_a~Oy,oO~Ox(lO#_$ua$j$ua$m$ua%X$ua~P$bOk,vO~Ol,vO~P'UOy,wO~Oq,xO~P!/pO%h%k%w%y%g%n%t%S%g~",
  goto: "!&h&UPPPP&VP&_(|)d){*e+O+jP,VP&_,t,t&_P&_P/cPPPPPP/c1bPP1bP2}P3W7`PP7c7o7rPPP&_&_PP8O&_PP&_&_PP&_&_&_&_8S8x&_P8{P9O9O;qP<V&_PPP<Z<a&VP&V&VP&VP&VP&VP&VP&V&V&VP&VPP&VPP&VP<gP<n<tP<nP<n<nPPP<nP>mP>v>|?S>mP<n?YP?a?g?m?y@T@Z@e@o@uAcAiAoAuBPBVB]BcBiBoCRC]CcCiCoCyDPDVD]DcDmDsD}ETPPPPPPPPPE^EhEqE{FWPPPPPPPPPPPPI}JgNU!!qPP!!y!#X!#b!$W!#}!$a!$g!$j!$m!$p!$vPPPPPPPPPP!$y!$|PPPPPPPPP!%S!%`!%l!%x!%{!&R!&X!&_!&b]iOr#m$m'Q*w&XdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-Py!cP#i#v$X$g%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u{!dP#i#v$X$g$s%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u}!eP#i#v$X$g$s$t%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!P!fP#i#v$X$g$s$t$u%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!R!gP#i#v$X$g$s$t$u$v%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!T!hP#i#v$X$g$s$t$u$v$w%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!X!iP!n#i#v$X$g$s$t$u$v$w$x%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u&XSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-P$yUOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-P$TWOXYZhrv|}!R!S!T!X!j!l#]#j#m$P$R$T$W$k$m$|%R%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){*O*]*e*w+S+Z+[+`+e+|,P,c,w,xQ#|uQ,m,gR,|-O&SdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PW#pl!O!P$_W#xu&_,g-OQ$a!QQ$q!YQ$r!ZS${!j'bS&^#y#zQ'O$lQ(e&WQ(r&nW(s&p(t(u*kQ(v&rQ)b'XS)c'Z+VS+U)d)eQ+j*fQ+l*hQ+x*}Q+z+PR,j,YR&]#xe!wXY!S!T%_%f's({){*OR%]!vQ!{XQ%x#]Q&f$TR&i$WT,f,U,o!Y!kP!n#i#v$X$g$s$t$u$v$w$x$y%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,uQ&Z#qR'^$rR'a${R%U!m&WcOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PT#gc#hS#^_#_S#a`#bS#ca#dS#eb#fT*`(`*aT(a%x(cQ$VwR+T)cX$Tw$U$V&hZkOr$m'Q*wXoOr'Q*wQ$n!WQ&v$eQ&w$fQ'Y$pQ']$rQ)U&}Q)['SQ)^'TQ)_'UQ)k'[Q)m'^Q*n({Q*p(|Q*q(}Q*s)SS*u)V)lQ*z)YQ*{)ZQ*|)]Q+o*mQ+p*oQ+r*tQ+s*vQ+y+OQ,]+qQ,_+wQ,`+xR,k,^WoOr'Q*wR#snQ'[$qR)V'OQ+S)cR+|+TQ)l'[R*v)VZmOnr'Q*wQrOR#urQ&`#{R(j&`S%l#Q#}S(T%l(WT(W%o&bQ%`!yS't%`'yR'y%dQ&k$XR(o&kQ%g!|S'}%g(PR(P%iQ(Z%pQ*T(UT*Y(Z*TQ'c$}R)p'cS'f%Q%RY)s'f)t+^,S,dU)t'g'h'iU+^)u)v)wS,S+_+`R,d,TQ#X]R%s#XQ#[^R%u#[Q#__R%y#_Q(^%vS*^(^*_R*_(_Q*a(`R+h*aQ#b`R%{#bQ#daR%|#dQ#fbR%}#fQ#hcR&O#hQ#kfQ&P#iW&S#k&P(m*dQ(m&eR*d,uQ$UwS&g$U&hR&h$VQ&u$cR(y&uQ&X#pR(f&XQ$_!PR&o$_Q*g(sS+k*g,ZR,Z+lQ&s$aR(w&sQ#njR&U#nQ*x)WR+u*xQ(z&vR*l(zQ&y$gS)Q&y)RR)R&zQ'R$nR)X'RQ'W$oS)a'W+QR+Q)bQ+W)gR,O+WWnOr'Q*wR#rnSqOrQ)W'QR+t*wWpOr'Q*wR'P$mYjOr$m'Q*wR&T#m[wOr#m$m'Q*wR&f$T$xPOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-PQ!nSQ#ieQ#vsU$Xx%b'wS$g!U$jQ$s!cQ$t!dQ$u!eQ$v!fQ$w!gQ$x!hQ$y!iQ%d!zQ%i!}Q%o#RQ%p#SQ&b$OQ&z$hQ(d&QQ(n&jQ)O&xQ)y'qQ*Q'|Q*S(SQ*r)PQ+f*XR,u,yQ!yXQ!|YQ$e!SQ$f!TW'p%_'s){*OQ'{%fR*o({[fOr#m$m'Q*wd!vXY!S!T%_%f's({){*OQ#QZQ#lhS#}v|Q$[}W$c!R$W&{)TS$o!X$kS$z!j'bQ%Q!lQ%v#]S&R#j(lQ&c$PQ&d$RQ&e$TQ'_$|Q'i%RQ'o%]Q(R%kQ(U%mQ(_%wQ(h&]S(k&a,wQ(p&lQ(q&mQ(x&tQ)]'SQ)`'VQ)n'aQ)q'eQ)v'gQ)w'hS)x'l,xQ*W(YQ*[(]Q+Y)jQ+])rQ+_)uQ+g*]Q+i*eQ+{+SQ,Q+ZQ,R+[Q,T+`Q,X+eQ,a+|Q,b,PR,l,cbTOr#j#m$m&a'Q'l*w#p!uXYZhv|}!R!S!T!X!j!l#]$P$R$T$W$k$|%R%]%_%f%k%m%w&]&l&m&t&{'S'V'a'b'e'g'h's(Y(](l({)T)j)r)u){*O*]*e+S+Z+[+`+e+|,P,c,w,xQ#wtW%V!o!s,r,{Q%W!pQ%X!qQ%Z!tQ%e,qS'k%Y,vQ'm,sQ'n,tQ+a)|Q,W+bS,e,U,oR,}-PU#{u,g-OR(i&_[gOr#m$m'Q*wX!xX#]$T$WQ#VZQ$QvR$Z|Q%a!yQ%h!|Q%n#QQ'_$zQ'z%dQ(Q%iQ(X%oQ([%pQ*U(UQ,V+aQ,i,WR,n,hQ$YxQ'v%bR)}'wQ,h,UR,p,oR#PYR#UZR%P!jQ$}!jR)o'bR%S!lR%x#]Q(b%xR*c(cQ$d!RQ&i$WQ)S&{R*t)TQ#qlQ$]!OQ$`!PR&q$_Q(r&pQ*i(tQ*j(uR+n*kR$b!QXpOr'Q*wQ$i!UR&|$jQ$p!XR&}$kR)i'ZQ)g'ZR+}+V",
  nodeNames: "⚠ print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ParenthesizedExpression ( BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList self VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from ) TupleExpression ComprehensionExpression async for LambdaExpression ArrayExpression [ ] ArrayComprehensionExpression DictionaryExpression { } DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
  maxTerm: 236,
  nodeProps: [
    [lezer.NodeProp.group, -14,4,81,83,84,86,88,90,92,94,95,96,98,101,104,"Statement Statement",-23,6,16,19,21,37,38,48,49,53,56,57,60,61,62,63,66,69,70,71,75,76,77,78,"Expression",-9,106,108,111,113,114,118,120,125,127,"Statement"]
  ],
  skippedNodes: [0,2],
  repeatNodeCount: 33,
  tokenData: "!E}MgR!^OX$}XY%wY[$}[]%w]p$}pq%wqr(crs*Ust2Otu$}uv4Qvw5Uwx5xxyAWyzAtz{Bb{|Cr|}Df}!OES!O!PFZ!P!QKa!Q!RLq!R![!(P![!]!)i!]!^!*m!^!_!+Z!_!`!,k!`!a!-_!a!b$}!b!c!.l!c!d!/b!d!e!1f!e!h!/b!h!i!8O!i!t!/b!t!u!=b!u!w!/b!w!x!?`!x!}!/b!}#O!@t#O#P!Ab#P#Q!Bc#Q#R!CP#R#S!/b#S#T$}#T#U!/b#U#V!1f#V#Y!/b#Y#Z!8O#Z#f!/b#f#g!=b#g#i!/b#i#j!?`#j#o!/b#o#p!Cs#p#q!D[#q#r!EO#r#s!Ea#s$g$}$g~!/b<r%`R%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i7[%nR%r7[O#o%i#p#q%i#r~%iMg&[Z%o`%up%r7[%x!b%z#t%iS%lW$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'UZ%r7[$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'|V%r7[OY%iYZ&}Z]%i]^&}^#o%i#p#q%i#r~%i<u(tY%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#T%i#T#U)t#U#f%i#f#g)t#g#h)t#h#o%i#p#q%i#r~%i7_)kRjR%r7[O#o%i#p#q%i#r~%i7_){R!kR%r7[O#o%i#p#q%i#r~%iG{*e]%vp%o`%r7[%x!b%iS%g,XOY+^YZ.{Z]+^]^.{^r+^rs/]s#O+^#O#P0|#P#o+^#o#p1b#p#q+^#q#r1b#r~+^Bm+g]%r7[%lW%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be,g]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be-gR%r7[%g,XO#o%i#p#q%i#r~%iBe-uT%r7[O#o,`#o#p.U#p#q,`#q#r.U#r~,`,X.ZV%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.U,X.uO%g,X,X.xPO~.U7d/SR%r7[%lWO#o%i#p#q%i#r~%iEc/dX%r7[%g,XOr.{rs0Ps#O.{#O#P0c#P#o.{#o#p0w#p#q.{#q#r0w#r~.{Ec0YR%m#|%r7[%k,XO#o%i#p#q%i#r~%i7d0hT%r7[O#o.{#o#p0w#p#q.{#q#r0w#r~.{W0|O%lWBm1RT%r7[O#o+^#o#p1b#p#q+^#q#r1b#r~+^,a1iV%lW%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.UMg2cXQ1s%o`%up%r7[%x!b%z#t%iS%lWOY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3OHP3VXQ1s%r7[OY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3O1s3wRQ1sOY3rZ]3r^~3rGz4eT%PQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iBd4{R!t,W%r7[O#o%i#p#q%i#r~%iGz5iT$yQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{6X_%s`%up%r7[%z#t%lW%g,XOY7WYZ:dZ]7W]^:d^r7Wrs:xsw7Wwx;|x#O7W#O#P>n#P#o7W#o#p?t#p#q7W#q#r?S#r~7WFq7e]%r7[%x!b%z#t%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be8e]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be9cT%r7[O#o8^#o#p9r#p#q8^#q#r9r#r~8^,X9wV%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r,X:aPO~9r;h:oR%r7[%x!b%z#t%iSO#o%i#p#q%i#r~%iC{;T]%r7[%x!b%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Fq<VZ%r7[%z#t%g,XOr:drs<xsw:dwx=[x#O:d#O#P=p#P#o:d#o#p>_#p#q:d#q#r>U#r~:d8r=RR%r7[%x!b%iSO#o%i#p#q%i#r~%iFq=gR%j!f%r7[%z#t%h,XO#o%i#p#q%i#r~%i;h=uT%r7[O#o:d#o#p>U#p#q:d#q#r>U#r~:d%[>_O%x!b%z#t%iS%[>dP%iS#o#p>g%W>nO%x!b%z#tFq>sT%r7[O#o7W#o#p?S#p#q7W#q#r?S#r~7W0e?_V%x!b%z#t%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r0e?{X%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P#o9r#o#p@h#p~9r0a@qV%x!b%z#t%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9rG{AkRf,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i<uBXR!PR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{BuVT,X%o`%up%r7[%x!b%z#t%iS%lWOz%iz{C[{!_%i!_!`4t!`#o%i#p#q%i#r~%iBeCcT_R%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DVT$|,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DyRx,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMgEgU$},X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`!aEy!a#o%i#p#q%i#r~%i<vFQR&U&j%r7[O#o%i#p#q%i#r~%iG{FnV!eQ%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!PGT!P!Q%i!Q![Gy![#o%i#p#q%i#r~%iBeGYT%r7[O!O%i!O!PGi!P#o%i#p#q%i#r~%iBeGpR!n,X%r7[O#o%i#p#q%i#r~%iBcHQ_!g,V%r7[O!Q%i!Q![Gy![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#SGy#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBcIUX%r7[O{%i{|Iq|}%i}!OIq!O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcIvT%r7[O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcJ^Z!g,V%r7[O!Q%i!Q![JV![!l%i!l!mKP!m#R%i#R#SJV#S#^%i#^#_KP#_#o%i#p#q%i#r~%iBcKWR!g,V%r7[O#o%i#p#q%i#r~%iG{KtV%OR%o`%up%r7[%x!b%z#t%iS%lWO!P%i!P!QLZ!Q!_%i!_!`4t!`#o%i#p#q%i#r~%iBdLbT%QQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iGyMUm!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!d%i!d!e!#w!e!g%i!g!hIP!h!l%i!l!mKP!m!q%i!q!r!%V!r!z%i!z!{!&_!{#R%i#R#S!!k#S#U%i#U#V!#w#V#X%i#X#YIP#Y#^%i#^#_KP#_#c%i#c#d!%V#d#l%i#l#m!&_#m#o%i#p#q%i#r~%iBc! UT%r7[O!Q%i!Q![! e![#o%i#p#q%i#r~%iBc! l_!g,V%r7[O!Q%i!Q![! e![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S! e#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!!ra!g,V%r7[O!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!#|W%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!$mW!g,V%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!%[V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!%xV!g,V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!&dZ%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iBc!'^Z!g,V%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iGy!(da!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iMg!)|Ty1s%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`!*]!`#o%i#p#q%i#r~%i7_!*dR%YR%r7[O#o%i#p#q%i#r~%iG{!+QR#_,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{!+nVjR%o`%up%r7[%x!b%z#t%iS%lWO!^%i!^!_!,T!_!`)d!`!a)d!a#o%i#p#q%i#r~%iBd!,[T$zQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!-OT%X,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#o%i#p#q%i#r~%iG{!-rUjR%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`!a!.U!a#o%i#p#q%i#r~%iBd!.]T${Q%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!/RT]Q#uP%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iMg!/wZ%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jHP!0sZ%r7[%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!1{c%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!6v#g#o!0j#p#q%i#r$g%i$g~!0jBe!3_]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs!4Ws#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be!4_T%r7[%g,XOr%irs!4ns#o%i#p#q%i#r~%iBe!4uR%r7[%k,XO#o%i#p#q%i#r~%iBe!5V]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx!6Ox#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be!6VT%r7[%g,XOw%iwx!6fx#o%i#p#q%i#r~%iBe!6mR%r7[%h,XO#o%i#p#q%i#r~%iHP!7P_%r7[%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!8ec%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!t!0j!t!u!<Y!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!<Y#g#o!0j#p#q%i#r$g%i$g~!0jBe!9wT%r7[%t,XOr%irs!:Ws#o%i#p#q%i#r~%iBe!:]T%r7[Or%irs!:ls#o%i#p#q%i#r~%iBe!:sR%r7[%y,XO#o%i#p#q%i#r~%iBe!;TT%r7[%n,XOw%iwx!;dx#o%i#p#q%i#r~%iBe!;iT%r7[Ow%iwx!;xx#o%i#p#q%i#r~%iBe!<PR%r7[%w,XO#o%i#p#q%i#r~%iHP!<c_%r7[%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!=wg%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!h!0j!h!i!<Y!i!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#U!0j#U#V!6v#V#Y!0j#Y#Z!<Y#Z#o!0j#p#q%i#r$g%i$g~!0jMg!?u_%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jG{!AXR!W,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMg!AgX%r7[OY$}YZ%wZ]$}]^%w^#o$}#o#p!BS#p#q$}#q#r!BS#r~$}&f!BcO%o`%up%x!b%z#t%iS%lW<u!BvR!XR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iGz!CdT$xQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iGy!C|P![Gm%iS%lW#o#p!DP&Y!D[O%o`%up%x!b%z#tGz!DoT$wQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%i<u!EaO!]7_%o`%up%x!b%z#t%iS%lWGy!EtR%R,V%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i",
  tokenizers: [legacyPrint, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines, bodyContinue],
  topRules: {"Script":[0,3]},
  specialized: [{term: 188, get: value => spec_identifier[value] || -1}],
  tokenPrec: 6076
});

exports.parser = parser;


/***/ }),

/***/ "./node_modules/lezer-tree/dist/tree.cjs":
/*!***********************************************!*\
  !*** ./node_modules/lezer-tree/dist/tree.cjs ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

/// The default maximum length of a `TreeBuffer` node.
const DefaultBufferLength = 1024;
let nextPropID = 0;
const CachedNode = new WeakMap();
/// Each [node type](#tree.NodeType) can have metadata associated with
/// it in props. Instances of this class represent prop names.
class NodeProp {
    /// Create a new node prop type. You can optionally pass a
    /// `deserialize` function.
    constructor({ deserialize } = {}) {
        this.id = nextPropID++;
        this.deserialize = deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// Create a string-valued node prop whose deserialize function is
    /// the identity function.
    static string() { return new NodeProp({ deserialize: str => str }); }
    /// Create a number-valued node prop whose deserialize function is
    /// just `Number`.
    static number() { return new NodeProp({ deserialize: Number }); }
    /// Creates a boolean-valued node prop whose deserialize function
    /// returns true for any input.
    static flag() { return new NodeProp({ deserialize: () => true }); }
    /// Store a value for this prop in the given object. This can be
    /// useful when building up a prop object to pass to the
    /// [`NodeType`](#tree.NodeType) constructor. Returns its first
    /// argument.
    set(propObj, value) {
        propObj[this.id] = value;
        return propObj;
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#tree.NodeSet.extend) or
    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop
    /// values for each node type in the set. Takes a [match
    /// object](#tree.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src)
                    src[0].set(props, src[1]);
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#tree.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#tree.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a number array. Each parser
/// [has](#lezer.Parser.nodeSet) a node set, and [tree
/// buffers](#tree.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536)
/// node types in it, so that the ids fit into 16-bit typed array
/// slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#tree.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    add[0].set(newProps, add[1]);
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the `TreeCursor` interface instead, which provides a view on
/// some part of this data structure, and can be used to move around
/// to adjacent nodes.
class Tree {
    /// Construct a new tree. You usually want to go through
    /// [`Tree.build`](#tree.Tree^build) instead.
    constructor(type, 
    /// The tree's child nodes. Children small enough to fit in a
    /// `TreeBuffer will be represented as such, other children can be
    /// further `Tree` instances with their own internal structure.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
    }
    /// @internal
    toString() {
        let children = this.children.map(c => c.toString()).join();
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular
    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)
    /// nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, true);
    }
    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#tree.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        return this.cursor(pos, side).node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, the given node
    /// will not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor();;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Balance the direct children of this tree.
    balance(maxBufferLength = DefaultBufferLength) {
        return this.children.length <= BalanceBranchFactor ? this
            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer @internal
    constructor(
    /// @internal
    buffer, 
    // The total length of the group of nodes in the buffer.
    length, 
    /// @internal
    set, type = NodeType.none) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
        this.type = type;
    }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, after) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (after != -100000000 /* None */) {
                let start = buffer[i + 1], end = buffer[i + 2];
                if (dir > 0) {
                    if (end > after)
                        pick = i;
                    if (end > after)
                        break;
                }
                else {
                    if (start < after)
                        pick = i;
                    if (end >= after)
                        break;
                }
            }
            else {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
}
class TreeNode {
    constructor(node, from, index, _parent) {
        this.node = node;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get to() { return this.from + this.node.length; }
    nextChild(i, dir, after, full = false) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))
                    continue;
                if (next instanceof TreeBuffer) {
                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if (full || (!next.type.isAnonymous || hasChild(next))) {
                    let inner = new TreeNode(next, start, i, parent);
                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
                }
            }
            if (full || !parent.type.isAnonymous)
                return null;
            i = parent.index + dir;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }
    childAfter(pos) { return this.nextChild(0, 1, pos); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
    }
    get prevSibling() {
        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, after) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, -100000000 /* None */); }
    get lastChild() { return this.child(-1, -100000000 /* None */); }
    childAfter(pos) { return this.child(1, pos); }
    childBefore(pos) { return this.child(-1, pos); }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, full = false) {
        this.full = full;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enter(dir, after) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enter(1, -100000000 /* None */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enter(-1, -100000000 /* None */); }
    /// Move the cursor to the first child that starts at or after `pos`.
    childAfter(pos) { return this.enter(1, pos); }
    /// Move to the last child that ends at or before `pos`.
    childBefore(pos) { return this.enter(-1, pos); }
    /// Move the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                let child = parent.node.children[i];
                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
                    return false;
            }
        }
        return true;
    }
    move(dir) {
        if (this.enter(dir, -100000000 /* None */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty, its next sibling or the next sibling of
    /// the first parent node that has one.
    next() { return this.move(1); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by ist last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev() { return this.move(-1); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        for (;;) {
            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
                break;
            if (this.from == this.to ||
                (side < 1 ? this.from >= pos : this.from > pos) ||
                (side > -1 ? this.to <= pos : this.to < pos)) {
                this.parent();
                break;
            }
        }
        return this;
    }
    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#tree.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#tree.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
const BalanceBranchFactor = 8;
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        while (id == inRepeat) {
            cursor.next();
            ({ id, start, end, size } = cursor);
        }
        let startPos = start - parentStart;
        if (size < 0) { // Reused node
            children.push(reused[id]);
            positions.push(startPos);
            cursor.next();
            return;
        }
        let type = types[id], node, buffer;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index, inRepeat);
            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            while (cursor.pos > endPos)
                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);
            else
                node = new Tree(type, localChildren, localPositions, end - start);
        }
        children.push(node);
        positions.push(startPos);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let nodeSize = fork.size, startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0)
                    break scan;
                if (fork.id >= minRepeatType)
                    localSkipped += 4;
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index, inRepeat) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (id == inRepeat)
            return index;
        let startIndex = index;
        if (size > 4) {
            let endPos = cursor.pos - (size - 4);
            while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer, index, inRepeat);
        }
        if (id < minRepeatType) { // Don't copy repeat nodes into buffers
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {
    let localChildren = [], localPositions = [];
    if (length <= maxBufferLength) {
        for (let i = from; i < to; i++) {
            localChildren.push(children[i]);
            localPositions.push(positions[i] - start);
        }
    }
    else {
        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i];
            i++;
            for (; i < to; i++) {
                let nextEnd = positions[i] + children[i].length;
                if (nextEnd - groupStart > maxChild)
                    break;
            }
            if (i == groupFrom + 1) {
                let only = children[groupFrom];
                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse
                    for (let j = 0; j < only.children.length; j++) {
                        localChildren.push(only.children[j]);
                        localPositions.push(only.positions[j] + groupStart - start);
                    }
                    continue;
                }
                localChildren.push(only);
            }
            else if (i == groupFrom + 1) {
                localChildren.push(children[groupFrom]);
            }
            else {
                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart);
                if (innerType != NodeType.none && !containsType(inner.children, innerType))
                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);
                localChildren.push(inner);
            }
            localPositions.push(groupStart - start);
        }
    }
    return new Tree(outerType, localChildren, localPositions, length);
}
function containsType(nodes, type) {
    for (let elt of nodes)
        if (elt.type == type)
            return true;
    return false;
}
/// Tree fragments are used during [incremental
/// parsing](#lezer.ParseOptions.fragments) to track parts of old
/// trees that can be reused in a new parse. An array of fragments is
/// used to track regions of an old tree whose nodes might be reused
/// in new parses. Use the static
/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update
/// fragments for document changes.
class TreeFragment {
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, open) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = open;
    }
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        let cI = 0, pos = 0, off = 0;
        for (;;) {
            let nextC = cI < changes.length ? changes[cI++] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null :
                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the token at its
    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
}
// Creates an `Input` that is backed by a single, flat string.
function stringInput(input) { return new StringInput(input); }
class StringInput {
    constructor(string, length = string.length) {
        this.string = string;
        this.length = length;
    }
    get(pos) {
        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
    }
    lineAfter(pos) {
        if (pos < 0)
            return "";
        let end = this.string.indexOf("\n", pos);
        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
    }
    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }
    clip(at) { return new StringInput(this.string, at); }
}

exports.DefaultBufferLength = DefaultBufferLength;
exports.NodeProp = NodeProp;
exports.NodeSet = NodeSet;
exports.NodeType = NodeType;
exports.Tree = Tree;
exports.TreeBuffer = TreeBuffer;
exports.TreeCursor = TreeCursor;
exports.TreeFragment = TreeFragment;
exports.stringInput = stringInput;
//# sourceMappingURL=tree.cjs.map


/***/ }),

/***/ "./node_modules/lezer/dist/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/lezer/dist/index.cjs ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezerTree = __webpack_require__(/*! lezer-tree */ "./node_modules/lezer-tree/dist/tree.cjs");

/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// A group of values that the stack will share with all
    /// split instances
    ///@internal
    cx, 
    /// Holds state, pos, value stack pos (15 bits array index, 15 bits
    /// buffer index) triplets for all but the top state
    /// @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.cx = cx;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(cx, state, pos = 0) {
        return new Stack(cx, [], state, pos, pos, 0, [], 0, null);
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.cx;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let start = this.pos, nextState = action, { parser } = this.cx;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            if (next <= this.cx.parser.maxNode)
                this.buffer.push(next, this.pos, nextEnd, 4);
            this.pos = nextEnd;
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt node into the buffer. This may be a reused node or
    // the result of running a nested parser.
    /// @internal
    useNode(value, next) {
        let index = this.cx.reused.length - 1;
        if (index < 0 || this.cx.reused[index] != value) {
            this.cx.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.cx.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 200 /* Token */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    /// Find the start position of the rule that is currently being parsed.
    get ruleStart() {
        for (let state = this.state, base = this.stack.length;;) {
            let force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);
            if (!(force & 65536 /* ReduceFlag */))
                return 0;
            base -= 3 * (force >> 19 /* ReduceDepthShift */);
            if ((force & 65535 /* ValueMask */) < this.cx.parser.minRepeatTerm)
                return this.stack[base + 1];
            state = this.stack[base];
        }
    }
    /// Find the start position of an instance of any of the given term
    /// types, or return `null` when none of them are found.
    ///
    /// **Note:** this is only reliable when there is at least some
    /// state that unambiguously matches the given rule on the stack.
    /// I.e. if you have a grammar like this, where the difference
    /// between `a` and `b` is only apparent at the third token:
    ///
    ///     a { b | c }
    ///     b { "x" "y" "x" }
    ///     c { "x" "y" "z" }
    ///
    /// Then a parse state after `"x"` will not reliably tell you that
    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check
    /// for either of those two rules (assuming that `a` isn't part of
    /// some rule that includes other things starting with `"x"`).
    ///
    /// When `before` is given, this keeps scanning up the stack until
    /// it finds a match that starts before that position.
    startOf(types, before) {
        let state = this.state, frame = this.stack.length, { parser } = this.cx;
        for (;;) {
            let force = parser.stateSlot(state, 5 /* ForcedReduce */);
            let depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;
            if (types.indexOf(term) > -1) {
                let base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];
                if (before == null || before > pos)
                    return pos;
            }
            if (frame == 0)
                return null;
            if (depth == 0) {
                frame -= 3;
                state = this.stack[frame];
            }
            else {
                frame -= 3 * (depth - 1);
                state = parser.getGoto(this.stack[frame - 3], term, true);
            }
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.cx.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next));
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)
                    if (best.indexOf(nextStates[i]) < 0)
                        best.push(nextStates[i]);
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {
            if (nextStates[i] == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(nextStates[i], this.pos);
            stack.score -= 200 /* Token */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        if (!this.cx.parser.validAction(this.state, reduce)) {
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.cx;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.cx.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.cx.parser.dialect.flags[dialectID]; }
}
var Recover;
(function (Recover) {
    Recover[Recover["Token"] = 200] = "Token";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(stack) {
        this.stack = stack;
        this.top = stack.state;
        this.rest = stack.stack;
        this.offset = this.rest.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.rest == this.stack.stack)
                this.rest = this.rest.slice();
            this.rest.push(this.top, 0, 0);
            this.offset += 3;
        }
        else {
            this.offset -= (depth - 1) * 3;
        }
        let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);
        this.top = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack) {
        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

/// Tokenizers write the tokens they read into instances of this class.
class Token {
    constructor() {
        /// The start of the token. This is set by the parser, and should not
        /// be mutated by the tokenizer.
        this.start = -1;
        /// This starts at -1, and should be updated to a term id when a
        /// matching token is found.
        this.value = -1;
        /// When setting `.value`, you should also set `.end` to the end
        /// position of the token. (You'll usually want to use the `accept`
        /// method.)
        this.end = -1;
    }
    /// Accept a token, setting `value` and `end` to the given values.
    accept(value, end) {
        this.value = value;
        this.end = end;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, token, stack) { readToken(this.data, input, token, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// Exports that are used for `@external tokens` in the grammar should
/// export an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream and a token object,
    /// [fills](#lezer.Token.accept) the token object if it recognizes a
    /// token. `token.start` should be used as the start position to
    /// scan from.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, token, stack, group) {
    let state = 0, groupMask = 1 << group, dialect = stack.cx.parser.dialect;
    scan: for (let pos = token.start;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value))) {
                    token.accept(term, pos);
                    break;
                }
            }
        let next = input.get(pos++);
        // Do a binary search on the state's edges
        for (let low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError)
                    return side < 0 ? cursor.to - 1 : cursor.from + 1;
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments) {
        this.fragments = fragments;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            else if (start == pos && start + next.length <= this.safeTo) {
                return start == pos && start >= this.safeFrom ? next : null;
            }
            if (next instanceof lezerTree.TreeBuffer) {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
            else {
                this.index[last]++;
                if (start + next.length >= pos) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
        }
    }
}
class CachedToken extends Token {
    constructor() {
        super(...arguments);
        this.extended = -1;
        this.mask = 0;
    }
    clear(start) {
        this.start = start;
        this.value = this.extended = -1;
    }
}
const dummyToken = new Token;
class TokenCache {
    constructor(parser) {
        this.tokens = [];
        this.mainToken = dummyToken;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack, input) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.cx, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {
                this.updateCachedToken(token, tokenizer, stack, input);
                token.mask = mask;
            }
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (!main) {
            main = dummyToken;
            main.start = stack.pos;
            if (stack.pos == input.length)
                main.accept(stack.cx.parser.eofTerm, stack.pos);
            else
                main.accept(0 /* Err */, stack.pos + 1);
        }
        this.mainToken = main;
        return this.actions;
    }
    updateCachedToken(token, tokenizer, stack, input) {
        token.clear(stack.pos);
        tokenizer.token(input, token, stack);
        if (token.value > -1) {
            let { parser } = stack.cx;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](input.read(token.start, token.end), stack);
                    if (result >= 0 && stack.cx.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else if (stack.pos == input.length) {
            token.accept(stack.cx.parser.eofTerm, stack.pos);
        }
        else {
            token.accept(0 /* Err */, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.cx, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 1), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec[Rec["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));
/// A parse context can be used for step-by-step parsing. After
/// creating it, you repeatedly call `.advance()` until it returns a
/// tree to indicate it has reached the end of the parse.
class Parse {
    constructor(parser, input, startPos, context) {
        this.parser = parser;
        this.input = input;
        this.startPos = startPos;
        this.context = context;
        // The position to which the parse has advanced.
        this.pos = 0;
        this.recovering = 0;
        this.nextStackID = 0x2654;
        this.nested = null;
        this.nestEnd = 0;
        this.nestWrap = null;
        this.reused = [];
        this.tokens = new TokenCache(parser);
        this.topTerm = parser.top[1];
        this.stacks = [Stack.start(this, parser.top[0], this.startPos)];
        let fragments = context === null || context === void 0 ? void 0 : context.fragments;
        this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        if (this.nested) {
            let result = this.nested.advance();
            this.pos = this.nested.pos;
            if (result) {
                this.finishNested(this.stacks[0], result);
                this.nested = null;
            }
            return null;
        }
        let stacks = this.stacks, pos = this.pos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        let maybeNest;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], nest;
            for (;;) {
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (nest = this.checkNest(stack)) {
                    if (!maybeNest || maybeNest.stack.score < stack.score)
                        maybeNest = nest;
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.mainToken;
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (maybeNest) {
            this.startNested(maybeNest);
            return null;
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.pos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.pos)
                this.pos = newStacks[i].pos;
        return null;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { input, parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.fragments) {
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof lezerTree.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof lezerTree.Tree)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        let actions = this.tokens.getActions(stack, input);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            let nest = this.checkNest(stack);
            if (nest)
                return nest;
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        let maybeNest;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    continue;
                }
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    break;
                }
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.input.length > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        if (finished)
            return finished;
        if (maybeNest)
            for (let s of this.stacks)
                if (s.score > maybeNest.stack.score) {
                    maybeNest = undefined;
                    break;
                }
        if (maybeNest)
            this.startNested(maybeNest);
        return null;
    }
    forceFinish() {
        let stack = this.stacks[0].split();
        if (this.nested)
            this.finishNested(stack, this.nested.forceFinish());
        return this.stackToTree(stack.forceAll());
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack, pos = stack.pos) {
        return lezerTree.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.startPos,
            length: pos - this.startPos,
            minRepeatType: this.parser.minRepeatTerm });
    }
    checkNest(stack) {
        let info = this.parser.findNested(stack.state);
        if (!info)
            return null;
        let spec = info.value;
        if (typeof spec == "function")
            spec = spec(this.input, stack);
        return spec ? { stack, info, spec } : null;
    }
    startNested(nest) {
        let { stack, info, spec } = nest;
        this.stacks = [stack];
        this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
        this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
        if (spec.startParse) {
            this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
        }
        else {
            this.finishNested(stack);
        }
    }
    scanForNestEnd(stack, endToken, filter) {
        for (let pos = stack.pos; pos < this.input.length; pos++) {
            dummyToken.start = pos;
            dummyToken.value = -1;
            endToken.token(this.input, dummyToken, stack);
            if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
                return pos;
        }
        return this.input.length;
    }
    finishNested(stack, tree) {
        if (this.nestWrap)
            tree = new lezerTree.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
        else if (!tree)
            tree = new lezerTree.Tree(lezerTree.NodeType.none, [], [], this.nestEnd - stack.pos);
        let info = this.parser.findNested(stack.state);
        stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
        if (verbose)
            console.log(this.stackID(stack) + ` (via unnest)`);
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class Parser {
    /// @internal
    constructor(spec) {
        /// @internal
        this.bufferLength = lezerTree.DefaultBufferLength;
        /// @internal
        this.strict = false;
        this.nextStateCache = [];
        this.cachedDialect = null;
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let tokenArray = decodeArray(spec.tokenData);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        this.nodeSet = new lezerTree.NodeSet(nodeNames.map((name, i) => lezerTree.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {
            return { name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };
        });
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        for (let i = 0, l = this.states.length / 6 /* Size */; i < l; i++)
            this.nextStateCache[i] = null;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    /// Parse a given string or stream.
    parse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        let cx = new Parse(this, input, startPos, context);
        for (;;) {
            let done = cx.advance();
            if (done)
                return done;
        }
    }
    /// Start an incremental parse.
    startParse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        return new Parse(this, input, startPos, context);
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    findNested(state) {
        let flags = this.stateSlot(state, 0 /* Flags */);
        return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let cached = this.nextStateCache[state];
        if (cached)
            return cached;
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && result.indexOf(this.data[i + 1]) < 0)
                result.push(this.data[i + 1]);
        }
        let table = this.goto, max = table[0];
        for (let term = 0; term < max; term++) {
            for (let pos = table[term + 1];;) {
                let groupTag = table[pos++], target = table[pos++];
                for (let end = pos + (groupTag >> 1); pos < end; pos++)
                    if (table[pos] == state && result.indexOf(target) < 0)
                        result.push(target);
                if (groupTag & 1)
                    break;
            }
        }
        return this.nextStateCache[state] = result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(Parser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.nested)
            copy.nested = this.nested.map(obj => {
                if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))
                    return obj;
                return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };
            });
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// Tells you whether this grammar has any nested grammars.
    get hasNested() { return this.nested.length > 0; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        if (this.cachedDialect && this.cachedDialect.source == dialect)
            return this.cachedDialect;
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return this.cachedDialect = new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new Parser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        if (stack.pos == stack.cx.input.length &&
            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}

exports.NodeProp = lezerTree.NodeProp;
exports.NodeSet = lezerTree.NodeSet;
exports.NodeType = lezerTree.NodeType;
exports.Tree = lezerTree.Tree;
exports.TreeCursor = lezerTree.TreeCursor;
exports.ExternalTokenizer = ExternalTokenizer;
exports.Parser = Parser;
exports.Stack = Stack;
exports.Token = Token;
//# sourceMappingURL=index.cjs.map


/***/ }),

/***/ "./ast.ts":
/*!****************!*\
  !*** ./ast.ts ***!
  \****************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.countDefDeclStmts = void 0;
function countDefDeclStmts(stmts) {
    var f = function (acc, x) {
        var b = (function () {
            switch (x.tag) {
                case "define": return true;
                case "assign": return !(x.type_ == "");
                default: return false;
            }
        })();
        return (acc[0] && b) ? [true, acc[1] + 1] : [false, acc[1]];
    };
    return stmts.reduce(f, [true, 0])[1];
}
exports.countDefDeclStmts = countDefDeclStmts;


/***/ }),

/***/ "./compiler.ts":
/*!*********************!*\
  !*** ./compiler.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = exports.codeGenStmt = exports.hasReturns = exports.codeGenExpr = exports.run = void 0;
var wabt_1 = __importDefault(__webpack_require__(/*! wabt */ "wabt"));
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var parser_1 = __webpack_require__(/*! ./parser */ "./parser.ts");
var typechecker_1 = __webpack_require__(/*! ./typechecker */ "./typechecker.ts");
var errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
function run(watSource) {
    return __awaiter(this, void 0, void 0, function () {
        var wabtApi, parsed, binary, wasmModule;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, wabt_1.default()];
                case 1:
                    wabtApi = _a.sent();
                    parsed = wabtApi.parseWat("example", watSource);
                    binary = parsed.toBinary({});
                    return [4 /*yield*/, WebAssembly.instantiate(binary.buffer, {})];
                case 2:
                    wasmModule = _a.sent();
                    // This next line is wasm-interp
                    return [2 /*return*/, wasmModule.instance.exports._start()];
            }
        });
    });
}
exports.run = run;
// (window as any)["runWat"] = run;
function codeGenExpr(expr) {
    switch (expr.tag) {
        case "id":
            return ["(local.get $" + expr.name + ")"];
        case "literal": {
            var literal = expr.value;
            switch (literal.tag) {
                case "bool":
                    return (literal.value) ? ["(i32.const 1)"] : ["(i32.const 0)"];
                case "number":
                    return ["(i32.const " + literal.value + ")"];
                default:
                    throw new Error("None not implemented yet");
            }
        }
        case "call":
            return expr.arguments.map(codeGenExpr).flat().concat(["(call $" + expr.name + ")"]);
        case "uniop": {
            var instr = (function () {
                switch (expr.uniop) {
                    case "not":
                        return ["(i32.const 1)", "(i32.xor)"];
                    case "neg":
                        return ["(i32.const -1)", "(i32.mul)"];
                }
            })();
            var argExpr = codeGenExpr(expr.arg);
            return argExpr.concat(instr);
        }
        case "binop": {
            var argExpr1 = codeGenExpr(expr.arg1);
            var argExpr2 = codeGenExpr(expr.arg2);
            var args = argExpr1.concat(argExpr2);
            var binop = (function () {
                switch (expr.binop) {
                    case "+": return "add";
                    case "-": return "sub";
                    case "*": return "mul";
                    case "//": return "div_s";
                    case "%": return "rem_s";
                    case "==": return "eq";
                    case "!=": return "neq";
                    case "<=": return "le_s";
                    case ">=": return "ge_s";
                    case "<": return "lt_s";
                    case ">": return "gt_s";
                    case "is": throw new Error("Not implemented");
                }
            })();
            return args.concat(["(i32." + binop + ")"]);
        }
    }
}
exports.codeGenExpr = codeGenExpr;
function hasReturns(stmt) {
    switch (stmt.tag) {
        case "if":
            return !stmt.body1.every(function (s) { return !hasReturns(s); })
                || !stmt.body2.every(function (s) { return !hasReturns(s); })
                || !stmt.body1.every(function (s) { return s.tag != "return"; })
                || !stmt.body2.every(function (s) { return s.tag != "return"; });
        case "while":
            return !stmt.body.every(function (s) { return !hasReturns(s); })
                || !stmt.body.every(function (s) { return s.tag != "return"; });
        default:
            return false;
    }
}
exports.hasReturns = hasReturns;
function codeGenStmt(stmt) {
    switch (stmt.tag) {
        case "define": {
            var inputOutput = stmt.parameters.map(function (p) { return "(param $" + p.name + " i32)"; }).join(" ");
            // number of define statements
            var n = ast_1.countDefDeclStmts(stmt.body);
            var defStmts = stmt.body.slice(0, n);
            var rest_1 = stmt.body.slice(n);
            var decls = defStmts.filter(function (s) { return s.tag == "assign"; })
                .map(function (s) {
                if (s.tag != "assign") {
                    throw new Error("Compiler error. Check code.");
                }
                return "(local $" + s.name + " i32)";
            });
            var defs = defStmts.map(codeGenStmt).flat();
            var preamble = decls.concat(defs).map(function (s) { return "    " + s; });
            var distBetweenNestedReturn_1 = rest_1.map(function (k, i) { return [i, k]; })
                .filter(function (t) { return hasReturns(t[1]); })
                .reduce(function (acc, t) {
                var arr = acc[0].concat([t[0] - acc[1]]);
                return [arr, t[0]];
            }, [[], 0])[0];
            // manipulate the AST instead of doing this manually
            var addIfElseEnclosure_1 = function (code, dists) {
                var n = dists.shift();
                var currSlice = code.slice(0, n + 1);
                var maybeEarlyRet = currSlice.map(codeGenStmt).flat().map(function (s) { return "    " + s; });
                var remainder = code.slice(n + 1);
                var maybeSkip;
                if (dists.length > 0) {
                    maybeSkip = addIfElseEnclosure_1(remainder, dists).flat().map(function (s) { return "    " + s; });
                }
                else {
                    maybeSkip = remainder.map(codeGenStmt).flat().map(function (s) { return "    " + s; });
                }
                maybeSkip[maybeSkip.length - 1] += "))";
                var maybeBlock = ["(local.get $___EARLY_RET)", "(i32.const 1)",
                    "(i32.xor)", "(if", "  (then"]
                    .concat(maybeSkip)
                    .map(function (s) { return "    " + s; });
                return maybeEarlyRet.concat(maybeBlock);
            };
            var remainder = (function () {
                if (distBetweenNestedReturn_1.length > 0) {
                    return addIfElseEnclosure_1(rest_1, distBetweenNestedReturn_1);
                }
                else {
                    return rest_1.map(codeGenStmt).flat().map(function (s) { return "    " + s; });
                }
            })();
            // if any statement contains nested return statements
            if (!rest_1.every(function (s) { return !hasReturns(s); }) || rest_1[rest_1.length - 1].tag == "return") {
                inputOutput += " (result i32)";
                preamble.unshift("    (local $___RET_VAL i32)");
                preamble.unshift("    (local $___EARLY_RET i32)");
                preamble.push("    (i32.const 0)");
                preamble.push("    (local.set $___EARLY_RET)");
                remainder.push("    (local.get $___RET_VAL)");
            }
            remainder[remainder.length - 1] += ")";
            return (["  (func $" + stmt.name + " " + inputOutput]).concat(preamble, remainder);
        }
        case "return":
            // TODO: see if you can optimize away the last two instructions when there
            // is no branching
            return codeGenExpr(stmt.value).concat([
                "(local.set $___RET_VAL)",
                "(i32.const 1)",
                "(local.set $___EARLY_RET)"
            ]);
        case "assign": {
            return codeGenExpr(stmt.value).concat(["(local.set $" + stmt.name + ")"]);
        }
        case "expr":
            // the typechecker should prevent this EXCEPT for a lone expression at the
            // end of the program which will be implicitly returned
            // TODO: make into a print statement
            return codeGenExpr(stmt.expr).concat(["(local.set $___IMPL_RET)"]);
        case "if": {
            var pred = codeGenExpr(stmt.pred);
            var body1 = stmt.body1.map(codeGenStmt).flat().map(function (s) { return "    " + s; });
            body1[body1.length - 1] = body1[body1.length - 1] + ")";
            var body2 = stmt.body2.map(codeGenStmt).flat().map(function (s) { return "    " + s; });
            body2[body2.length - 1] = body2[body2.length - 1] + "))";
            var thenCl = (body1.length > 0) ? "  (then" : "  (then)";
            var elseCl = (body2.length > 0) ? "  (else" : "  (else))";
            return (pred).concat(["(if", thenCl], body1, [elseCl], body2);
        }
        case "while": {
            var pred = codeGenExpr(stmt.pred);
            var body = stmt.body
                .map(codeGenStmt)
                .flat()
                .concat(pred, ["(i32.const 1)", "(i32.xor)", "(br_if 1)", "(br 0))))"])
                .map(function (s) { return "      " + s; });
            return (pred).concat(["(if", "  (then", "    (loop"], body);
        }
        case "pass": return [];
    }
}
exports.codeGenStmt = codeGenStmt;
function compile(source) {
    var ast = parser_1.parseProgram(source);
    try {
        typechecker_1.typeCheckProgram(ast);
        var vars_1 = [];
        ast.forEach(function (stmt) {
            if (stmt.tag === "assign") {
                vars_1.push(stmt.name);
            }
        });
        var funs_1 = [];
        ast.forEach(function (stmt, i) {
            if (stmt.tag === "define") {
                funs_1.push(codeGenStmt(stmt).join("\n"));
            }
        });
        var allFuns = funs_1.join("\n\n");
        var stmts = ast.filter(function (stmt) { return stmt.tag !== "define"; });
        var varDecls_1 = [];
        varDecls_1.push("(local $___IMPL_RET i32)");
        vars_1.forEach(function (v) { varDecls_1.push("(local $" + v + " i32)"); });
        var allStmts = stmts.map(codeGenStmt).flat();
        var ourCode = varDecls_1.concat(allStmts).map(function (s) { return "    " + s; }).join("\n");
        var lastStmt = ast[ast.length - 1];
        var isExpr = lastStmt.tag === "expr";
        var scaffold = [
            "(module",
            allFuns,
            "  (func (export \"_start\") " + ((isExpr) ? "(result i32)" : ""),
            (isExpr) ? ourCode : ourCode + "))",
            (isExpr) ? "    (local.get $___IMPL_RET)))" : ""
        ];
        return scaffold.join("\n");
    }
    catch (err) {
        alert(err.message);
        throw new errors_1.CompilerError();
    }
}
exports.compile = compile;


/***/ }),

/***/ "./errors.ts":
/*!*******************!*\
  !*** ./errors.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UniaryOpTypeError = exports.ParseError = exports.FuncCallTypError = exports.GeneralTypeError = exports.MissingReturn = exports.NotDeclaredInScope = exports.NotAVariable = exports.NotAFunctionOrClass = exports.DuplicateDeclaration = exports.ConditionalExprTypeError = exports.CompilerError = exports.BinaryOpTypeError = void 0;
var BinaryOpTypeError = /** @class */ (function (_super) {
    __extends(BinaryOpTypeError, _super);
    function BinaryOpTypeError(op, t1, t2) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Cannot apply operator `" + op + "` on types `" + t1 + "` and `" + t2 + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'BinaryOpTypeError';
        _this.op = op;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return BinaryOpTypeError;
}(Error));
exports.BinaryOpTypeError = BinaryOpTypeError;
var CompilerError = /** @class */ (function (_super) {
    __extends(CompilerError, _super);
    function CompilerError() {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'CompilerError';
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return CompilerError;
}(Error));
exports.CompilerError = CompilerError;
var ConditionalExprTypeError = /** @class */ (function (_super) {
    __extends(ConditionalExprTypeError, _super);
    function ConditionalExprTypeError(conditionalType) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Conditional expression cannot be of type `" + conditionalType + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'ConditionalExprTypeError';
        _this.conditionalType = conditionalType;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return ConditionalExprTypeError;
}(Error));
exports.ConditionalExprTypeError = ConditionalExprTypeError;
var DuplicateDeclaration = /** @class */ (function (_super) {
    __extends(DuplicateDeclaration, _super);
    function DuplicateDeclaration(ident) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Duplicate declaration of identifier in same scope: " + ident) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, DuplicateDeclaration);
        }
        _this.name = 'DuplicateDeclaration';
        _this.ident = ident;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return DuplicateDeclaration;
}(Error));
exports.DuplicateDeclaration = DuplicateDeclaration;
var NotAFunctionOrClass = /** @class */ (function (_super) {
    __extends(NotAFunctionOrClass, _super);
    function NotAFunctionOrClass(objName) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Not a function or class: " + objName) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'NotAFunctionOrClass';
        _this.objName = objName;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return NotAFunctionOrClass;
}(Error));
exports.NotAFunctionOrClass = NotAFunctionOrClass;
var NotAVariable = /** @class */ (function (_super) {
    __extends(NotAVariable, _super);
    function NotAVariable(varName) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Not a variable: " + varName) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'NotAVariable';
        _this.varName = varName;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return NotAVariable;
}(Error));
exports.NotAVariable = NotAVariable;
var NotDeclaredInScope = /** @class */ (function (_super) {
    __extends(NotDeclaredInScope, _super);
    function NotDeclaredInScope(varName) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Cannot assign to variable that is not explicitly decalared in this scope: " + varName) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'NotDeclaredInScope';
        _this.varName = varName;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return NotDeclaredInScope;
}(Error));
exports.NotDeclaredInScope = NotDeclaredInScope;
var MissingReturn = /** @class */ (function (_super) {
    __extends(MissingReturn, _super);
    function MissingReturn(f) {
        var _newTarget = this.constructor;
        if (f === void 0) { f = "contains"; }
        var _this = _super.call(this, "All paths in this function/method must have a return statement: " + f) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'MissingReturn';
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return MissingReturn;
}(Error));
exports.MissingReturn = MissingReturn;
var GeneralTypeError = /** @class */ (function (_super) {
    __extends(GeneralTypeError, _super);
    function GeneralTypeError(actualType, expectedType) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Expected type `" + expectedType + "`; got type `" + actualType + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'GeneralTypeError';
        _this.actualType = actualType;
        _this.expectedType = expectedType;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return GeneralTypeError;
}(Error));
exports.GeneralTypeError = GeneralTypeError;
var FuncCallTypError = /** @class */ (function (_super) {
    __extends(FuncCallTypError, _super);
    function FuncCallTypError(actualType, expectedType, paramN) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Expected type `" + expectedType + "`; got type `" + actualType + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, FuncCallTypError);
        }
        _this.name = 'FuncCallTypError';
        _this.actualType = actualType;
        _this.expectedType = expectedType;
        _this.paramN = paramN;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return FuncCallTypError;
}(Error));
exports.FuncCallTypError = FuncCallTypError;
var ParseError = /** @class */ (function (_super) {
    __extends(ParseError, _super);
    function ParseError(token) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Parse error near token " + token) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'ParseError';
        _this.token = token;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return ParseError;
}(Error));
exports.ParseError = ParseError;
var UniaryOpTypeError = /** @class */ (function (_super) {
    __extends(UniaryOpTypeError, _super);
    function UniaryOpTypeError(op, t) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Cannot apply operator `" + op + "` on type `" + t + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'UniaryOpTypeError';
        _this.op = op;
        _this.t = t;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return UniaryOpTypeError;
}(Error));
exports.UniaryOpTypeError = UniaryOpTypeError;


/***/ }),

/***/ "./parser.ts":
/*!*******************!*\
  !*** ./parser.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.traverseExpr = exports.traverseParameters = exports.traverseStmt = exports.parseFollowingStmts = exports.parseProgram = void 0;
var lezer_python_1 = __webpack_require__(/*! lezer-python */ "./node_modules/lezer-python/dist/index.cjs");
var errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
function parseProgram(source) {
    var t = lezer_python_1.parser.parse(source).cursor();
    // The top node in the program is a Script node with a list of children
    // that are various statements
    t.firstChild();
    return parseFollowingStmts(source, t);
}
exports.parseProgram = parseProgram;
function parseFollowingStmts(s, t) {
    var stmts = [];
    do {
        var stmt = traverseStmt(s, t);
        stmts.push(stmt);
        // drop all statements after pass or early return
        if (stmt.tag == "pass" || stmt.tag == "return") {
            break;
        }
    } while (t.nextSibling()); // t.nextSibling() returns false when it reaches
    //  the end of the list of children
    return stmts;
}
exports.parseFollowingStmts = parseFollowingStmts;
/*
  Invariant – t must focus on the same node at the end of the traversal
*/
function traverseStmt(s, t) {
    switch (t.type.name) {
        case "ReturnStatement": {
            t.firstChild(); // Focus return keyword
            t.nextSibling(); // Focus expression
            var value = traverseExpr(s, t);
            t.parent();
            return { tag: "return", value: value };
        }
        case "AssignStatement": {
            t.firstChild(); // focused on name (the first child)
            var name_1 = s.substring(t.from, t.to);
            t.nextSibling(); // the declared type (if any)
            var type_ = (function () {
                if (t.firstChild()) { // : in the type declaration
                    t.nextSibling(); // the actual declared type
                    var substr = s.substring(t.from, t.to);
                    t.parent();
                    if (substr == "bool" || substr == "int") {
                        return substr;
                    }
                }
                return "";
            })();
            t.nextSibling(); // focused on = sign. May need this for complex tasks, like +=!
            t.nextSibling(); // focused on the value expression
            var value = traverseExpr(s, t);
            t.parent();
            return { tag: "assign", name: name_1, type_: type_, value: value };
        }
        case "ExpressionStatement": {
            t.firstChild(); // The child is some kind of expression, the
            // ExpressionStatement is just a wrapper with no information
            var expr = traverseExpr(s, t);
            t.parent();
            return { tag: "expr", expr: expr };
        }
        case "IfStatement": {
            t.firstChild(); // if statement
            var traverseIfs_1 = function (s, t) {
                if ((["if", "elif"]).includes(t.node.type.name)) {
                    t.nextSibling(); // the predicate
                    var pred = traverseExpr(s, t);
                    t.nextSibling(); // the body
                    t.firstChild(); // : before the body
                    t.nextSibling(); // the first statement of the body
                    var body1 = parseFollowingStmts(s, t);
                    // Body immediately after if cannot be empty
                    if (body1.length == 0) {
                        throw new errors_1.ParseError("DEDENT");
                    }
                    t.parent(); // Body
                    t.nextSibling(); // elif/else (if any)
                    return [{ tag: "if", pred: pred, body1: body1, body2: traverseIfs_1(s, t) }];
                }
                else if (t.node.type.name == "else") { // else
                    t.nextSibling(); // the body
                    t.firstChild(); // : before the body
                    t.nextSibling(); // the first statement of the body
                    var body_1 = parseFollowingStmts(s, t);
                    t.parent();
                    return body_1;
                }
                else {
                    throw new Error("Compiler error. Check code.");
                }
            };
            var ifstmt = traverseIfs_1(s, t);
            t.parent();
            return ifstmt[0];
        }
        case "WhileStatement": {
            t.firstChild(); // while
            t.nextSibling(); // predicate
            var pred = traverseExpr(s, t);
            t.nextSibling(); // Body
            t.firstChild(); // colon
            t.nextSibling(); // statement
            var body_2 = parseFollowingStmts(s, t);
            t.parent();
            t.parent();
            return { tag: "while", pred: pred, body: body_2 };
        }
        case "PassStatement": return { tag: "pass" };
        case "FunctionDefinition":
            t.firstChild(); // Focus on def
            t.nextSibling(); // Focus on name of function
            var name_2 = s.substring(t.from, t.to);
            t.nextSibling(); // Focus on ParamList
            var parameters = traverseParameters(s, t);
            t.nextSibling();
            var outputType = (function () {
                if (t.node.type.name == "TypeDef") {
                    t.firstChild();
                    t.nextSibling(); // the actual declared type
                    var substr = s.substring(t.from, t.to);
                    t.parent();
                    if (substr == "bool" || substr == "int") {
                        return substr;
                    }
                    t.nextSibling(); // Focus on Body
                }
                else {
                    var outputType_1 = "none";
                }
            })();
            t.nextSibling(); // Focus on :
            t.firstChild();
            t.nextSibling();
            var body = parseFollowingStmts(s, t);
            if (body.length == 0) {
                throw new errors_1.ParseError("EOF");
            }
            ;
            t.parent(); // Pop to Body
            t.parent(); // Pop to FunctionDefinition
            return { tag: "define", name: name_2, parameters: parameters, outputType: outputType, body: body };
    }
}
exports.traverseStmt = traverseStmt;
function traverseParameters(s, t) {
    var parameters = [];
    t.firstChild(); // Focuses on open paren
    do {
        t.nextSibling(); // Focuses on a VariableName
        var name_3 = s.substring(t.from, t.to);
        if (name_3 == ")") {
            break;
        }
        t.nextSibling(); // Focuses on a typedef, if any
        if (t.node.type.name == "TypeDef") {
            t.firstChild(); // : in the type declaration
            t.nextSibling(); // the actual declared type
            var type_ = s.substring(t.from, t.to);
            t.parent(); // back to parameter
            parameters.push({ name: name_3, type_: type_ });
        }
        else {
            throw new Error("Parse error near token RPAREN: " + s.substring(t.node.from, t.node.to));
        }
        t.nextSibling(); // Focus on , or )
    } while (s.substring(t.from, t.to) != ")");
    t.parent(); // Pop to ParamList
    return parameters;
}
exports.traverseParameters = traverseParameters;
function traverseExpr(s, t) {
    switch (t.type.name) {
        case "Number":
            return {
                tag: "literal",
                value: {
                    tag: "number",
                    value: Number(s.substring(t.from, t.to))
                }
            };
        case "Boolean": {
            var bool = (function () {
                switch (s.substring(t.from, t.to)) {
                    case "True": return true;
                    case "False": return false;
                }
            })();
            return {
                tag: "literal",
                value: {
                    tag: "bool",
                    value: bool
                }
            };
        }
        case "VariableName":
            return { tag: "id", name: s.substring(t.from, t.to) };
        case "CallExpression": {
            t.firstChild(); // Focus name
            var name_4 = s.substring(t.from, t.to);
            t.nextSibling(); // Focus ArgList
            t.firstChild(); // Focus open paren
            var argList = [];
            do {
                t.nextSibling(); // Focus on parameter
                argList.push(traverseExpr(s, t));
                t.nextSibling(); // Focus on , or )
            } while (s.substring(t.from, t.to) != ")");
            t.parent();
            t.parent();
            return { tag: "call", name: name_4, arguments: argList };
        }
        case "UnaryExpression": {
            t.firstChild();
            var uniop = (function () {
                switch (s.substring(t.from, t.to)) {
                    case "-": return "neg";
                    case "not": return "not";
                    default:
                        throw new Error("Not implemented at " + t.from + " " + t.to + ": " + s.substring(t.from, t.to));
                }
            })();
            t.nextSibling();
            var arg = traverseExpr(s, t);
            t.parent();
            return { tag: "uniop", arg: arg, uniop: uniop };
        }
        case "BinaryExpression": {
            t.firstChild();
            var arg1 = traverseExpr(s, t);
            t.nextSibling();
            var binop = (function () {
                var str = s.substring(t.from, t.to);
                var intOps = ["+", "-", "*", "//", "%", "==", "!=", ">=", "<=", ">", "<"];
                if (intOps.includes(str)) {
                    return str;
                }
                else {
                    throw new Error("Not implemented at " + t.from + " " + t.to + ": " + s.substring(t.from, t.to));
                }
            })();
            t.nextSibling();
            var arg2 = traverseExpr(s, t);
            t.parent();
            return { tag: "binop", arg1: arg1, arg2: arg2, binop: binop };
        }
    }
}
exports.traverseExpr = traverseExpr;


/***/ }),

/***/ "./typechecker.ts":
/*!************************!*\
  !*** ./typechecker.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.typeCheckProgram = void 0;
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
// FIXME: the rhs of variable declaration can only be literals
function typeCheckProgram(prog) {
    typeCheck(prog, new Map, new Map, "none");
}
exports.typeCheckProgram = typeCheckProgram;
// A failure in the typechecking process leads to an unrecoverable failure so we
// might as well throw an error and exit. A pass at this stage however does not
// warrant any action.
function typeCheck(stmts, outerVarScope, outerFuncScope, retType) {
    // All the function definitions and variable declarations must be at the top
    // of the scope. The order of defs or decls doesn't matter--they can even be
    // interweaved, as long as no computation happens before then end of this
    // block. We'll call this the preamble.
    // Get the statement number where the preamble ends
    var n = ast_1.countDefDeclStmts(stmts);
    // extract the assignment and definition statements
    var declBlock = stmts.slice(0, n).filter(function (x) { return x.tag == "assign"; });
    var defBlock = stmts.slice(0, n).filter(function (x) { return x.tag == "define"; });
    // check for deplicate declaration of identifiers
    var idents = new Map;
    for (var _i = 0, _a = stmts.slice(0, n); _i < _a.length; _i++) {
        var stmt = _a[_i];
        if (stmt.tag != "assign" && stmt.tag != "define") {
            throw new Error("Compiler error. Check code.");
        }
        ;
        if (idents.has(stmt.name)) {
            throw new errors_1.DuplicateDeclaration(stmt.name);
        }
        ;
        idents.set(stmt.name, stmt);
    }
    // Keep a table of variables and their types
    // Note: definitions in the current scope will overwrite definitions from
    // outerscope if there are conflicts
    var varScope = declBlock.map(function (stmt) {
        if (stmt.tag != "assign") {
            throw new Error("Compiler error. Check code.");
        }
        ;
        if (stmt.type_ == "") {
            throw new errors_1.NotAVariable(stmt.name);
        }
        else {
            return stmt;
        }
    })
        // Merge with outer scope. Overwrite type declarations if necessary.
        .reduce(function (map, t) {
        map.set(t.name, t.type_);
        return map;
    }, outerVarScope);
    // Keep a table of all currently defined functions. Overwrite definitions from
    // the outer scope if necessary
    var funcScope = defBlock.reduce(function (map, t) {
        if (t.tag != "define") {
            throw new Error("Compiler error. Check code.");
        }
        ;
        var ftype = {
            parameterTypes: t.parameters.map(function (p) { return p.type_; }),
            outputType: t.outputType
        };
        map.set(t.name, ftype);
        return map;
    }, outerFuncScope);
    // Typecheck each statement
    for (var _b = 0, stmts_1 = stmts; _b < stmts_1.length; _b++) {
        var stmt = stmts_1[_b];
        if (stmt.tag == "assign") {
            var rhsType = inferExprType(stmt.value, varScope, funcScope);
            var lhsType = varScope.get(stmt.name);
            if (rhsType != lhsType) {
                throw new errors_1.GeneralTypeError(lhsType, rhsType);
            }
        }
        else if (stmt.tag == "expr") {
            checkExprType(stmt.expr, varScope, funcScope);
        }
        else if (stmt.tag == "define") {
            // ChocoPy functions don't capture variables. Reset scope to be the
            // supplied parameters.
            var varScope_1 = stmt.parameters.reduce(function (map, p) {
                map.set(p.name, p.type_);
                return map;
            }, new Map);
            // check statements in the body, including matching return types to the
            // stated output type
            try {
                typeCheck(stmt.body, varScope_1, funcScope, stmt.outputType);
            }
            catch (err) {
                if (err instanceof errors_1.NotAVariable) {
                    if (varScope_1.has(err.varName)) {
                        throw new errors_1.NotDeclaredInScope(err.varName);
                    }
                }
                throw err;
            }
            checkReturnType(stmt.name, stmt.body, varScope_1, funcScope, stmt.outputType);
        }
        else if (stmt.tag == "return") {
            var t = inferExprType(stmt.value, varScope, funcScope);
            if (retType != t) {
                throw new errors_1.GeneralTypeError(retType, t);
            }
        }
        else if (stmt.tag == "if") {
            var t = inferExprType(stmt.pred, varScope, funcScope);
            if (t != "bool") {
                throw new errors_1.ConditionalExprTypeError(t);
            }
            typeCheck(stmt.body1, varScope, funcScope, retType);
            typeCheck(stmt.body2, varScope, funcScope, retType);
        }
        else if (stmt.tag == "while") {
            var t = inferExprType(stmt.pred, varScope, funcScope);
            if (t != "bool") {
                throw new errors_1.ConditionalExprTypeError(t);
            }
            typeCheck(stmt.body, varScope, funcScope, retType);
        }
    }
    ;
}
function checkReturnType(name, stmts, varScope, funcScope, retType) {
    var checkLastStmtRetType = function () {
        // stmts.length == 0 should be caught be a ParseError
        var lastStmt = stmts[stmts.length - 1];
        if (lastStmt.tag == "return") {
            var t = inferExprType(lastStmt.value, varScope, funcScope);
            if (retType != t) {
                throw new errors_1.GeneralTypeError(t, retType);
            }
        }
        else { // no return since "return" is always the last statement
            if (retType != "none") {
                throw new errors_1.MissingReturn(name);
            }
        }
    };
    // no nested statements (aside from func defs, which don't count)
    if (stmts.every(function (s) { return s.tag != "if" && s.tag != "while"; })) {
        checkLastStmtRetType();
        // There exists at least one if or while statement in the array
    }
    else {
        try {
            // check nested statements
            var stmtGroups = stmts.filter(function (s) { return s.tag == "if" || s.tag == "while"; })
                .map(function (s) {
                switch (s.tag) {
                    case "if":
                        return [s.body1, s.body2];
                    case "while":
                        return [s.body];
                }
            })
                .flat();
            for (var _i = 0, stmtGroups_1 = stmtGroups; _i < stmtGroups_1.length; _i++) {
                var s = stmtGroups_1[_i];
                checkReturnType(name, s, varScope, funcScope, retType);
            }
        }
        catch (err) {
            if (err instanceof errors_1.MissingReturn) {
                checkLastStmtRetType();
            }
        }
    }
}
function checkExprType(expr, varScope, funcScope) {
    // leverage the type chekcing code in the inference algorithm
    inferExprType(expr, varScope, funcScope);
}
function inferExprType(expr, varScope, funcScope) {
    switch (expr.tag) {
        case "literal": {
            var literal = expr.value;
            return (literal.tag == "number") ? "int" : literal.tag;
        }
        case "id": return varScope.get(expr.name);
        case "call": {
            if (funcScope.has(expr.name)) {
                var ftype = funcScope.get(expr.name);
                // check parameter types
                var zipped = ftype.parameterTypes.map(function (k, i) { return [i, k, expr.arguments[i]]; });
                for (var _i = 0, zipped_1 = zipped; _i < zipped_1.length; _i++) {
                    var tuple = zipped_1[_i];
                    var paramN = tuple[0];
                    var t1 = tuple[1];
                    var t2 = inferExprType(tuple[2], varScope, funcScope);
                    if (t1 != t2) {
                        throw new errors_1.FuncCallTypError(t1, t2, paramN);
                    }
                }
                return ftype.outputType;
            }
            else {
                throw new errors_1.NotAFunctionOrClass(expr.name);
            }
        }
        case "uniop": {
            var t = inferExprType(expr.arg, varScope, funcScope);
            switch (expr.uniop) {
                case "not": {
                    if (t != "bool") {
                        throw new errors_1.UniaryOpTypeError("not", t);
                    }
                    else {
                        return "bool";
                    }
                }
                case "neg": {
                    if (t != "int") {
                        throw new errors_1.UniaryOpTypeError("neg", t);
                    }
                    else {
                        return "int";
                    }
                }
            }
        }
        case "binop": {
            var t1 = inferExprType(expr.arg1, varScope, funcScope);
            var t2 = inferExprType(expr.arg2, varScope, funcScope);
            var intOps = ["+", "-", "*", "//", "%", "==", "!=", ">=", "<=", ">", "<"];
            if (intOps.includes(expr.binop)) {
                if (t1 != "int" || t2 != "int") {
                    var op = expr.binop;
                    throw new errors_1.BinaryOpTypeError(op, t1, t2);
                }
                else {
                    if ((["+", "-", "*", "//", "%"]).includes(expr.binop)) {
                        return "int";
                    }
                    else {
                        return "bool";
                    }
                }
                // the "is" operator
            }
            else {
                if (t1 == "int" || t1 == "bool" || t2 == "int" || t2 == "bool") {
                    throw new errors_1.BinaryOpTypeError("is", t1, t2);
                }
                else {
                    return "bool";
                }
            }
        }
    }
}


/***/ }),

/***/ "./webstart.ts":
/*!*********************!*\
  !*** ./webstart.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var compiler_1 = __webpack_require__(/*! ./compiler */ "./compiler.ts");
document.addEventListener("DOMContentLoaded", function () { return __awaiter(void 0, void 0, void 0, function () {
    var runButton, userCode;
    return __generator(this, function (_a) {
        runButton = document.getElementById("run");
        userCode = document.getElementById("user-code");
        runButton.addEventListener("click", function () { return __awaiter(void 0, void 0, void 0, function () {
            var program, wat, code, output, result, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        program = userCode.value;
                        wat = compiler_1.compile(program);
                        code = document.getElementById("generated-code");
                        code.textContent = wat;
                        output = document.getElementById("output");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, compiler_1.run(wat)];
                    case 2:
                        result = _a.sent();
                        output.textContent = String(result);
                        output.setAttribute("style", "color: black");
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        output.textContent = String(e_1);
                        output.setAttribute("style", "color: red");
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        return [2 /*return*/];
    });
}); });


/***/ }),

/***/ "wabt":
/*!***********************!*\
  !*** external "wabt" ***!
  \***********************/
/***/ ((module) => {

module.exports = wabt;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./webstart.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci1weXRob24vZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvbGV6ZXItdHJlZS9kaXN0L3RyZWUuY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2xlemVyL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vYXN0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vY29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9lcnJvcnMudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi90eXBlY2hlY2tlci50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL3dlYnN0YXJ0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0L2V4dGVybmFsIFwid2FidFwiIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsa0RBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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bnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXIgPSByZXF1aXJlKCdsZXplcicpO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IFxuICBwcmludEtleXdvcmQgPSAxLFxuICBuZXdsaW5lID0gMTY0LFxuICBuZXdsaW5lQnJhY2tldGVkID0gMTY1LFxuICBuZXdsaW5lRW1wdHkgPSAxNjYsXG4gIGVvZiA9IDE2NyxcbiAgY29udGludWVCb2R5ID0gMTY4LFxuICBlbmRCb2R5ID0gMTY5LFxuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IDIxLFxuICBUdXBsZUV4cHJlc3Npb24gPSA0OCxcbiAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA0OSxcbiAgQXJyYXlFeHByZXNzaW9uID0gNTMsXG4gIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA1NixcbiAgRGljdGlvbmFyeUV4cHJlc3Npb24gPSA1NyxcbiAgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uID0gNjAsXG4gIFNldEV4cHJlc3Npb24gPSA2MSxcbiAgU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2MixcbiAgY29tcG91bmRTdGF0ZW1lbnQgPSAyMzE7XG5cbmNvbnN0IG5ld2xpbmUkMSA9IDEwLCBjYXJyaWFnZVJldHVybiA9IDEzLCBzcGFjZSA9IDMyLCB0YWIgPSA5LCBoYXNoID0gMzUsIHBhcmVuT3BlbiA9IDQwLCBkb3QgPSA0NjtcblxuY29uc3QgYnJhY2tldGVkID0gW1xuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiwgVHVwbGVFeHByZXNzaW9uLCBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiwgQXJyYXlFeHByZXNzaW9uLCBBcnJheUNvbXByZWhlbnNpb25FeHByZXNzaW9uLFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiwgRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uLCBTZXRFeHByZXNzaW9uLCBTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvblxuXSwgcGFyZW50U3RhdGVtZW50ID0gW2NvbXBvdW5kU3RhdGVtZW50XTtcblxuY29uc3QgY2FjaGVzID0gbmV3IFdlYWtNYXA7XG5cbi8vIFBlci1pbnB1dC1zdHJlYW0gaW5kZW50YXRpb24gY2FjaGUuIGBwcmV2YCBtYXBzIGluZGVudGF0aW9uIGRlcHRoc1xuLy8gdG8gdGhlIGxhc3QgcG9zaXRpb24gYXQgd2hpY2ggYSBzdGF0ZW1lbnQgaW5kZW50ZWQgdG8gdGhhdCBkZXB0aFxuLy8gd2FzIHNlZW4uIFRoZXJlJ3MgYW4gZXh0cmEgc2V0IG9mIHNsb3RzIGZvciB0aGUgX2N1cnJlbnRfXG4vLyBpbmRlbnRhdGlvbiwgc2luY2UgdGhhdCBuZWVkcyB0byBiZSBhdmFpbGFibGUgYWxvbmdzaWRlIGEgcHJldmlvdXNcbi8vIGluZGVudGF0aW9uIHBvc2l0aW9uIGF0IHRoZSBzYW1lIGxldmVsLlxuY2xhc3MgQ2FjaGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxhc3QgPSB0aGlzLmxhc3RJbmRlbnQgPSAtMTtcbiAgICB0aGlzLnByZXYgPSBbXTtcbiAgfVxuXG4gIGdldChwb3MpIHtcbiAgICBpZiAodGhpcy5sYXN0ID09IHBvcykgcmV0dXJuIHRoaXMubGFzdEluZGVudFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wcmV2Lmxlbmd0aDsgaSsrKSBpZiAodGhpcy5wcmV2W2ldID09IHBvcykgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHNldChwb3MsIGluZGVudCkge1xuICAgIGlmIChwb3MgPT0gdGhpcy5sYXN0KSByZXR1cm5cbiAgICBpZiAodGhpcy5sYXN0ID4gLTEpIHRoaXMuc2V0UHJldih0aGlzLmxhc3QsIHRoaXMubGFzdEluZGVudCk7XG4gICAgdGhpcy5sYXN0ID0gcG9zO1xuICAgIHRoaXMubGFzdEluZGVudCA9IGluZGVudDtcbiAgfVxuXG4gIHNldFByZXYocG9zLCBpbmRlbnQpIHtcbiAgICB3aGlsZSAodGhpcy5wcmV2Lmxlbmd0aCA8IGluZGVudCkgdGhpcy5wcmV2LnB1c2goLTEpO1xuICAgIHRoaXMucHJldltpbmRlbnRdID0gcG9zO1xuICB9XG5cbiAgc3RhdGljIGZvcihpbnB1dCkge1xuICAgIGxldCBmb3VuZCA9IGNhY2hlcy5nZXQoaW5wdXQpO1xuICAgIGlmICghZm91bmQpIGNhY2hlcy5zZXQoaW5wdXQsIGZvdW5kID0gbmV3IENhY2hlKTtcbiAgICByZXR1cm4gZm91bmRcbiAgfVxufVxuXG5jb25zdCBtYXhJbmRlbnQgPSA1MDtcblxuZnVuY3Rpb24gZ2V0SW5kZW50KGlucHV0LCBwb3MpIHtcbiAgbGV0IGNhY2hlID0gQ2FjaGUuZm9yKGlucHV0KSwgZm91bmQgPSBjYWNoZS5nZXQocG9zKTtcbiAgaWYgKGZvdW5kID4gLTEpIHJldHVybiBmb3VuZFxuXG4gIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiB2ZXJ5IG9mdGVuIChvciBldmVuIGF0IGFsbCkgaW4gbm9ybWFsXG4gIC8vIHBhcnNpbmcsIHNpbmNlIHRoZSBpbmRlbnRhdGlvbnMgYXJlIHN0b3JlZCBieSB0aGUgbmV3bGluZVxuICAvLyB0b2tlbml6ZXIgYWhlYWQgb2YgdGltZS4gQnV0IGl0J3Mga2luZCBvZiB0cmlja3kgdG8gcHJvdmUgd2hldGhlclxuICAvLyB0aGF0IGFsd2F5cyBoYXBwZW5zIGluIGluY3JlbWVudGFsIHBhcnNpbmcgc2NlbmFyaW9zLCBzbyBoZXJlJ3MgYVxuICAvLyBmYWxsYmFjayBhbnl3YXkuXG4gIGxldCBiZWZvcmUgPSBpbnB1dC5yZWFkKE1hdGgubWF4KDAsIHBvcyAtIG1heEluZGVudCksIHBvcyk7XG4gIGxldCBjb3VudCA9IDAsIHN0YXJ0ID0gYmVmb3JlLmxlbmd0aDtcbiAgZm9yICg7IHN0YXJ0ID4gMDsgc3RhcnQtLSkge1xuICAgIGxldCBuZXh0ID0gYmVmb3JlLmNoYXJDb2RlQXQoc3RhcnQgLSAxKTtcbiAgICBpZiAobmV4dCA9PSBuZXdsaW5lJDEgfHwgbmV4dCA9PSBjYXJyaWFnZVJldHVybikgYnJlYWtcbiAgfVxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBiZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2ggPSBiZWZvcmUuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY2ggPT0gc3BhY2UpIGNvdW50Kys7XG4gICAgZWxzZSBpZiAoY2ggPT0gdGFiKSBjb3VudCArPSA4IC0gKGNvdW50ICUgOCk7XG4gICAgZWxzZSBicmVha1xuICB9XG4gIGNhY2hlLnNldFByZXYocG9zLCBjb3VudCk7XG4gIHJldHVybiBjb3VudFxufVxuXG5jb25zdCBuZXdsaW5lcyA9IG5ldyBsZXplci5FeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHRva2VuLCBzdGFjaykgPT4ge1xuICBsZXQgbmV4dCA9IGlucHV0LmdldCh0b2tlbi5zdGFydCk7XG4gIGlmIChuZXh0IDwgMCkge1xuICAgIHRva2VuLmFjY2VwdChlb2YsIHRva2VuLnN0YXJ0KTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobmV4dCAhPSBuZXdsaW5lJDEgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybikgcmV0dXJuXG4gIGlmIChzdGFjay5zdGFydE9mKGJyYWNrZXRlZCkgIT0gbnVsbCkge1xuICAgIHRva2VuLmFjY2VwdChuZXdsaW5lQnJhY2tldGVkLCB0b2tlbi5zdGFydCArIDEpO1xuICAgIHJldHVyblxuICB9XG4gIGxldCBzY2FuID0gdG9rZW4uc3RhcnQgKyAxLCBpbmRlbnQgPSAwO1xuICBmb3IgKDsgc2NhbiA8IGlucHV0Lmxlbmd0aDsgc2NhbisrKSB7XG4gICAgbGV0IGNoID0gaW5wdXQuZ2V0KHNjYW4pO1xuICAgIGlmIChjaCA9PSBzcGFjZSkgaW5kZW50Kys7XG4gICAgZWxzZSBpZiAoY2ggPT0gdGFiKSBpbmRlbnQgKz0gOCAtIChpbmRlbnQgJSA4KTtcbiAgICBlbHNlIGlmIChjaCA9PSBuZXdsaW5lJDEgfHwgaW5kZW50ID09IGNhcnJpYWdlUmV0dXJuIHx8IGNoID09IGhhc2gpIHtcbiAgICAgIHRva2VuLmFjY2VwdChuZXdsaW5lRW1wdHksIHRva2VuLnN0YXJ0ICsgMSk7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgdG9rZW4uYWNjZXB0KG5ld2xpbmUsIHRva2VuLnN0YXJ0ICsgMSk7XG4gIENhY2hlLmZvcihpbnB1dCkuc2V0KHNjYW4sIGluZGVudCk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZSwgZmFsbGJhY2s6IHRydWV9KTtcblxuY29uc3QgYm9keUNvbnRpbnVlID0gbmV3IGxlemVyLkV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4sIHN0YWNrKSA9PiB7XG4gIGxldCBwYXJlbnQgPSBzdGFjay5zdGFydE9mKHBhcmVudFN0YXRlbWVudCk7XG4gIGxldCBwYXJlbnRJbmRlbnQgPSBwYXJlbnQgPT0gbnVsbCA/IDAgOiBnZXRJbmRlbnQoaW5wdXQsIHBhcmVudCk7XG4gIGxldCBpbmRlbnRIZXJlID0gZ2V0SW5kZW50KGlucHV0LCB0b2tlbi5zdGFydCk7XG4gIHRva2VuLmFjY2VwdChpbmRlbnRIZXJlIDw9IHBhcmVudEluZGVudCA/IGVuZEJvZHkgOiBjb250aW51ZUJvZHksIHRva2VuLnN0YXJ0KTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlLCBmYWxsYmFjazogdHJ1ZX0pO1xuXG5jb25zdCBsZWdhY3lQcmludCA9IG5ldyBsZXplci5FeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHRva2VuKSA9PiB7XG4gIGxldCBwb3MgPSB0b2tlbi5zdGFydDtcbiAgZm9yIChsZXQgcHJpbnQgPSBcInByaW50XCIsIGkgPSAwOyBpIDwgcHJpbnQubGVuZ3RoOyBpKyssIHBvcysrKVxuICAgIGlmIChpbnB1dC5nZXQocG9zKSAhPSBwcmludC5jaGFyQ29kZUF0KGkpKSByZXR1cm5cbiAgbGV0IGVuZCA9IHBvcztcbiAgaWYgKC9cXHcvLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dC5nZXQocG9zKSkpKSByZXR1cm5cbiAgZm9yICg7OyBwb3MrKykge1xuICAgIGxldCBuZXh0ID0gaW5wdXQuZ2V0KHBvcyk7XG4gICAgaWYgKG5leHQgPT0gc3BhY2UgfHwgbmV4dCA9PSB0YWIpIGNvbnRpbnVlXG4gICAgaWYgKG5leHQgIT0gcGFyZW5PcGVuICYmIG5leHQgIT0gZG90ICYmIG5leHQgIT0gbmV3bGluZSQxICYmIG5leHQgIT0gY2FycmlhZ2VSZXR1cm4gJiYgbmV4dCAhPSBoYXNoKVxuICAgICAgdG9rZW4uYWNjZXB0KHByaW50S2V5d29yZCwgZW5kKTtcbiAgICByZXR1cm5cbiAgfVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLGF3YWl0OjQwLCBvcjo0OCwgYW5kOjUwLCBpbjo1NCwgbm90OjU2LCBpczo1OCwgaWY6NjQsIGVsc2U6NjYsIGxhbWJkYTo3MCwgc2VsZjo3NCwgeWllbGQ6OTAsIGZyb206OTIsIGFzeW5jOjEwMCwgZm9yOjEwMiwgTm9uZToxNTQsIFRydWU6MTU2LCBGYWxzZToxNTYsIGRlbDoxNzAsIHBhc3M6MTc0LCBicmVhazoxNzgsIGNvbnRpbnVlOjE4MiwgcmV0dXJuOjE4NiwgcmFpc2U6MTk0LCBpbXBvcnQ6MTk4LCBhczoyMDAsIGdsb2JhbDoyMDQsIG5vbmxvY2FsOjIwNiwgYXNzZXJ0OjIxMCwgZWxpZjoyMjAsIHdoaWxlOjIyNCwgdHJ5OjIzMCwgZXhjZXB0OjIzMiwgZmluYWxseToyMzQsIHdpdGg6MjM4LCBkZWY6MjQyLCBjbGFzczoyNTJ9O1xuY29uc3QgcGFyc2VyID0gbGV6ZXIuUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTMsXG4gIHN0YXRlczogXCIhO1tPYFEhTFRPT08lZlEhTFVPJyNHY09PUSFMUScjQ20nI0NtT09RIUxRJyNDbicjQ25PJ1VRIUxTTycjQ2xPKHpRIUxVTycjR2JPT1EhTFEnI0djJyNHY09PUSFMUScjRFMnI0RTT09RIUxRJyNHYicjR2JPKWhRIUxTTycjQ3FPKXhRIUxTTycjRGNPKllRIUxTTycjRGdPT1EhTFEnI0R0JyNEdE8qbU9XTycjRHRPKnVPYE8nI0R0Typ9T3BPJyNEdU8rWU8hYk8nI0R1TytlTyN0TycjRHVPK3BPJmpPJyNEdU8tclEhTFVPJyNHU09PUSFMUScjR1MnI0dTTydVUSFMU08nI0dSTy9VUSFMVU8nI0dST09RIUxRJyNFXicjRV5PL21RIUxTTycjRV9PT1EhTFEnI0dRJyNHUU8vd1EhTFNPJyNHUE9PUSZGVicjR1AnI0dQTzBTUSFMU08nI0ZRT09RIUxRJyNGdCcjRnRPMFhRIUxTTycjRlBPT1EmRlYnI0hdJyNIXU9PUSZGVicjR08nI0dPT09RIUxSJyNGUycjRlNRYFEhTFRPT08nVVEhTFNPJyNDb08wZ1EhTFNPJyNDek8wblEhTFNPJyNET08xUFEhTFNPJyNHZ08xYVEhTFVPJyNFUk8nVVEhTFNPJyNFU09PUSFMUScjRVUnI0VVT09RIUxRJyNFVycjRVdPT1EhTFEnI0VZJyNFWU8xdVEhTFNPJyNFW08yXVEhTFNPJyNFYE8wU1EhTFNPJyNFYk8ycFEhTFVPJyNFYk8wU1EhTFNPJyNFZU8vbVEhTFNPJyNFaE8vbVEhTFNPJyNFbE8vbVEhTFNPJyNFb08ye1EhTFNPJyNFcU8zU1EhTFNPJyNFdk8zX1EhTFNPJyNFck8vbVEhTFNPJyNFdk8wU1EhTFNPJyNFeE8wU1EhTFNPJyNFfU9PUSFMUScjQ2MnI0NjT09RIUxRJyNDZCcjQ2RPT1EhTFEnI0NlJyNDZU9PUSFMUScjQ2YnI0NmT09RIUxRJyNDZycjQ2dPT1EhTFEnI0NoJyNDaE9PUSFMUScjQ2onI0NqTydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TydVUSFMU08sNTh8TzNkUSFMU08nI0RuT09RIUxRLDU6WCw1OlhPM3dRIUxTTyw1OltPNFVRIylXTyw1OltPNFpRIUxVTyw1OVdPMGdRIUxTTyw1OV9PMGdRIUxTTyw1OV9PMGdRIUxTTyw1OV9PNnlRIUxTTyw1OV9PN09RIUxTTyw1OV9PN1ZRIUxTTyw1OWdPN15RIUxTTycjR2JPOGRRIUxTTycjR2FPT1EhTFEnI0dhJyNHYU9PUSFMUScjRFknI0RZTzh7USFMU08sNTldTydVUSFMU08sNTldTzlaUSFMU08sNTldTzlgUSFMU08sNTpRTydVUSFMU08sNTpRT09RIUxRLDU5fSw1OX1POW5RIUxTTyw1OX1POXNRIUxTTyw1OldPJ1VRIUxTTyw1OldPJ1VRIUxTTyw1OlVPT1EhTFEsNTpSLDU6Uk86VVEhTFNPLDU6Uk86WlEhTFNPLDU6Vk9PT08nI0ZdJyNGXU86YE9XTyw1OmBPT1EhTFEsNTpgLDU6YE9PT08nI0ZeJyNGXk86aE9gTyw1OmBPOnBRIUxTTycjRHZPT09PJyNGXycjRl9PO1FPcE8sNTphT09RIUxRLDU6YSw1OmFPT09PJyNGYicjRmJPO11PIWJPLDU6YU9PT08nI0ZjJyNGY087aE8jdE8sNTphT09PTycjRmQnI0ZkTztzTyZqTyw1OmFPT1EhTFEnI0ZlJyNGZU88T1EhTFVPLDU6ZU8+cFEhTFVPLDU8bU8/WlEjNF5PJyNGZk8/fVEhTFVPLDU8bU9PUSFMUSw1OnksNTp5T0BmUSFMVE8nI0ZtT0F1USFMU08sNTtVT09RJkZWLDU8ayw1PGtPQlFRIUxVTycjSFlPQmlRIUxTTyw1O2xPT1EhTFEtRTlyLUU5ck9PUSZGViw1O2ssNTtrTzNZUSFMU08nI0V4T09RIUxSLUU5US1FOVFPQnFRIUxVTyw1OVpPRHhRIUxVTyw1OWZPRWNRIUxTTycjR2RPRW5RIUxTTycjR2RPMFNRIUxTTycjR2RPRXlRIUxTTycjRFFPRlJRIUxTTyw1OWpPRldRIUxTTycjR2hPJ1VRIUxTTycjR2hPL21RIUxTTyw1PVJPT1EhTFEsNT1SLDU9Uk8vbVEhTFNPJyNEfU9PUSFMUScjRU8nI0VPT0Z1USFMU08nI0ZnT0dWUSFMU08sNTh6T0dlUSFMU08sNTh6TylrUSFMU08sNTprT0dqUSFMVU8nI0dqT09RIUxRLDU6biw1Om5PT1EhTFEsNTp2LDU6dk9HfVEhTFNPLDU6ek9IYFEhTFNPLDU6fE9PUSFMUScjRmonI0ZqT0huUSFMVU8sNTp8T0h8USFMU08sNTp8T0lSUSFMU08nI0hbT09RIUxRLDU7UCw1O1BPSWFRIUxTTycjSFhPT1EhTFEsNTtTLDU7U08zX1EhTFNPLDU7V08zX1EhTFNPLDU7Wk9JclEhTFVPJyNIXk8nVVEhTFNPJyNIXk9JfFEhTFNPLDU7XU8ye1EhTFNPLDU7XU8vbVEhTFNPLDU7Yk8wU1EhTFNPLDU7ZE9KUlEhTFRPJyNFbU9LW1EmRlhPLDU7Xk9Oc1EhTFNPJyNIX08zX1EhTFNPLDU7Yk8hIE9RIUxTTyw1O2RPISBUUSFMU08sNTtpTyEjeFEhTFVPMUcuaE8hJFBRIUxVTzFHLmhPISZwUSFMVU8xRy5oTyEmelEhTFVPMUcuaE8hKWVRIUxVTzFHLmhPISl4USFMVU8xRy5oTyEqXVEhTFVPMUcuaE8hLHtRIUxTTycjR3BPIS1aUSFMVU8nI0dTTy9tUSFMU08nI0dwTyEtZVEhTFNPJyNHb09PUSFMUSw1OlksNTpZTyEtbVEhTFNPLDU6WU8hLXJRIUxTTycjR3FPIS19USFMU08nI0dxTyEuYlEhTFNPMUcvdk9PUSFMUScjRHInI0RyT09RIUxRMUcvdjFHL3ZPT1EhTFExRy55MUcueU8hL2JRIUxVTzFHLnlPIS9pUSFMVU8xRy55TzBnUSFMU08xRy55TyEwVVEhTFNPMUcvUk9PUSFMUScjRFgnI0RYTy9tUSFMU08sNTlyT09RIUxRMUcudzFHLndPITBdUSFMU08xRy9kTyEwbVEhTFNPMUcvZE8hMHVRIUxTTzFHL2VPJ1VRIUxTTycjR2lPITB6USFMU08nI0dpTyExUFEhTFVPMUcud08hMWFRIUxTTyw1OWZPITJnUSFMU08nI0ZYTyEyelEhTFNPLDU9WE8hM1NRIUxTTzFHL2xPITNYUSFMVU8xRy9sT09RIUxRMUcvaTFHL2lPITNpUSFMU08nI0ZVTyE0Y1EhTFNPLDU9U08vbVEhTFNPMUcvcE8hNVFRIUxTTzFHL3JPITVWUSFMVU8xRy9yTyE1Z1EhTFVPMUcvcE9PUSFMUTFHL20xRy9tT09RIUxRMUcvcTFHL3FPT09PLUU5Wi1FOVpPT1EhTFExRy96MUcvek9PT08tRTlbLUU5W08hNXdRIUxTTycjR3xPL21RIUxTTycjR3xPITZWUSFMU08sNTpiT09PTy1FOV0tRTldT09RIUxRMUcvezFHL3tPT09PLUU5YC1FOWBPT09PLUU5YS1FOWFPT09PLUU5Yi1FOWJPT1EhTFEtRTljLUU5Y08hNmJRIUxVTzFHMlhPJ1VRIUxTTyw1PFFPT1EhTFEsNTxRLDU8UU9PUSFMUS1FOWQtRTlkT09RIUxRLDU8WCw1PFhPT1EhTFEtRTlrLUU5a09PUSZGVjFHMHAxRzBwTzBTUSFMU08nI0ZpTyE2eVEhTFVPLDU9dE9PUSFMUTFHMVcxRzFXTyE3YlEhTFNPMUcxV09PUSFMUScjRFQnI0RUTy9tUSFMU08sNT1PT09RIUxRLDU9Tyw1PU9PITdnUSFMU08nI0ZUTyE3dVEhTFNPLDU5bE8hN31RIUxTTzFHL1VPIThYUSFMVU8sNT1TT09RIUxRMUcybTFHMm1PT1EhTFEsNTppLDU6aU8hOHhRIUxTTycjR1JPT1EhTFEsNTxSLDU8Uk9PUSFMUS1FOWUtRTllTyE5WlEhTFNPMUcuZk9PUSFMUTFHMFYxRzBWTyE5aVEhTFNPJyNGV08hOXxRIUxTTyw1PVVPL21RIUxTTzFHMGZPL21RIUxTTzFHMGZPMFNRIUxTTzFHMGhPT1EhTFEtRTloLUU5aE8hOl9RIUxTTzFHMGhPITpqUSFMU08xRzBoTyE6b1EhTFNPJyNGbE8hO1FRIUxTTyw1PXZPITtgUSFMU08nI0ZoTyE7eVEhTFNPLDU9c08hPFtRJkZYTzFHMHJPIT9wUSZGWE8xRzB1TyFDUlEhTFNPJyNGcE8hQ2BRIUxTTyw1PXhPIUNoUSFMVU8sNT14Ty9tUSFMU08xRzB3TyFDclEhTFNPMUcwd08zX1EhTFNPMUcwfE8hIE9RIUxTTzFHMU9PT1EmRlYsNTtYLDU7WE8hQ3dRIUxUTyw1O1hPIUVqUSZGWE8xRzB4TyFJUlEhTFNPJyNGcU8zX1EhTFNPMUcweE8zX1EhTFNPMUcweE8hSWBRIUxTTycjRnJPIUlwUSFMU08sNT15TzBTUSFMU08sNT15T09RJkZWMUcwfDFHMHxPIUpaUSFMU08nI0V6TyFKYlEjKVdPMUcxT09PUSZGVjFHMVQxRzFUTzNfUSFMU08xRzFUT09RIUxRLDU9Wyw1PVtPT1EhTFEnI0RvJyNEb08vbVEhTFNPLDU9W08hSmpRIUxTTycjRlpPIUtRUSFMU08sNT1aT09RIUxRMUcvdDFHL3RPIUtZUSFMU08nI0ZbTyFLbVEhTFNPLDU9XU8hS3VRIUxTTyw1PV1PIUxZUSFMU08sNT1dTyFMalEhTFNPLDU9XU9PUSFMUTcrJWI3KyViT09RIUxRNyskZTcrJGVPITd9USFMU083KyRtTyFOXVEhTFNPMUcueU8hTmRRIUxTTzFHLnlPT1EhTFExRy9eMUcvXk9PUSFMUSw1O3EsNTtxTydVUSFMU08sNTtxT09RIUxRNyslTzcrJU9PIU5rUSFMU083KyVPT09RIUxRLUU5VC1FOVRPT1EhTFE3KyVQNyslUE8hTntRIUxTTyw1PVRPJ1VRIUxTTyw1PVRPT1EhTFE3KyRjNyskY08jIFFRIUxTTzcrJU9PIyBZUSFMU083KyVQT09RIUxRLDU7cyw1O3NPJ1VRIUxTTyw1O3NPT1EhTFEtRTlWLUU5Vk9PUSFMUTcrJVc3KyVXTyMgX1EhTFNPMUcyc08jIGdRIUxTTzcrJVdPT1EhTFEsNTtwLDU7cE8nVVEhTFNPLDU7cE9PUSFMUS1FOVMtRTlTTyMgbFEhTFNPNyslW09PUSFMUTcrJV43KyVeTyMgelEhTFNPMUcybk8jIWlRIUxTTzcrJV5PIyFuUSFMU08nI0ZZTyMjUlEhTFNPMUcydE8jI1pRIUxTTzcrJVtPIyNgUSFMU08nI0ZgTyMjeVEhTFNPLDU9aE8jI3lRIUxTTyw1PWhPIyRYT01oTycjRHhPIyRkT1FPJyNHfU9PT08xRy98MUcvfE8jJGlRIUxTTzFHL3xPIyRxUSFMVU8xRzFsT09RIUxRLDU8VCw1PFRPT1EhTFEtRTlnLUU5Z09PUSFMUTcrJnI3KyZyT09RIUxRMUcyajFHMmpPT1EhTFEsNTtvLDU7b09PUSFMUS1FOVItRTlST09RIUxRNyskcDcrJHBPIyVbUSFMU08nI0ZmTyMleFEhTFNPLDU8bU8jJlpRIUxVTyw1O3JPT1EhTFEtRTlVLUU5VU9PUSFMUTcrJlE3KyZRTyMmblEhTFNPNysmUU9PUSFMUTcrJlM3KyZTTyMmfFEhTFNPJyNIWk8wU1EhTFNPNysmU08jJ2JRIUxTTzcrJlNPT1EhTFEsNTxXLDU8V09PUSFMUS1FOWotRTlqT09RIUxRLDU8Uyw1PFNPT1EhTFEtRTlmLUU5Zk8jJ21RJkZYTzcrJl5PIUlSUSFMU08nI0ZvTzNfUSFMU083KyZeTzNfUSFMU083KyZhTyMrUlEhTFVPLDU8W08nVVEhTFNPLDU8W09PUSFMUS1FOW4tRTluTyMrXVEhTFNPMUczZE8zX1EhTFNPNysmY08vbVEhTFNPNysmY09PUSZGVjcrJmg3KyZoTyFKYlEjKVdPNysmak8jK2VRJkZXTzFHMHNPT1EmRlYtRTlvLUU5b08zX1EhTFNPNysmZE8zX1EhTFNPNysmZE9PUSZGViw1PF0sNTxdTyMrcFEhTFNPLDU8XU9PUSZGVjcrJmQ3KyZkTyMre1EmRlhPNysmZE8jL15RIUxTTyw1PF5PT1EhTFEtRTlwLUU5cE8jL2lRIUxTTzFHM2VPIy9xUSFMU08nI0hhTyMwUFEhTFNPJyNIYU8wU1EhTFNPJyNIYU9PUSFMUScjSGEnI0hhTyMwW1EhTFNPJyNIYE9PUSFMUSw1O2YsNTtmTyMwZFEhTFNPLDU7Zk8vbVEhTFNPJyNFfE9PUSZGVjcrJmo3KyZqTzNfUSFMU083KyZqT09RJkZWNysmbzcrJm9PT1EhTFExRzJ2MUcydk9PUSFMUSw1O3UsNTt1T09RIUxRLUU5WC1FOVhPIzBpUSFMU08sNTt2TyMwdFEhTFNPLDU7dk9PUSFMUS1FOVktRTlZTyMxWFEhTFNPMUcyd08jMWFRIUxTTzFHMndPIzFxUSFMU08xRzJ3TyMxWFEhTFNPMUcyd09PUSFMUTw8SFg8PEhYTyMxfFEhTFVPMUcxXU9PUSFMUTw8SGo8PEhqUCMyV1EhTFNPJyNGVk83VlEhTFNPMUcyb08jMmVRIUxTTzFHMm9PIzJqUSFMU088PEhqT09RIUxRPDxIazw8SGtPIzJ6USFMVU8xRzFfT09RIUxRPDxIcjw8SHJPIzNVUSFMVU8xRzFbTyMzdVEhTFNPNysoYE8jM31RIUxTTzw8SHZPT1EhTFE8PEh4PDxIeE8jNFNRIUxTTyw1O3RPJ1VRIUxTTyw1O3RPT1EhTFEtRTlXLUU5V09PUSFMUTw8SHY8PEh2T09RIUxRLDU7eiw1O3pPL21RIUxTTyw1O3pPT1EhTFEtRTleLUU5Xk8jNFhRIUxTTzFHM1NPT09PJyNGYScjRmFPIzRnT01oTyw1OmRPT09PLDU9aSw1PWlPT09PNyslaDcrJWhPIzRyUSFMU08xRzJYTy9tUSFMU088PElsTyM1VFEhTFNPJyNGa08jNWlRIUxTTyw1PXVPMFNRIUxTTyw1PXVPIzV6USFMU088PEluT09RIUxRPDxJbjw8SW5PMFNRIUxTTzw8SW5PT1EmRlYtRTltLUU5bU8zX1EhTFNPPDxJeE9PUSZGViw1PFosNTxaTzNfUSFMU08sNTxaT09RJkZWPDxJeDw8SXhPT1EmRlY8PEl7PDxJe08jNlBRIUxVTzFHMXZPIzZaUSZGWE88PEl9TzNfUSFMU088PEl9T09RJkZWPDxKVTw8SlVPM19RIUxTTzw8SlVPIUN3USFMVE8nI0ZuTyM5bFEmRldPNysmX09PUSZGVjcrJl83KyZfT09RJkZWPDxKTzw8Sk9PIzl3USZGWE88PEpPT09RJkZWMUcxdzFHMXdPMFNRIUxTTzFHMXdPM19RIUxTTzw8Sk9PMFNRIUxTTzFHMXhPIz1ZUSFMU083KylQT09RIUxRJyNFeycjRXtPL21RIUxTTyw1PXtPIz1iUSFMU08sNT17T09RIUxRLDU9eyw1PXtPIz1tUSFMU08nI0ZzTyM9d1EhTFNPLDU9ek9PUSFMUTFHMVExRzFRT09RIUxRLDU7aCw1O2hPIz5QUSFMU08xRzFiTyM+ZFEhTFNPMUcxYk8jPnRRIUxTTzFHMWJPIz9QUSFMU083KyhjTyM/UFEhTFNPNysoY08jP1hRIUxTTzcrKGNPIz9pUSFMU083KyhaTzdWUSFMU083KyhaT09RIUxRQU4+VUFOPlVPT1EhTFFBTj5iQU4+Yk8vbVEhTFNPMUcxYE8jQFNRIUxVTzFHMWBPT1EhTFExRzFmMUcxZk9PT08tRTlfLUU5X09PUSFMUUFOP1dBTj9XTyNAXlEhTFNPLDU8Vk9PUSFMUS1FOWktRTlpTyNAclEhTFNPMUczYU9PUSFMUUFOP1lBTj9ZTyNBVFEhTFNPQU4/WU9PUSZGVkFOP2RBTj9kT09RJkZWMUcxdTFHMXVPM19RIUxTT0FOP2lPI0FZUSZGWE9BTj9pT09RJkZWQU4/cEFOP3BPT1EmRlUsNTxZLDU8WU9PUSZGVS1FOWwtRTlsT09RJkZWPDxJeTw8SXlPM19RIUxTT0FOP2pPM19RIUxTTzcrJ2NPT1EmRlZBTj9qQU4/ak9PUSFMUTcrJ2Q3KydkT09RIUxRMUczZzFHM2dPL21RIUxTTzFHM2dPT1EhTFEsNTxfLDU8X09PUSFMUS1FOXEtRTlxTyNEa1EhTFNPNysmfE8jRHtRIUxTTzcrJnxPT1EhTFE3KyZ8NysmfE8jRVdRIUxTTzw8S31PI0VXUSFMU088PEt9TyNFYFEhTFNPJyNHa09PUSFMUTw8S3U8PEt1TyNFalEhTFNPPDxLdU9PUSFMUTcrJno3KyZ6TzBTUSFMU08xRzFxTyNGVFEhTFNPNysoe09PUSFMUUcyNHRHMjR0T09RJkZWRzI1VEcyNVRPM19RIUxTT0cyNVRPT1EmRlZHMjVVRzI1VU9PUSZGVjw8Sn08PEp9T09RIUxRNyspUjcrKVJPT1EhTFE8PEpoPDxKaE8jRmZRIUxTTzw8SmhPI0Z2USFMU09BTkFpTyNHT1EhTFNPJyNHbE9PUSFMUScjR2wnI0dsTzBuUSFMU08nI0RiTyNHaVEhTFNPLDU9Vk9PUSFMUUFOQWFBTkFhT09RIUxRNysnXTcrJ11PT1EmRlZMRCpvTEQqb09PUSFMUUFOQFNBTkBTTyNIUVEhTFNPLDU5fE9PUSFMUTFHMnExRzJxTyNFYFEhTFNPMUcvaE9PUSFMUTcrJVM3KyVTTzdWUSFMU08nI0N6TzdWUSFMU08sNTlfTzdWUSFMU08sNTlfTzdWUSFMU08sNTlfTyNIVlEhTFVPLDU8bU83VlEhTFNPMUcueU8vbVEhTFNPMUcvVU8vbVEhTFNPNyskbU8nVVEhTFNPJyNHUk8jSGpRIUxTTyw1OV9PI0hvUSFMU08sNTlfTyNIdlEhTFNPLDU5ak8jSHtRIUxTTzFHL1JPMG5RIUxTTycjRE9PN1ZRIUxTTyw1OWdcIixcbiAgc3RhdGVEYXRhOiBcIiNJXn5PJHFPUyRsT1Mka09TUU9Tfk9QaE9UZU9kc09mWE9sdE9wIVNPc3VPdWRPfXZPIU8hUE8hUyFWTyFUIVVPIVdZTyFbWk8hZ2RPIW5kTyFvZE8hcGRPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8jZCFUTyNnIVdPI2shWE8jbSFZTyNyIVpPI3VsTyRqcU8kfFFPJH1RTyVSUk8lU1ZPJWdbTyVoXU8la15PJW5fTyV0YE8ld2FPJXliT35PVCFhT10hYU9fIWJPZiFqTyFXIWxPIWUhbU8kdyFbTyR4IV1PJHkhXk8keiFfTyR7IV9PJHwhYE8kfSFgTyVPIWFPJVAhYU8lUSFhT35PaCVWWGklVlhqJVZYayVWWGwlVlhtJVZYcCVWWHglVlh5JVZYIXQlVlgjXyVWWCRqJVZYJG0lVlglWCVWWCFQJVZYIVMlVlghVCVWWCVZJVZYIVglVlghXSVWWCFPJVZYI1clVlhxJVZYIWslVlh+UCRiT2RzT2ZYT3VkTyFXWU8hW1pPIWdkTyFuZE8hb2RPIXBkTyR8UU8kfVFPJVJSTyVTVk8lZ1tPJWhdTyVrXk8lbl9PJXRgTyV3YU8leWJPfk94JVVYeSVVWCNfJVVYJGolVVgkbSVVWCVYJVVYfk9oIXBPaSFxT2ohb09rIW9PbCFyT20hc09wIXRPIXQlVVh+UChmT1Qhek9sLHFPcy1PT312T35QJ1VPVCF9T2wscU9zLU9PIVgjT09+UCdVT1QjUk9fI1NPbCxxT3MtT08hXSNUT35QJ1VPJWkjV08laiNZT35PJWwjWk8lbSNZT35PIVsjXU8lbyNeTyVzI2BPfk8hWyNdTyV1I2FPJXYjYE9+TyFbI11PJWojYE8leCNjT35PIVsjXU8lbSNgTyV6I2VPfk9UJHZYXSR2WF8kdlhmJHZYaCR2WGkkdlhqJHZYayR2WGwkdlhtJHZYcCR2WHgkdlghVyR2WCFlJHZYJHckdlgkeCR2WCR5JHZYJHokdlgkeyR2WCR8JHZYJH0kdlglTyR2WCVQJHZYJVEkdlghUCR2WCFTJHZYIVQkdlh+TyVnW08laF1PJWteTyVuX08ldGBPJXdhTyV5Yk95JHZYIXQkdlgjXyR2WCRqJHZYJG0kdlglWCR2WCVZJHZYIVgkdlghXSR2WCFPJHZYI1ckdlhxJHZYIWskdlh+UCt7T3gjak95JHVYIXQkdVgjXyR1WCRqJHVYJG0kdVglWCR1WH5PbCxxT3MtT09+UCdVTyNfI21PJGojb08kbSNvT35PJVNWT35PIVMjdE8jbSFZTyNyIVpPI3VsT35PbHRPflAnVU9UI3lPXyN6T3UjeE8lU1ZPeXRQfk9UJE9PbCxxT3MtT08hTyRQT35QJ1VPeSRSTyF0JFdPJVgkU08jXyF1WCRqIXVYJG0hdVh+T1QkT09sLHFPcy1PTyNfI09YJGojT1gkbSNPWH5QJ1VPbCxxT3MtT08jXyNTWCRqI1NYJG0jU1h+UCdVTyFlJF5PIW4kXk8lU1ZPfk9UJGhPflAnVU8hVCRqTyNrJGtPI20kbE9+T3kkbU9+T1QkfE9fJHxPbCxxT3MtT08hUCVPT35QJ1VPbCxxT3MtT095JVJPflAnVU8lZiVUT35PXyFiT2Yhak8hVyFsTyFlIW1PVGBhXWBhaGBhaWBhamBha2BhbGBhbWBhcGBheGBheWBhIXRgYSNfYGEkamBhJG1gYSR3YGEkeGBhJHlgYSR6YGEke2BhJHxgYSR9YGElT2BhJVBgYSVRYGElWGBhIVBgYSFTYGEhVGBhJVlgYSFYYGEhXWBhIU9gYSNXYGFxYGEha2Bhfk9rJVlPfk9sJVlPflAnVU9sLHFPflAnVU9oLHNPaSx0T2osck9rLHJPbCx6T20se09wLVBPIVAlVVghUyVVWCFUJVVYJVklVVghWCVVWCFdJVVYIU8lVVgjVyVVWCFrJVVYflAoZk8lWSVbT3glVFghUCVUWCFTJVRYIVQlVFghWCVUWHklVFh+T3glX08hUCVeTyFTJWNPIVQlYk9+TyFQJV5Pfk94JWZPIVMlY08hVCViTyFYJWFYfk8hWCVqT35PeCVrT3klbU8hUyVjTyFUJWJPIV0lW1h+TyFdJXFPfk8hXSVyT35PJWkjV08laiV0T35PJWwjWk8lbSV0T35PVCV3T2wscU9zLU9PfXZPflAnVU8hWyNdTyVvI15PJXMlek9+TyFbI11PJXUjYU8ldiV6T35PIVsjXU8laiV6TyV4I2NPfk8hWyNdTyVtJXpPJXojZU9+T1QhbWFdIW1hXyFtYWYhbWFoIW1haSFtYWohbWFrIW1hbCFtYW0hbWFwIW1heCFtYXkhbWEhVyFtYSFlIW1hIXQhbWEjXyFtYSRqIW1hJG0hbWEkdyFtYSR4IW1hJHkhbWEkeiFtYSR7IW1hJHwhbWEkfSFtYSVPIW1hJVAhbWElUSFtYSVYIW1hIVAhbWEhUyFtYSFUIW1hJVkhbWEhWCFtYSFdIW1hIU8hbWEjVyFtYXEhbWEhayFtYX5QI3lPeCNqT3kkdWEhdCR1YSNfJHVhJGokdWEkbSR1YSVYJHVhflAkYk9UJlFPbHRPc3VPeCRZWHkkWVghdCRZWCNfJFlYJGokWVgkbSRZWCVYJFlYflAnVU94I2pPeSR1YSF0JHVhI18kdWEkaiR1YSRtJHVhJVgkdWF+T1BoT1RlT2x0T3N1T312TyFPIVBPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8jXyRhWCRqJGFYJG0kYVh+UCdVTyNfI21PJGomVk8kbSZWT35PIWUmV09mJXxYJGolfFgjVyV8WCNfJXxYJG0lfFgjViV8WH5PZiFqTyRqJllPfk9oY2FpY2FqY2FrY2FsY2FtY2FwY2F4Y2F5Y2EhdGNhI19jYSRqY2EkbWNhJVhjYSFQY2EhU2NhIVRjYSVZY2EhWGNhIV1jYSFPY2EjV2NhcWNhIWtjYX5QJGJPcG5heG5heW5hI19uYSRqbmEkbW5hJVhuYX5PaCFwT2khcU9qIW9PayFvT2whck9tIXNPIXRuYX5QRGFPJVgmW094JVdYeSVXWH5PJVNWT3glV1h5JVdYfk94Jl9PeXRYfk95JmFPfk94JWtPI18lW1gkaiVbWCRtJVtYIVAlW1h5JVtYIV0lW1ghayVbWCVYJVtYfk9ULHlPbCxxT3MtT099dk9+UCdVTyVYJFNPI19TYSRqU2EkbVNhfk8lWCRTT35PeCZqTyNfJV5YJGolXlgkbSVeWGslXlh+UCRiT3gmbU8hTyZsTyNfI1NhJGojU2EkbSNTYX5PI1cmbk8jXyNVYSRqI1VhJG0jVWF+TyFlJF5PIW4kXk8jViZwTyVTVk9+TyNWJnBPfk94JnJPI18mT1gkaiZPWCRtJk9Yfk94JnRPI18le1gkaiV7WCRtJXtYeSV7WH5PeCZ4T2smUVh+UCRiT2sme09+T1BoT1RlT2x0T3N1T312TyFPIVBPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8kaidRT35QJ1VPcSdVTyNoJ1NPI2knVE9QI2ZhVCNmYWQjZmFmI2ZhbCNmYXAjZmFzI2ZhdSNmYX0jZmEhTyNmYSFTI2ZhIVQjZmEhVyNmYSFbI2ZhIWcjZmEhbiNmYSFvI2ZhIXAjZmEhdyNmYSF5I2ZhIXsjZmEhfSNmYSNQI2ZhI1QjZmEjViNmYSNZI2ZhI1ojZmEjXSNmYSNkI2ZhI2cjZmEjayNmYSNtI2ZhI3IjZmEjdSNmYSRpI2ZhJGojZmEkfCNmYSR9I2ZhJVIjZmElUyNmYSVnI2ZhJWgjZmElayNmYSVuI2ZhJXQjZmEldyNmYSV5I2ZhJG0jZmEkbiNmYSRvI2Zhfk94J1ZPI1cnWE95JlJYfk9mJ1pPfk9mIWpPeSRtT35PVCFhT10hYU9fIWJPZiFqTyFXIWxPIWUhbU8keSFeTyR6IV9PJHshX08kfCFgTyR9IWBPJU8hYU8lUCFhTyVRIWFPaFVpaVVpalVpa1VpbFVpbVVpcFVpeFVpeVVpIXRVaSNfVWkkalVpJG1VaSR3VWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk8keCFdT35QISBdTyR4VWl+UCEgXU9UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR8IWBPJH0hYE8lTyFhTyVQIWFPJVEhYU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJVhVaSFQVWkhU1VpIVRVaSVZVWkhWFVpIV1VaSFPVWkjV1VpcVVpIWtVaX5PJHohX08keyFfT35QISRXTyR6VWkke1VpflAhJFdPXyFiT2Yhak8hVyFsTyFlIW1PaFVpaVVpalVpa1VpbFVpbVVpcFVpeFVpeVVpIXRVaSNfVWkkalVpJG1VaSR3VWkkeFVpJHlVaSR6VWkke1VpJHxVaSR9VWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk9UIWFPXSFhTyVPIWFPJVAhYU8lUSFhT35QISdVT1RVaV1VaSVPVWklUFVpJVFVaX5QISdVT2Yhak8hVyFsTyFlIW1PVFVpXVVpX1VpaFVpaVVpalVpa1VpbFVpbVVpcFVpeFVpeVVpIXRVaSNfVWkkalVpJG1VaSR3VWkkeFVpJHlVaSR6VWkke1VpJHxVaSR9VWklT1VpJVBVaSVRVWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk8hUyVjTyFUJWJPeCVkWCFQJWRYfk8lWCdgTyVZJ2BPflAre094J2JPIVAlY1h+TyFQJ2RPfk94J2VPeSdnTyFYJWVYfk9sLHFPcy1PT3gnZU95J2hPIVglZVh+UCdVTyFYJ2pPfk9qIW9PayFvT2whck9tIXNPaGdpcGdpeGdpeWdpIXRnaSNfZ2kkamdpJG1naSVYZ2l+T2khcU9+UCEuZ09pZ2l+UCEuZ09oLHNPaSx0T2osck9rLHJPbCx6T20se09+T3EnbE9+UCEvcE9UJ3FPbCxxT3MtT08hUCdyT35QJ1VPeCdzTyFQJ3JPfk8hUCd1T35PIVQnd09+T3gnc08hUCd4TyFTJWNPIVQlYk9+UCRiT2gsc09pLHRPaixyT2ssck9sLHpPbSx7TyFQbmEhU25hIVRuYSVZbmEhWG5hIV1uYSFPbmEjV25hcW5hIWtuYX5QRGFPVCd8T2wscU9zLU9PeCN7WCFYI3tYflAnVU94JWZPIVglYWF+TyFYKE9Pfk94JWZPIVMlY08hVCViTyFYJWFhflAkYk9UKFNPbCxxT3MtT094I3hYIV0jeFgjXyN4WCRqI3hYJG0jeFghUCN4WHkjeFghayN4WCVYI3hYflAnVU94JWtPIV0lW2EjXyVbYSRqJVthJG0lW2EhUCVbYXklW2EhayVbYSVYJVthfk8hXShWT35PeCVrTyFTJWNPIVQlYk8hXSVbYX5QJGJPeChZTyFTJWNPIVQlYk8hXSViYX5QJGJPeChdT3klcFghXSVwWCFrJXBYfk95KGBPIV0oYk8hayhjT35PeCNqT3kkdWkhdCR1aSNfJHVpJGokdWkkbSR1aSVYJHVpfk8hZSZXT2YlfGEkaiV8YSNXJXxhI18lfGEkbSV8YSNWJXxhfk8kaihnT35PVCN5T18jek91I3hPJVNWT35PeCZfT3l0YX5PbHRPc3VPflAnVU94JWtPI18lW2EkaiVbYSRtJVthIVAlW2F5JVthIV0lW2EhayVbYSVYJVthflAkYk94KGxPI18kdVgkaiR1WCRtJHVYJVgkdVh+TyVYJFNPI19TaSRqU2kkbVNpfk94I3pYI18jelgkaiN6WCRtI3pYayN6WH5QJ1VPeCZqTyNfJV5hJGolXmEkbSVeYWslXmF+T1Qock9mKHRPJVNWT35PI1YodU9+TyVTVk94JGBYI18kYFgkaiRgWCRtJGBYfk94JnJPI18mT2EkaiZPYSRtJk9hfk9sLHFPcy1PT3gkW1gjXyRbWCRqJFtYJG0kW1h5JFtYflAnVU94JnRPI18le2EkaiV7YSRtJXtheSV7YX5PcSh8TyNiKHtPUCNgaVQjYGlkI2BpZiNgaWwjYGlwI2BpcyNgaXUjYGl9I2BpIU8jYGkhUyNgaSFUI2BpIVcjYGkhWyNgaSFnI2BpIW4jYGkhbyNgaSFwI2BpIXcjYGkheSNgaSF7I2BpIX0jYGkjUCNgaSNUI2BpI1YjYGkjWSNgaSNaI2BpI10jYGkjZCNgaSNnI2BpI2sjYGkjbSNgaSNyI2BpI3UjYGkkaSNgaSRqI2BpJHwjYGkkfSNgaSVSI2BpJVMjYGklZyNgaSVoI2BpJWsjYGklbiNgaSV0I2BpJXcjYGkleSNgaSRtI2BpJG4jYGkkbyNgaX5PcSh9T1AjY2lUI2NpZCNjaWYjY2lsI2NpcCNjaXMjY2l1I2NpfSNjaSFPI2NpIVMjY2khVCNjaSFXI2NpIVsjY2khZyNjaSFuI2NpIW8jY2khcCNjaSF3I2NpIXkjY2kheyNjaSF9I2NpI1AjY2kjVCNjaSNWI2NpI1kjY2kjWiNjaSNdI2NpI2QjY2kjZyNjaSNrI2NpI20jY2kjciNjaSN1I2NpJGkjY2kkaiNjaSR8I2NpJH0jY2klUiNjaSVTI2NpJWcjY2klaCNjaSVrI2NpJW4jY2kldCNjaSV3I2NpJXkjY2kkbSNjaSRuI2NpJG8jY2l+T1QpUE9rJGRYeCRkWH5QJ1VPeCZ4T2smUWF+T3gmeE9rJlFhflAkYk9rKVRPfk9QaE9UZU9sdE9wIVNPc3VPfXZPIU8hUE8hUyFWTyFUIVVPIXd4TyF5eU8he3pPIX17TyNQfE8jVH1PI1YhT08jWSFRTyNaIVFPI10hUk8jZCFUTyNnIVdPI2shWE8jbSFZTyNyIVpPI3VsT35QJ1VPcSlaTyNoJ1NPI2kpWU9QI2ZpVCNmaWQjZmlmI2ZpbCNmaXAjZmlzI2ZpdSNmaX0jZmkhTyNmaSFTI2ZpIVQjZmkhVyNmaSFbI2ZpIWcjZmkhbiNmaSFvI2ZpIXAjZmkhdyNmaSF5I2ZpIXsjZmkhfSNmaSNQI2ZpI1QjZmkjViNmaSNZI2ZpI1ojZmkjXSNmaSNkI2ZpI2cjZmkjayNmaSNtI2ZpI3IjZmkjdSNmaSRpI2ZpJGojZmkkfCNmaSR9I2ZpJVIjZmklUyNmaSVnI2ZpJWgjZmklayNmaSVuI2ZpJXQjZmkldyNmaSV5I2ZpJG0jZmkkbiNmaSRvI2Zpfk9sLHFPcy1PT3kkbU9+UCdVT2wscU9zLU9PeCRmWHkkZlh+UCdVT3gnVk95JlJhfk9UKWRPXyllT3UpY08lTylmTyVTVk9+TyFQKWhPflAhSXhPeSRtTyZVKWpPfk9UJHxPXyR8T2wscU9zLU9PeCN9WCFQI31YflAnVU94J2JPIVAlY2F+T2wscU9zLU9PeSlyT3gkT1ghWCRPWH5QJ1VPeCdlTyFYJWVhfk9sLHFPcy1PT3gnZU95KXVPIVglZWF+UCdVT2wscU9zLU9PeCdlTyFYJWVhflAnVU94J2VPeSl1TyFYJWVhfk9qLHJPayxyT2wsek9tLHtPaGdpcGdpeGdpIVBnaSFTZ2khVGdpJVlnaSFYZ2l5Z2khXWdpI19naSRqZ2kkbWdpIU9naSNXZ2lxZ2kha2dpJVhnaX5PaSx0T35QIUx1T2lnaX5QIUx1T1QncU9sLHFPcy1PTyFQKXpPflAnVU9rKXxPfk94Kk9PIVApek9+TyFQKlBPfk94JWZPIVglYWl+TyFYKlJPfk94KFlPIVMlY08hVCViTyFdJWJpfk94JWtPIV0lW2kjXyVbaSRqJVtpJG0lW2khUCVbaXklW2khayVbaSVYJVtpfk8hXSpWT35PXypYT2wscU9zLU9PeCN8WCFdI3xYflAnVU94KFlPIV0lYml+TyFdKlpPfk9UKl1PbCxxT3MtT094JFNYeSRTWCFdJFNYIWskU1h+UCdVT3goXU95JXBhIV0lcGEhayVwYX5PIVsjXU8lcipgTyFdIWxYfk8hXSpiT35PeShgTyFdKmNPfk94JFlpeSRZaSF0JFlpI18kWWkkaiRZaSRtJFlpJVgkWWl+UCRiT1QmUU9sLHFPcy1PT3gkWVgjXyRZWCRqJFlYJG0kWVglWCRZWH5QJ1VPeChsTyNfJHVhJGokdWEkbSR1YSVYJHVhfk94I3phI18jemEkaiN6YSRtI3phayN6YX5QJGJPeCplTyNfI1NxJGojU3EkbSNTcX5PeCpmTyNXKmhPI18lfVgkaiV9WCRtJX1YIVAlfVh+T1Qqak9mKmtPJVNWT35PcSptTyNiKHtPUCNgcVQjYHFkI2BxZiNgcWwjYHFwI2BxcyNgcXUjYHF9I2BxIU8jYHEhUyNgcSFUI2BxIVcjYHEhWyNgcSFnI2BxIW4jYHEhbyNgcSFwI2BxIXcjYHEheSNgcSF7I2BxIX0jYHEjUCNgcSNUI2BxI1YjYHEjWSNgcSNaI2BxI10jYHEjZCNgcSNnI2BxI2sjYHEjbSNgcSNyI2BxI3UjYHEkaSNgcSRqI2BxJHwjYHEkfSNgcSVSI2BxJVMjYHElZyNgcSVoI2BxJWsjYHElbiNgcSV0I2BxJXcjYHEleSNgcSRtI2BxJG4jYHEkbyNgcX5PayRkYXgkZGF+UCRiT3gmeE9rJlFpfk8kbSp5TyRuKndPJG8qeU9+T3gqfU95JG1PI1cqfU9+TyNpK09PUCNmcVQjZnFkI2ZxZiNmcWwjZnFwI2ZxcyNmcXUjZnF9I2ZxIU8jZnEhUyNmcSFUI2ZxIVcjZnEhWyNmcSFnI2ZxIW4jZnEhbyNmcSFwI2ZxIXcjZnEheSNmcSF7I2ZxIX0jZnEjUCNmcSNUI2ZxI1YjZnEjWSNmcSNaI2ZxI10jZnEjZCNmcSNnI2ZxI2sjZnEjbSNmcSNyI2ZxI3UjZnEkaSNmcSRqI2ZxJHwjZnEkfSNmcSVSI2ZxJVMjZnElZyNmcSVoI2ZxJWsjZnElbiNmcSV0I2ZxJXcjZnEleSNmcSRtI2ZxJG4jZnEkbyNmcX5PI1crUE94JGZheSRmYX5PeCdWT3kmUml+T3kkUk8lWCtST3gmVFghUCZUWH5PJVNWT3gmVFghUCZUWH5PeCtWTyFQJlNYfk8hUCtYT35PeStaT3gkT2EhWCRPYX5PbCxxT3MtT095K1tPeCRPYSFYJE9hflAnVU94J2VPIVglZWl+T2wscU9zLU9PeCdlTyFYJWVpflAnVU94J2VPeStgTyFYJWVpfk94I3lpIVAjeWl+UCRiT1QncU9sLHFPcy1PT35QJ1VPaytiT35PVCdxT2wscU9zLU9PIVArY09+UCdVT3gje2khWCN7aX5QJGJPeCN4aSFdI3hpI18jeGkkaiN4aSRtI3hpIVAjeGl5I3hpIWsjeGklWCN4aX5QJGJPeChZTyFdJWJxfk8hXStkT35PeStlT35PeChdT3klcGkhXSVwaSFrJXBpfk8hWyNdTyVyKmBPIV0hbGF+T3gobE8jXyR1aSRqJHVpJG0kdWklWCR1aX5PJVNWT3gkX1gjXyRfWCRqJF9YJG0kX1ghUCRfWH5PeCpmTyNfJX1hJGolfWEkbSV9YSFQJX1hfk8hUCttT35PayRkaXgkZGl+UCRiT3ErcU9QI2V5VCNleWQjZXlmI2V5bCNleXAjZXlzI2V5dSNleX0jZXkhTyNleSFTI2V5IVQjZXkhVyNleSFbI2V5IWcjZXkhbiNleSFvI2V5IXAjZXkhdyNleSF5I2V5IXsjZXkhfSNleSNQI2V5I1QjZXkjViNleSNZI2V5I1ojZXkjXSNleSNkI2V5I2cjZXkjayNleSNtI2V5I3IjZXkjdSNleSRpI2V5JGojZXkkfCNleSR9I2V5JVIjZXklUyNleSVnI2V5JWgjZXklayNleSVuI2V5JXQjZXkldyNleSV5I2V5JG0jZXkkbiNleSRvI2V5fk8kbSt2TyRuKndPJG8rdk9+TyNpK3dPUCNmeVQjZnlkI2Z5ZiNmeWwjZnlwI2Z5cyNmeXUjZnl9I2Z5IU8jZnkhUyNmeSFUI2Z5IVcjZnkhWyNmeSFnI2Z5IW4jZnkhbyNmeSFwI2Z5IXcjZnkheSNmeSF7I2Z5IX0jZnkjUCNmeSNUI2Z5I1YjZnkjWSNmeSNaI2Z5I10jZnkjZCNmeSNnI2Z5I2sjZnkjbSNmeSNyI2Z5I3UjZnkkaSNmeSRqI2Z5JHwjZnkkfSNmeSVSI2Z5JVMjZnklZyNmeSVoI2Z5JWsjZnklbiNmeSV0I2Z5JXcjZnkleSNmeSRtI2Z5JG4jZnkkbyNmeX5PeCdWT3kmUnF+TyVYK1JPeCZUYSFQJlRhfk94JGdYIVAkZ1h+UCFJeE94K1ZPIVAmU2F+T2wscU9zLU9PeSxQT3gkT2khWCRPaX5QJ1VPbCxxT3MtT094JE9pIVgkT2l+UCdVT3ksUE94JE9pIVgkT2l+T3gnZU8hWCVlcX5PbCxxT3MtT094J2VPIVglZXF+UCdVT3AsVU8hUyVjTyFUJWJPIVAlXXEhWCVdcSFdJV1xeCVdcX5QIS9wT3gjfGkhXSN8aX5QJGJPI1csWU94JF9hI18kX2EkaiRfYSRtJF9hIVAkX2F+T3gqZk8jXyV9aSRqJX1pJG0lfWkhUCV9aX5PIVAsW09+T3EsXk9QI2UhUlQjZSFSZCNlIVJmI2UhUmwjZSFScCNlIVJzI2UhUnUjZSFSfSNlIVIhTyNlIVIhUyNlIVIhVCNlIVIhVyNlIVIhWyNlIVIhZyNlIVIhbiNlIVIhbyNlIVIhcCNlIVIhdyNlIVIheSNlIVIheyNlIVIhfSNlIVIjUCNlIVIjVCNlIVIjViNlIVIjWSNlIVIjWiNlIVIjXSNlIVIjZCNlIVIjZyNlIVIjayNlIVIjbSNlIVIjciNlIVIjdSNlIVIkaSNlIVIkaiNlIVIkfCNlIVIkfSNlIVIlUiNlIVIlUyNlIVIlZyNlIVIlaCNlIVIlayNlIVIlbiNlIVIldCNlIVIldyNlIVIleSNlIVIkbSNlIVIkbiNlIVIkbyNlIVJ+T2wscU9zLU9PeCRPcSFYJE9xflAnVU95LGNPeCRPcSFYJE9xfk94J2VPIVglZXl+T2wscU9zLGdPflAnVU9wLFVPIVMlY08hVCViTyFQJV15IVglXXkhXSVdeXglXXl+UCEvcE94KmZPI18lfXEkaiV9cSRtJX1xIVAlfXF+T2wscU9zLU9PeCRPeSFYJE95flAnVU94J2VPIVglZSFSfk9wJWBYIVAlYFghUyVgWCFUJWBYIVglYFghXSVgWHglYFh+UCEvcE9wLFVPIVMlY08hVCViTyFQJV9hIVglX2EhXSVfYXglX2F+T3ksb09+T3gobE8jXyR1YSRqJHVhJG0kdWElWCR1YX5QJGJPayx2T35PbCx2T35QJ1VPeSx3T35PcSx4T35QIS9wTyVoJWsldyV5JWclbiV0JVMlZ35cIixcbiAgZ290bzogXCIhJmgmVVBQUFAmVlAmXyh8KWQpeyplK08ralAsVlAmXyx0LHQmX1AmX1AvY1BQUFBQUC9jMWJQUDFiUDJ9UDNXN2BQUDdjN283clBQUCZfJl9QUDhPJl9QUCZfJl9QUCZfJl8mXyZfOFM4eCZfUDh7UDlPOU87cVA8ViZfUFBQPFo8YSZWUCZWJlZQJlZQJlZQJlZQJlZQJlYmViZWUCZWUFAmVlBQJlZQPGdQPG48dFA8blA8bjxuUFBQPG5QPm1QPnY+fD9TPm1QPG4/WVA/YT9nP20/eUBUQFpAZUBvQHVBY0FpQW9BdUJQQlZCXUJjQmlCb0NSQ11DY0NpQ29DeURQRFZEXURjRG1Ec0R9RVRQUFBQUFBQUFBFXkVoRXFFe0ZXUFBQUFBQUFBQUFBQSX1KZ05VISFxUFAhIXkhI1ghI2IhJFchI30hJGEhJGchJGohJG0hJHAhJHZQUFBQUFBQUFBQISR5ISR8UFBQUFBQUFBQISVTISVgISVsISV4ISV7ISZSISZYISZfISZiXWlPciNtJG0nUSp3JlhkT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhaiFsIW8hcCFxIXMhdCF6IX0jUiNTI10jaiNtJE8kUCRSJFQkVyRoJGokayRtJHwlUiVZJV0lXyViJWYlayVtJXcmUSZdJmEmaiZsJm0mdCZ4JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncSdzJ3cnfChTKFkoXShsKHspUClUKWopcil1KXspfCpPKlgqXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgseSx7LVB5IWNQI2kjdiRYJGclZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHV7IWRQI2kjdiRYJGckcyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdX0hZVAjaSN2JFgkZyRzJHQlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhUCFmUCNpI3YkWCRnJHMkdCR1JWQlaSVvJXAmYiZ6KGQobilPKXkqUSpTKnIrZix1IVIhZ1AjaSN2JFgkZyRzJHQkdSR2JWQlaSVvJXAmYiZ6KGQobilPKXkqUSpTKnIrZix1IVQhaFAjaSN2JFgkZyRzJHQkdSR2JHclZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhWCFpUCFuI2kjdiRYJGckcyR0JHUkdiR3JHglZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUmWFNPU1hZWmVocnN0dnh8fSFSIVMhVCFVIVghYyFkIWUhZiFnIWghaSFqIWwhbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0kfCVSJVklXSVfJWIlZiVrJW0ldyZRJl0mYSZqJmwmbSZ0JngmeydRJ1MnVidhJ2InZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUCR5VU9YWVpocnR2fH0hUiFTIVQhWCFqIWwhbyFwIXEhcyF0I10jaiNtJFAkUiRUJFckayRtJHwlUiVZJV0lXyVmJWslbSV3Jl0mYSZsJm0mdCZ7J1EnUydWJ2EnYidlJ2cnaCdsJ3MoWShdKGwoeylUKWopcil1KXspfCpPKl0qZSp3K1MrWitbK2ArYitlK3wsUCxVLGMsbyxxLHIscyx0LHYsdyx4LHstUCRUV09YWVpocnZ8fSFSIVMhVCFYIWohbCNdI2ojbSRQJFIkVCRXJGskbSR8JVIlXSVfJWYlayVtJXcmXSZhJmwmbSZ0JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncyhZKF0obCh7KVQpailyKXUpeypPKl0qZSp3K1MrWitbK2ArZSt8LFAsYyx3LHhRI3x1USxtLGdSLHwtTyZTZE9TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWwhbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0kfCVSJVklXSVfJWIlZiVrJW0ldyZRJl0mYSZqJmwmbSZ0JngmeydRJ1MnVidhJ2UnZydoJ2wncSdzJ3cnfChTKFkoXShsKHspUClUKWopcil1KXspfCpPKlgqXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgseSx7LVBXI3BsIU8hUCRfVyN4dSZfLGctT1EkYSFRUSRxIVlRJHIhWlMkeyFqJ2JTJl4jeSN6USdPJGxRKGUmV1EociZuVyhzJnAodCh1KmtRKHYmclEpYidYUyljJ1orVlMrVSlkKWVRK2oqZlErbCpoUSt4Kn1RK3orUFIsaixZUiZdI3hlIXdYWSFTIVQlXyVmJ3Moeyl7Kk9SJV0hdlEhe1hRJXgjXVEmZiRUUiZpJFdULGYsVSxvIVkha1AhbiNpI3YkWCRnJHMkdCR1JHYkdyR4JHklZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHVRJlojcVInXiRyUidhJHtSJVUhbSZXY09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWohbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnYidlJ2cnaCdsJ3Encyd3J3woUyhZKF0obCh7KVApVClqKXIpdSl7KXwqTypYKl0qZSp3K1MrWitbK2ArYitlK3wsUCxVLGMsbyxxLHIscyx0LHYsdyx4LHksey1QVCNnYyNoUyNeXyNfUyNhYCNiUyNjYSNkUyNlYiNmVCpgKGAqYVQoYSV4KGNRJFZ3UitUKWNYJFR3JFUkViZoWmtPciRtJ1Eqd1hvT3InUSp3USRuIVdRJnYkZVEmdyRmUSdZJHBRJ10kclEpVSZ9USlbJ1NRKV4nVFEpXydVUSlrJ1tRKW0nXlEqbih7USpwKHxRKnEofVEqcylTUyp1KVYpbFEqeilZUSp7KVpRKnwpXVErbyptUStwKm9RK3IqdFErcyp2USt5K09RLF0rcVEsXyt3USxgK3hSLGssXldvT3InUSp3UiNzblEnWyRxUilWJ09RK1MpY1IrfCtUUSlsJ1tSKnYpVlptT25yJ1Eqd1FyT1IjdXJRJmAje1IoaiZgUyVsI1EjfVMoVCVsKFdUKFclbyZiUSVgIXlTJ3QlYCd5Uid5JWRRJmskWFIobyZrUSVnIXxTJ30lZyhQUihQJWlRKFolcFEqVChVVCpZKFoqVFEnYyR9UilwJ2NTJ2YlUSVSWSlzJ2YpdCteLFMsZFUpdCdnJ2gnaVUrXil1KXYpd1MsUytfK2BSLGQsVFEjWF1SJXMjWFEjW15SJXUjW1EjX19SJXkjX1EoXiV2UypeKF4qX1IqXyhfUSphKGBSK2gqYVEjYmBSJXsjYlEjZGFSJXwjZFEjZmJSJX0jZlEjaGNSJk8jaFEja2ZRJlAjaVcmUyNrJlAobSpkUShtJmVSKmQsdVEkVXdTJmckVSZoUiZoJFZRJnUkY1IoeSZ1USZYI3BSKGYmWFEkXyFQUiZvJF9RKmcoc1MraypnLFpSLForbFEmcyRhUih3JnNRI25qUiZVI25RKngpV1IrdSp4USh6JnZSKmwoelEmeSRnUylRJnkpUlIpUiZ6USdSJG5SKVgnUlEnVyRvUylhJ1crUVIrUSliUStXKWdSLE8rV1duT3InUSp3UiNyblNxT3JRKVcnUVIrdCp3V3BPcidRKndSJ1AkbVlqT3IkbSdRKndSJlQjbVt3T3IjbSRtJ1Eqd1ImZiRUJHhQT1hZWmhydHZ8fSFSIVMhVCFYIWohbCFvIXAhcSFzIXQjXSNqI20kUCRSJFQkVyRrJG0kfCVSJVklXSVfJWYlayVtJXcmXSZhJmwmbSZ0JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncyhZKF0obCh7KVQpailyKXUpeyl8Kk8qXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgsey1QUSFuU1EjaWVRI3ZzVSRYeCViJ3dTJGchVSRqUSRzIWNRJHQhZFEkdSFlUSR2IWZRJHchZ1EkeCFoUSR5IWlRJWQhelElaSF9USVvI1JRJXAjU1EmYiRPUSZ6JGhRKGQmUVEobiZqUSlPJnhRKXkncVEqUSd8USpTKFNRKnIpUFErZipYUix1LHlRIXlYUSF8WVEkZSFTUSRmIVRXJ3AlXydzKXsqT1EneyVmUipvKHtbZk9yI20kbSdRKndkIXZYWSFTIVQlXyVmJ3Moeyl7Kk9RI1FaUSNsaFMjfXZ8USRbfVckYyFSJFcmeylUUyRvIVgka1MkeiFqJ2JRJVEhbFEldiNdUyZSI2oobFEmYyRQUSZkJFJRJmUkVFEnXyR8USdpJVJRJ28lXVEoUiVrUShVJW1RKF8ld1EoaCZdUyhrJmEsd1EocCZsUShxJm1RKHgmdFEpXSdTUSlgJ1ZRKW4nYVEpcSdlUSl2J2dRKXcnaFMpeCdsLHhRKlcoWVEqWyhdUStZKWpRK10pclErXyl1UStnKl1RK2kqZVEreytTUSxRK1pRLFIrW1EsVCtgUSxYK2VRLGErfFEsYixQUixsLGNiVE9yI2ojbSRtJmEnUSdsKncjcCF1WFlaaHZ8fSFSIVMhVCFYIWohbCNdJFAkUiRUJFckayR8JVIlXSVfJWYlayVtJXcmXSZsJm0mdCZ7J1MnVidhJ2InZSdnJ2gncyhZKF0obCh7KVQpailyKXUpeypPKl0qZStTK1orWytgK2UrfCxQLGMsdyx4USN3dFclViFvIXMscix7USVXIXBRJVghcVElWiF0USVlLHFTJ2slWSx2USdtLHNRJ24sdFErYSl8USxXK2JTLGUsVSxvUix9LVBVI3t1LGctT1IoaSZfW2dPciNtJG0nUSp3WCF4WCNdJFQkV1EjVlpRJFF2UiRafFElYSF5USVoIXxRJW4jUVEnXyR6USd6JWRRKFElaVEoWCVvUShbJXBRKlUoVVEsVithUSxpLFdSLG4saFEkWXhRJ3YlYlIpfSd3USxoLFVSLHAsb1IjUFlSI1VaUiVQIWpRJH0halIpbydiUiVTIWxSJXgjXVEoYiV4UipjKGNRJGQhUlEmaSRXUSlTJntSKnQpVFEjcWxRJF0hT1EkYCFQUiZxJF9RKHImcFEqaSh0USpqKHVSK24qa1IkYiFRWHBPcidRKndRJGkhVVImfCRqUSRwIVhSJn0ka1IpaSdaUSlnJ1pSK30rVlwiLFxuICBub2RlTmFtZXM6IFwi4pqgIHByaW50IENvbW1lbnQgU2NyaXB0IEFzc2lnblN0YXRlbWVudCAqIEJpbmFyeUV4cHJlc3Npb24gQml0T3AgQml0T3AgQml0T3AgQml0T3AgQXJpdGhPcCBBcml0aE9wIEAgQXJpdGhPcCAqKiBVbmFyeUV4cHJlc3Npb24gQXJpdGhPcCBCaXRPcCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gKCBCaW5hcnlFeHByZXNzaW9uIG9yIGFuZCBDb21wYXJlT3AgaW4gbm90IGlzIFVuYXJ5RXhwcmVzc2lvbiBDb25kaXRpb25hbEV4cHJlc3Npb24gaWYgZWxzZSBMYW1iZGFFeHByZXNzaW9uIGxhbWJkYSBQYXJhbUxpc3Qgc2VsZiBWYXJpYWJsZU5hbWUgQXNzaWduT3AgLCA6IE5hbWVkRXhwcmVzc2lvbiBBc3NpZ25PcCBZaWVsZEV4cHJlc3Npb24geWllbGQgZnJvbSApIFR1cGxlRXhwcmVzc2lvbiBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBhc3luYyBmb3IgTGFtYmRhRXhwcmVzc2lvbiBBcnJheUV4cHJlc3Npb24gWyBdIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gRGljdGlvbmFyeUV4cHJlc3Npb24geyB9IERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBTZXRFeHByZXNzaW9uIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uIENhbGxFeHByZXNzaW9uIEFyZ0xpc3QgQXNzaWduT3AgTWVtYmVyRXhwcmVzc2lvbiAuIFByb3BlcnR5TmFtZSBOdW1iZXIgU3RyaW5nIEZvcm1hdFN0cmluZyBGb3JtYXRSZXBsYWNlbWVudCBGb3JtYXRDb252ZXJzaW9uIEZvcm1hdFNwZWMgQ29udGludWVkU3RyaW5nIEVsbGlwc2lzIE5vbmUgQm9vbGVhbiBUeXBlRGVmIEFzc2lnbk9wIFVwZGF0ZVN0YXRlbWVudCBVcGRhdGVPcCBFeHByZXNzaW9uU3RhdGVtZW50IERlbGV0ZVN0YXRlbWVudCBkZWwgUGFzc1N0YXRlbWVudCBwYXNzIEJyZWFrU3RhdGVtZW50IGJyZWFrIENvbnRpbnVlU3RhdGVtZW50IGNvbnRpbnVlIFJldHVyblN0YXRlbWVudCByZXR1cm4gWWllbGRTdGF0ZW1lbnQgUHJpbnRTdGF0ZW1lbnQgUmFpc2VTdGF0ZW1lbnQgcmFpc2UgSW1wb3J0U3RhdGVtZW50IGltcG9ydCBhcyBTY29wZVN0YXRlbWVudCBnbG9iYWwgbm9ubG9jYWwgQXNzZXJ0U3RhdGVtZW50IGFzc2VydCBTdGF0ZW1lbnRHcm91cCA7IElmU3RhdGVtZW50IEJvZHkgZWxpZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBGb3JTdGF0ZW1lbnQgVHJ5U3RhdGVtZW50IHRyeSBleGNlcHQgZmluYWxseSBXaXRoU3RhdGVtZW50IHdpdGggRnVuY3Rpb25EZWZpbml0aW9uIGRlZiBQYXJhbUxpc3QgQXNzaWduT3AgVHlwZURlZiBDbGFzc0RlZmluaXRpb24gY2xhc3MgRGVjb3JhdGVkU3RhdGVtZW50IERlY29yYXRvciBBdFwiLFxuICBtYXhUZXJtOiAyMzYsXG4gIG5vZGVQcm9wczogW1xuICAgIFtsZXplci5Ob2RlUHJvcC5ncm91cCwgLTE0LDQsODEsODMsODQsODYsODgsOTAsOTIsOTQsOTUsOTYsOTgsMTAxLDEwNCxcIlN0YXRlbWVudCBTdGF0ZW1lbnRcIiwtMjMsNiwxNiwxOSwyMSwzNywzOCw0OCw0OSw1Myw1Niw1Nyw2MCw2MSw2Miw2Myw2Niw2OSw3MCw3MSw3NSw3Niw3Nyw3OCxcIkV4cHJlc3Npb25cIiwtOSwxMDYsMTA4LDExMSwxMTMsMTE0LDExOCwxMjAsMTI1LDEyNyxcIlN0YXRlbWVudFwiXVxuICBdLFxuICBza2lwcGVkTm9kZXM6IFswLDJdLFxuICByZXBlYXROb2RlQ291bnQ6IDMzLFxuICB0b2tlbkRhdGE6IFwiIUV9TWdSIV5PWCR9WFkld1lbJH1bXSV3XXAkfXBxJXdxcihjcnMqVXN0Mk90dSR9dXY0UXZ3NVV3eDV4eHlBV3l6QXR6e0Jie3xDcnx9RGZ9IU9FUyFPIVBGWiFQIVFLYSFRIVJMcSFSIVshKFAhWyFdISlpIV0hXiEqbSFeIV8hK1ohXyFgISxrIWAhYSEtXyFhIWIkfSFiIWMhLmwhYyFkIS9iIWQhZSExZiFlIWghL2IhaCFpIThPIWkhdCEvYiF0IXUhPWIhdSF3IS9iIXcheCE/YCF4IX0hL2IhfSNPIUB0I08jUCFBYiNQI1EhQmMjUSNSIUNQI1IjUyEvYiNTI1QkfSNUI1UhL2IjVSNWITFmI1YjWSEvYiNZI1ohOE8jWiNmIS9iI2YjZyE9YiNnI2khL2IjaSNqIT9gI2ojbyEvYiNvI3AhQ3MjcCNxIURbI3EjciFFTyNyI3MhRWEjcyRnJH0kZ34hL2I8ciVgUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWk3WyVuUiVyN1tPI28laSNwI3ElaSNyfiVpTWcmW1olb2AldXAlcjdbJXghYiV6I3QlaVMlbFckcTFzT1glaVhZJn1ZWyVpW10mfV1wJWlwcSZ9cSNPJWkjTyNQJ3cjUCNvJWkjcCNxJWkjcn4laUhQJ1VaJXI3WyRxMXNPWCVpWFkmfVlbJWlbXSZ9XXAlaXBxJn1xI08laSNPI1AndyNQI28laSNwI3ElaSNyfiVpSFAnfFYlcjdbT1klaVlaJn1aXSVpXV4mfV4jbyVpI3AjcSVpI3J+JWk8dSh0WSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYClkIWAjVCVpI1QjVSl0I1UjZiVpI2YjZyl0I2cjaCl0I2gjbyVpI3AjcSVpI3J+JWk3XylrUmpSJXI3W08jbyVpI3AjcSVpI3J+JWk3Xyl7UiFrUiVyN1tPI28laSNwI3ElaSNyfiVpR3sqZV0ldnAlb2AlcjdbJXghYiVpUyVnLFhPWSteWVoue1pdK15dXi57XnIrXnJzL11zI08rXiNPI1AwfCNQI28rXiNvI3AxYiNwI3ErXiNxI3IxYiNyfiteQm0rZ10lcjdbJWxXJWcsWE9ZLGBZWiVpWl0sYF1eJWlecixgcnMtYHMjTyxgI08jUC1wI1AjbyxgI28jcC5VI3AjcSxgI3Ejci5VI3J+LGBCZSxnXSVyN1slZyxYT1ksYFlaJWlaXSxgXV4laV5yLGBycy1gcyNPLGAjTyNQLXAjUCNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYEJlLWdSJXI3WyVnLFhPI28laSNwI3ElaSNyfiVpQmUtdVQlcjdbTyNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYCxYLlpWJWcsWE9ZLlVaXS5VXnIuVXJzLnBzI08uVSNPI1AudSNQfi5VLFgudU8lZyxYLFgueFBPfi5VN2QvU1IlcjdbJWxXTyNvJWkjcCNxJWkjcn4laUVjL2RYJXI3WyVnLFhPci57cnMwUHMjTy57I08jUDBjI1Ajby57I28jcDB3I3AjcS57I3EjcjB3I3J+LntFYzBZUiVtI3wlcjdbJWssWE8jbyVpI3AjcSVpI3J+JWk3ZDBoVCVyN1tPI28ueyNvI3AwdyNwI3EueyNxI3IwdyNyfi57VzB8TyVsV0JtMVJUJXI3W08jbyteI28jcDFiI3AjcSteI3EjcjFiI3J+K14sYTFpViVsVyVnLFhPWS5VWl0uVV5yLlVycy5wcyNPLlUjTyNQLnUjUH4uVU1nMmNYUTFzJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXT1kzT1laJWlaXTNPXV4laV4jbzNPI28jcDNyI3AjcTNPI3EjcjNyI3J+M09IUDNWWFExcyVyN1tPWTNPWVolaVpdM09dXiVpXiNvM08jbyNwM3IjcCNxM08jcSNyM3Ijcn4zTzFzM3dSUTFzT1kzclpdM3JefjNyR3o0ZVQlUFElb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpQmQ0e1IhdCxXJXI3W08jbyVpI3AjcSVpI3J+JWlHejVpVCR5USVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHezZYXyVzYCV1cCVyN1sleiN0JWxXJWcsWE9ZN1dZWjpkWl03V11eOmRecjdXcnM6eHN3N1d3eDt8eCNPN1cjTyNQPm4jUCNvN1cjbyNwP3QjcCNxN1cjcSNyP1Mjcn43V0ZxN2VdJXI3WyV4IWIleiN0JWlTJWcsWE9ZOF5ZWiVpWl04Xl1eJWledzhed3gtYHgjTzheI08jUDleI1AjbzheI28jcDlyI3AjcTheI3EjcjlyI3J+OF5CZThlXSVyN1slZyxYT1k4XllaJWlaXTheXV4laV53OF53eC1geCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlOWNUJXI3W08jbzheI28jcDlyI3AjcTheI3EjcjlyI3J+OF4sWDl3ViVnLFhPWTlyWl05cl53OXJ3eC5weCNPOXIjTyNQOl4jUH45cixYOmFQT345cjtoOm9SJXI3WyV4IWIleiN0JWlTTyNvJWkjcCNxJWkjcn4laUN7O1RdJXI3WyV4IWIlaVMlZyxYT1k4XllaJWlaXTheXV4laV53OF53eC1geCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkZxPFZaJXI3WyV6I3QlZyxYT3I6ZHJzPHhzdzpkd3g9W3gjTzpkI08jUD1wI1AjbzpkI28jcD5fI3AjcTpkI3Ejcj5VI3J+OmQ4cj1SUiVyN1sleCFiJWlTTyNvJWkjcCNxJWkjcn4laUZxPWdSJWohZiVyN1sleiN0JWgsWE8jbyVpI3AjcSVpI3J+JWk7aD11VCVyN1tPI286ZCNvI3A+VSNwI3E6ZCNxI3I+VSNyfjpkJVs+X08leCFiJXojdCVpUyVbPmRQJWlTI28jcD5nJVc+bk8leCFiJXojdEZxPnNUJXI3W08jbzdXI28jcD9TI3AjcTdXI3Ejcj9TI3J+N1cwZT9fViV4IWIleiN0JWlTJWcsWE9ZOXJaXTlyXnc5cnd4LnB4I085ciNPI1A6XiNQfjlyMGU/e1glaVMlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1AjbzlyI28jcEBoI3B+OXIwYUBxViV4IWIleiN0JWcsWE9ZOXJaXTlyXnc5cnd4LnB4I085ciNPI1A6XiNQfjlyR3tBa1JmLFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpPHVCWFIhUFIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpR3tCdVZULFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPeiVpentDW3shXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlCZUNjVF9SJXI3W08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHe0RWVCR8LFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpR3tEeVJ4LFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpTWdFZ1UkfSxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCFhRXkhYSNvJWkjcCNxJWkjcn4laTx2RlFSJlUmaiVyN1tPI28laSNwI3ElaSNyfiVpR3tGblYhZVElb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIU8laSFPIVBHVCFQIVElaSFRIVtHeSFbI28laSNwI3ElaSNyfiVpQmVHWVQlcjdbTyFPJWkhTyFQR2khUCNvJWkjcCNxJWkjcn4laUJlR3BSIW4sWCVyN1tPI28laSNwI3ElaSNyfiVpQmNIUV8hZyxWJXI3W08hUSVpIVEhW0d5IVshZyVpIWchaElQIWghbCVpIWwhbUtQIW0jUiVpI1IjU0d5I1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCY0lVWCVyN1tPeyVpe3xJcXx9JWl9IU9JcSFPIVElaSFRIVtKViFbI28laSNwI3ElaSNyfiVpQmNJdlQlcjdbTyFRJWkhUSFbSlYhWyNvJWkjcCNxJWkjcn4laUJjSl5aIWcsViVyN1tPIVElaSFRIVtKViFbIWwlaSFsIW1LUCFtI1IlaSNSI1NKViNTI14laSNeI19LUCNfI28laSNwI3ElaSNyfiVpQmNLV1IhZyxWJXI3W08jbyVpI3AjcSVpI3J+JWlHe0t0ViVPUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hUCVpIVAhUUxaIVEhXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlCZExiVCVRUSVyN1tPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpR3lNVW0hZyxWJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFPJWkhTyFQISBQIVAhUSVpIVEhWyEhayFbIWQlaSFkIWUhI3chZSFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSFxJWkhcSFyISVWIXIheiVpIXoheyEmXyF7I1IlaSNSI1MhIWsjUyNVJWkjVSNWISN3I1YjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jYyVpI2MjZCElViNkI2wlaSNsI20hJl8jbSNvJWkjcCNxJWkjcn4laUJjISBVVCVyN1tPIVElaSFRIVshIGUhWyNvJWkjcCNxJWkjcn4laUJjISBsXyFnLFYlcjdbTyFRJWkhUSFbISBlIVshZyVpIWchaElQIWghbCVpIWwhbUtQIW0jUiVpI1IjUyEgZSNTI1glaSNYI1lJUCNZI14laSNeI19LUCNfI28laSNwI3ElaSNyfiVpQmMhIXJhIWcsViVyN1tPIU8laSFPIVAhIFAhUCFRJWkhUSFbISFrIVshZyVpIWchaElQIWghbCVpIWwhbUtQIW0jUiVpI1IjUyEhayNTI1glaSNYI1lJUCNZI14laSNeI19LUCNfI28laSNwI3ElaSNyfiVpQmMhI3xXJXI3W08hUSVpIVEhUiEkZiFSIVMhJGYhUyNSJWkjUiNTISRmI1MjbyVpI3AjcSVpI3J+JWlCYyEkbVchZyxWJXI3W08hUSVpIVEhUiEkZiFSIVMhJGYhUyNSJWkjUiNTISRmI1MjbyVpI3AjcSVpI3J+JWlCYyElW1YlcjdbTyFRJWkhUSFZISVxIVkjUiVpI1IjUyElcSNTI28laSNwI3ElaSNyfiVpQmMhJXhWIWcsViVyN1tPIVElaSFRIVkhJXEhWSNSJWkjUiNTISVxI1MjbyVpI3AjcSVpI3J+JWlCYyEmZFolcjdbTyFRJWkhUSFbISdWIVshYyVpIWMhaSEnViFpI1IlaSNSI1MhJ1YjUyNUJWkjVCNaISdWI1ojbyVpI3AjcSVpI3J+JWlCYyEnXlohZyxWJXI3W08hUSVpIVEhWyEnViFbIWMlaSFjIWkhJ1YhaSNSJWkjUiNTISdWI1MjVCVpI1QjWiEnViNaI28laSNwI3ElaSNyfiVpR3khKGRhIWcsViVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hTyVpIU8hUCEgUCFQIVElaSFRIVshIWshWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISFrI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlNZyEpfFR5MXMlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWAhKl0hYCNvJWkjcCNxJWkjcn4laTdfISpkUiVZUiVyN1tPI28laSNwI3ElaSNyfiVpR3shK1FSI18sWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlHeyErblZqUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXiVpIV4hXyEsVCFfIWApZCFgIWEpZCFhI28laSNwI3ElaSNyfiVpQmQhLFtUJHpRJXI3W08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHeyEtT1QlWCxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgKWQhYCNvJWkjcCNxJWkjcn4laUd7IS1yVWpSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgKWQhYCFhIS5VIWEjbyVpI3AjcSVpI3J+JWlCZCEuXVQke1ElcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7IS9SVF1RI3VQJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laU1nIS93WiVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyVmJmolUyxYTyFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqSFAhMHNaJXI3WyVmJmolUyxYTyFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqTWchMXtjJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyF0ITBqIXQhdSE2diF1IX0hMGohfSNSJWkjUiNTITBqI1MjVCVpI1QjZiEwaiNmI2chNnYjZyNvITBqI3AjcSVpI3IkZyVpJGd+ITBqQmUhM19dJXI3WyVnLFhPWSxgWVolaVpdLGBdXiVpXnIsYHJzITRXcyNPLGAjTyNQLXAjUCNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYEJlITRfVCVyN1slZyxYT3IlaXJzITRucyNvJWkjcCNxJWkjcn4laUJlITR1UiVyN1slayxYTyNvJWkjcCNxJWkjcn4laUJlITVWXSVyN1slZyxYT1k4XllaJWlaXTheXV4laV53OF53eCE2T3gjTzheI08jUDleI1AjbzheI28jcDlyI3AjcTheI3EjcjlyI3J+OF5CZSE2VlQlcjdbJWcsWE93JWl3eCE2ZngjbyVpI3AjcSVpI3J+JWlCZSE2bVIlcjdbJWgsWE8jbyVpI3AjcSVpI3J+JWlIUCE3UF8lcjdbJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyE4ZWMlb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyE5cHN3JWl3eCE6fHghUSVpIVEhWyEwaiFbIWMlaSFjIXQhMGohdCF1ITxZIXUhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNmITBqI2YjZyE8WSNnI28hMGojcCNxJWkjciRnJWkkZ34hMGpCZSE5d1QlcjdbJXQsWE9yJWlycyE6V3MjbyVpI3AjcSVpI3J+JWlCZSE6XVQlcjdbT3IlaXJzITpscyNvJWkjcCNxJWkjcn4laUJlITpzUiVyN1sleSxYTyNvJWkjcCNxJWkjcn4laUJlITtUVCVyN1slbixYT3claXd4ITtkeCNvJWkjcCNxJWkjcn4laUJlITtpVCVyN1tPdyVpd3ghO3h4I28laSNwI3ElaSNyfiVpQmUhPFBSJXI3WyV3LFhPI28laSNwI3ElaSNyfiVpSFAhPGNfJXI3WyVmJmolUyxYT3IlaXJzITlwc3claXd4ITp8eCFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqTWchPXdnJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyFoITBqIWghaSE8WSFpIXQhMGohdCF1ITZ2IXUhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNVITBqI1UjViE2diNWI1khMGojWSNaITxZI1ojbyEwaiNwI3ElaSNyJGclaSRnfiEwak1nIT91XyVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyVmJmolUyxYT3IlaXJzITNXc3claXd4ITVPeCFRJWkhUSFbITBqIVshYyVpIWMhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNvITBqI3AjcSVpI3IkZyVpJGd+ITBqR3shQVhSIVcsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlNZyFBZ1glcjdbT1kkfVlaJXdaXSR9XV4ld14jbyR9I28jcCFCUyNwI3EkfSNxI3IhQlMjcn4kfSZmIUJjTyVvYCV1cCV4IWIleiN0JWlTJWxXPHUhQnZSIVhSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laUd6IUNkVCR4USVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHeSFDfFAhW0dtJWlTJWxXI28jcCFEUCZZIURbTyVvYCV1cCV4IWIleiN0R3ohRG9UJHdRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laTx1IUVhTyFdN18lb2AldXAleCFiJXojdCVpUyVsV0d5IUV0UiVSLFYlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpXCIsXG4gIHRva2VuaXplcnM6IFtsZWdhY3lQcmludCwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIG5ld2xpbmVzLCBib2R5Q29udGludWVdLFxuICB0b3BSdWxlczoge1wiU2NyaXB0XCI6WzAsM119LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAxODgsIGdldDogdmFsdWUgPT4gc3BlY19pZGVudGlmaWVyW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDYwNzZcbn0pO1xuXG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8vIFRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLy8vIEVhY2ggW25vZGUgdHlwZV0oI3RyZWUuTm9kZVR5cGUpIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aFxuLy8vIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhXG4gICAgLy8vIGBkZXNlcmlhbGl6ZWAgZnVuY3Rpb24uXG4gICAgY29uc3RydWN0b3IoeyBkZXNlcmlhbGl6ZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIHN0cmluZy12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uIGlzXG4gICAgLy8vIHRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAgICBzdGF0aWMgc3RyaW5nKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIgfSk7IH1cbiAgICAvLy8gQ3JlYXRlIGEgbnVtYmVyLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb24gaXNcbiAgICAvLy8ganVzdCBgTnVtYmVyYC5cbiAgICBzdGF0aWMgbnVtYmVyKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IE51bWJlciB9KTsgfVxuICAgIC8vLyBDcmVhdGVzIGEgYm9vbGVhbi12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uXG4gICAgLy8vIHJldHVybnMgdHJ1ZSBmb3IgYW55IGlucHV0LlxuICAgIHN0YXRpYyBmbGFnKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6ICgpID0+IHRydWUgfSk7IH1cbiAgICAvLy8gU3RvcmUgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wIGluIHRoZSBnaXZlbiBvYmplY3QuIFRoaXMgY2FuIGJlXG4gICAgLy8vIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHVwIGEgcHJvcCBvYmplY3QgdG8gcGFzcyB0byB0aGVcbiAgICAvLy8gW2BOb2RlVHlwZWBdKCN0cmVlLk5vZGVUeXBlKSBjb25zdHJ1Y3Rvci4gUmV0dXJucyBpdHMgZmlyc3RcbiAgICAvLy8gYXJndW1lbnQuXG4gICAgc2V0KHByb3BPYmosIHZhbHVlKSB7XG4gICAgICAgIHByb3BPYmpbdGhpcy5pZF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHByb3BPYmo7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI3RyZWUuTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgUGFyc2VyLndpdGhQcm9wc2BdKCNsZXplci5QYXJzZXIud2l0aFByb3BzKSB0byBjb21wdXRlIHByb3BcbiAgICAvLy8gdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCN0cmVlLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYG9wZW5lZEJ5YF0oI3RyZWUuTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKVxuICAgICAgICAgICAgICAgICAgICBzcmNbMF0uc2V0KHByb3BzLCBzcmNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIC8vLyB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVG9wICovKSA+IDA7IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogRXJyb3IgKi8pID4gMDsgfVxuICAgIC8vLyBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICAvLy8gbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIEFub255bW91cyAqLykgPiAwOyB9XG4gICAgLy8vIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIC8vLyBbZ3JvdXBzXSgjdHJlZS5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI3RyZWUuTm9kZVByb3BeZ3JvdXApIG5hbWVzLiBPZnRlbiB1c2VmdWwgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgLy8vIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIC8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBBbm9ueW1vdXMgKi8pO1xuLy8vIEEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbi8vLyBjb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWJlciBhcnJheS4gRWFjaCBwYXJzZXJcbi8vLyBbaGFzXSgjbGV6ZXIuUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuLy8vIGJ1ZmZlcnNdKCN0cmVlLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpXG4vLy8gbm9kZSB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheVxuLy8vIHNsb3RzLlxuY2xhc3MgTm9kZVNldCB7XG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIC8vLyB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIC8vLyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNyZWF0ZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFswXS5zZXQobmV3UHJvcHMsIGFkZFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuLy8vIEEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxuLy8vIHRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbi8vLyBjb252ZW5pZW50IHdheS5cbi8vL1xuLy8vIFN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbi8vLyBub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuLy8vXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xuLy8vIHJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbi8vLyB1c2UgdGhlIGBUcmVlQ3Vyc29yYCBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXMgYSB2aWV3IG9uXG4vLy8gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFyb3VuZFxuLy8vIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZSB7XG4gICAgLy8vIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBZb3UgdXN1YWxseSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAvLy8gW2BUcmVlLmJ1aWxkYF0oI3RyZWUuVHJlZV5idWlsZCkgaW5zdGVhZC5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBcbiAgICAvLy8gVGhlIHRyZWUncyBjaGlsZCBub2Rlcy4gQ2hpbGRyZW4gc21hbGwgZW5vdWdoIHRvIGZpdCBpbiBhXG4gICAgLy8vIGBUcmVlQnVmZmVyIHdpbGwgYmUgcmVwcmVzZW50ZWQgYXMgc3VjaCwgb3RoZXIgY2hpbGRyZW4gY2FuIGJlXG4gICAgLy8vIGZ1cnRoZXIgYFRyZWVgIGluc3RhbmNlcyB3aXRoIHRoZWlyIG93biBpbnRlcm5hbCBzdHJ1Y3R1cmUuXG4gICAgY2hpbGRyZW4sIFxuICAgIC8vLyBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgLy8vIHRoZSBjaGlsZHJlbi5cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgIGxlbmd0aCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLm1hcChjID0+IGMudG9TdHJpbmcoKSkuam9pbigpO1xuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjdHJlZS5UcmVlQ3Vyc29yKSByb290ZWQgYXQgdGhpcyB0cmVlLiBXaGVuXG4gICAgLy8vIGBwb3NgIGlzIGdpdmVuLCB0aGUgY3Vyc29yIGlzIFttb3ZlZF0oI3RyZWUuVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCN0cmVlLlRyZWVDdXJzb3IpIHRoYXQsIHVubGlrZSByZWd1bGFyXG4gICAgLy8vIGN1cnNvcnMsIGRvZXNuJ3Qgc2tpcCBbYW5vbnltb3VzXSgjdHJlZS5Ob2RlVHlwZS5pc0Fub255bW91cylcbiAgICAvLy8gbm9kZXMuXG4gICAgZnVsbEN1cnNvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICAvLy8gdHJlZS5cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3N5bnRheCBub2RlXSgjdHJlZS5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhlIGdpdmVuIG5vZGVcbiAgICAvLy8gd2lsbCBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKTs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMudHlwZSwgYy5mcm9tLCBjLnRvKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjLnR5cGUsIGMuZnJvbSwgYy50byk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUuXG4gICAgYmFsYW5jZShtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSBCYWxhbmNlQnJhbmNoRmFjdG9yID8gdGhpc1xuICAgICAgICAgICAgOiBiYWxhbmNlUmFuZ2UodGhpcy50eXBlLCBOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIG1heEJ1ZmZlckxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0LCB0eXBlID0gTm9kZVR5cGUubm9uZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBhZnRlcikge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgIT0gLTEwMDAwMDAwMCAvKiBOb25lICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gYnVmZmVyW2kgKyAxXSwgZW5kID0gYnVmZmVyW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID49IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmcm9tLCBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLm5vZGUubGVuZ3RoOyB9XG4gICAgbmV4dENoaWxkKGksIGRpciwgYWZ0ZXIsIGZ1bGwgPSBmYWxzZSkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Lm5vZGUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlciAhPSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gJiYgKGRpciA8IDAgPyBzdGFydCA+PSBhZnRlciA6IHN0YXJ0ICsgbmV4dC5sZW5ndGggPD0gYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbmV4dC5maW5kQ2hpbGQoMCwgbmV4dC5idWZmZXIubGVuZ3RoLCBkaXIsIGFmdGVyID09IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA/IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA6IGFmdGVyIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmdWxsIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdWxsIHx8ICFpbm5lci50eXBlLmlzQW5vbnltb3VzID8gaW5uZXIgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdWxsIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCBwb3MpOyB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAtMSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgLTEpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGN1cnNvcigpIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMpOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKS5ub2RlO1xuICAgIH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubm9kZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdOyB9XG4gICAgY2hpbGQoZGlyLCBhZnRlcikge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSB0aGlzLmNvbnRleHQuc3RhcnQpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zKTsgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAtMSk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxufVxuLy8vIEEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuLy8vIGFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmdWxsID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mdWxsID0gZnVsbDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZW50ZXIoZGlyLCBhZnRlcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBhZnRlciwgdGhpcy5mdWxsKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIGFmdGVyID09IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA/IC0xMDAwMDAwMDAgLyogTm9uZSAqLyA6IGFmdGVyIC0gdGhpcy5idWZmZXIuc3RhcnQpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZC4gV2hlbiB0aGlzIHJldHVybnNcbiAgICAvLy8gZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgIGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyKDEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlcigtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyKDEsIHBvcyk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IGVuZHMgYXQgb3IgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlcigtMSwgcG9zKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgIHBhcmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZSh0aGlzLmZ1bGwgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5mdWxsID8gdGhpcy5idWZmZXIucGFyZW50IDogdGhpcy5idWZmZXIucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLywgdGhpcy5mdWxsKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8sIHRoaXMuZnVsbCkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxuICAgIG5leHRTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKDEpOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxuICAgIGF0TGFzdE5vZGUoZGlyKSB7XG4gICAgICAgIGxldCBpbmRleCwgcGFyZW50LCB7IGJ1ZmZlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IGJ1ZmZlci5idWZmZXIuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyLmJ1ZmZlcltpICsgM10gPCB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgaW5kZXgsIHBhcmVudCB9ID0gYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHRoaXMuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyBkaXIsIGUgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQubm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mdWxsIHx8ICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbW92ZShkaXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZW50ZXIoZGlyLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHksIGl0cyBuZXh0IHNpYmxpbmcgb3IgdGhlIG5leHQgc2libGluZyBvZlxuICAgIC8vLyB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgIG5leHQoKSB7IHJldHVybiB0aGlzLm1vdmUoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpc3QgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldigpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICAvLy8gYHNpZGVgIGlzIC0xLCBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgZW5kIGF0IGBwb3NgLiBJZiBpdCBpcyAxLFxuICAgIC8vLyBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyAhdGhpcy5jaGlsZEJlZm9yZShwb3MpIDogIXRoaXMuY2hpbGRBZnRlcihwb3MpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbdHJlZV0oI3RyZWUuVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gICAgLy8vIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICAvLy8gYnVmZmVyXSgjdHJlZS5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiAhY2gudHlwZS5pc0Fub255bW91cyB8fCBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG5jb25zdCBCYWxhbmNlQnJhbmNoRmFjdG9yID0gODtcbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgdG9wSUQgPSAwLCBtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoLCByZXVzZWQgPSBbXSwgbWluUmVwZWF0VHlwZSA9IG5vZGVTZXQudHlwZXMubGVuZ3RoIH0gPSBkYXRhO1xuICAgIGxldCBjdXJzb3IgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcikgPyBuZXcgRmxhdEJ1ZmZlckN1cnNvcihidWZmZXIsIGJ1ZmZlci5sZW5ndGgpIDogYnVmZmVyO1xuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGlkID09IGluUmVwZWF0KSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgKHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7IC8vIFJldXNlZCBub2RlXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHJldXNlZFtpZF0pO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCwgaW5SZXBlYXQpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCwgaW5SZXBlYXQgPCAwID8gTm9kZVR5cGUubm9uZSA6IHR5cGVzW2luUmVwZWF0XSk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoID4gQmFsYW5jZUJyYW5jaEZhY3RvcilcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgbWF4QnVmZmVyTGVuZ3RoLCBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplLCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCwgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGlkID09IGluUmVwZWF0KVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4LCBpblJlcGVhdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkIDwgbWluUmVwZWF0VHlwZSkgeyAvLyBEb24ndCBjb3B5IHJlcGVhdCBub2RlcyBpbnRvIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1t0b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShvdXRlclR5cGUsIGlubmVyVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIHN0YXJ0LCBtYXhCdWZmZXJMZW5ndGgsIGxlbmd0aCkge1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgaWYgKGxlbmd0aCA8PSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnNbaV0gLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBtYXhDaGlsZCA9IE1hdGgubWF4KG1heEJ1ZmZlckxlbmd0aCwgTWF0aC5jZWlsKGxlbmd0aCAqIDEuNSAvIEJhbGFuY2VCcmFuY2hGYWN0b3IpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRFbmQgPSBwb3NpdGlvbnNbaV0gKyBjaGlsZHJlbltpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbmQgLSBncm91cFN0YXJ0ID4gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTtcbiAgICAgICAgICAgICAgICBpZiAob25seSBpbnN0YW5jZW9mIFRyZWUgJiYgb25seS50eXBlID09IGlubmVyVHlwZSAmJiBvbmx5Lmxlbmd0aCA+IG1heENoaWxkIDw8IDEpIHsgLy8gVG9vIGJpZywgY29sbGFwc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvbmx5LmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2gob25seS5jaGlsZHJlbltqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKG9ubHkucG9zaXRpb25zW2pdICsgZ3JvdXBTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKG9ubHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gYmFsYW5jZVJhbmdlKGlubmVyVHlwZSwgaW5uZXJUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIG1heEJ1ZmZlckxlbmd0aCwgcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJUeXBlICE9IE5vZGVUeXBlLm5vbmUgJiYgIWNvbnRhaW5zVHlwZShpbm5lci5jaGlsZHJlbiwgaW5uZXJUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBpbm5lci5jaGlsZHJlbiwgaW5uZXIucG9zaXRpb25zLCBpbm5lci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChpbm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmVlKG91dGVyVHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG5mdW5jdGlvbiBjb250YWluc1R5cGUobm9kZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBlbHQgb2Ygbm9kZXMpXG4gICAgICAgIGlmIChlbHQudHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjbGV6ZXIuUGFyc2VPcHRpb25zLmZyYWdtZW50cykgdG8gdHJhY2sgcGFydHMgb2Ygb2xkXG4vLy8gdHJlZXMgdGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXNcbi8vLyB1c2VkIHRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkXG4vLy8gaW4gbmV3IHBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbi8vLyBbYGFwcGx5Q2hhbmdlc2BdKCN0cmVlLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0byB1cGRhdGVcbi8vLyBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBTdGFydCAqLykgPiAwOyB9XG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBFbmQgKi8pID4gMDsgfVxuICAgIC8vLyBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgLy8vIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICAvLy8gYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgbGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0krK10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIChjSSA+IDAgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAobmV4dEMgPyAyIC8qIEVuZCAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgLy8vIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIC8vLyB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgLy8vIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgdG9rZW4gYXQgaXRzXG4gICAgLy8vIGVuZCBpcyBub3QgaW5jbHVkZWQgaW4gW2BzYWZlVG9gXSgjdHJlZS5UcmVlRnJhZ21lbnQuc2FmZVRvKS5cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgcGFydGlhbCA/IDIgLyogRW5kICovIDogMCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQ3JlYXRlcyBhbiBgSW5wdXRgIHRoYXQgaXMgYmFja2VkIGJ5IGEgc2luZ2xlLCBmbGF0IHN0cmluZy5cbmZ1bmN0aW9uIHN0cmluZ0lucHV0KGlucHV0KSB7IHJldHVybiBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpOyB9XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0KHBvcykge1xuICAgICAgICByZXR1cm4gcG9zIDwgMCB8fCBwb3MgPj0gdGhpcy5sZW5ndGggPyAtMSA6IHRoaXMuc3RyaW5nLmNoYXJDb2RlQXQocG9zKTtcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihcIlxcblwiLCBwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBlbmQgPCAwID8gdGhpcy5sZW5ndGggOiBNYXRoLm1pbihlbmQsIHRoaXMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpOyB9XG4gICAgY2xpcChhdCkgeyByZXR1cm4gbmV3IFN0cmluZ0lucHV0KHRoaXMuc3RyaW5nLCBhdCk7IH1cbn1cblxuZXhwb3J0cy5EZWZhdWx0QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbmV4cG9ydHMuTm9kZVByb3AgPSBOb2RlUHJvcDtcbmV4cG9ydHMuTm9kZVNldCA9IE5vZGVTZXQ7XG5leHBvcnRzLk5vZGVUeXBlID0gTm9kZVR5cGU7XG5leHBvcnRzLlRyZWUgPSBUcmVlO1xuZXhwb3J0cy5UcmVlQnVmZmVyID0gVHJlZUJ1ZmZlcjtcbmV4cG9ydHMuVHJlZUN1cnNvciA9IFRyZWVDdXJzb3I7XG5leHBvcnRzLlRyZWVGcmFnbWVudCA9IFRyZWVGcmFnbWVudDtcbmV4cG9ydHMuc3RyaW5nSW5wdXQgPSBzdHJpbmdJbnB1dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyZWUuY2pzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXJUcmVlID0gcmVxdWlyZSgnbGV6ZXItdHJlZScpO1xuXG4vLy8gQSBwYXJzZSBzdGFjay4gVGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcGFyc2VyIHRvIHRyYWNrXG4vLy8gcGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG4vLy8gdGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbi8vLyBhYm91dCB0aGUgcGFyc2Ugc3RhdGUuXG5jbGFzcyBTdGFjayB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBBIGdyb3VwIG9mIHZhbHVlcyB0aGF0IHRoZSBzdGFjayB3aWxsIHNoYXJlIHdpdGggYWxsXG4gICAgLy8vIHNwbGl0IGluc3RhbmNlc1xuICAgIC8vL0BpbnRlcm5hbFxuICAgIGN4LCBcbiAgICAvLy8gSG9sZHMgc3RhdGUsIHBvcywgdmFsdWUgc3RhY2sgcG9zICgxNSBiaXRzIGFycmF5IGluZGV4LCAxNSBiaXRzXG4gICAgLy8vIGJ1ZmZlciBpbmRleCkgdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlIHRvcCBzdGF0ZVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5jeCA9IGN4O1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGljIHN0YXJ0KGN4LCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKGN4LCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5jeDtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIEVyciAqLykgeyAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBFcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogR290b0ZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3MsIG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMuY3g7XG4gICAgICAgICAgICBpZiAobmV4dEVuZCA+IHRoaXMucG9zIHx8IG5leHQgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTa2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLmN4LnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXh0RW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IG5vZGUgaW50byB0aGUgYnVmZmVyLiBUaGlzIG1heSBiZSBhIHJldXNlZCBub2RlIG9yXG4gICAgLy8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIGEgbmVzdGVkIHBhcnNlci5cbiAgICAvLy8gQGludGVybmFsXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmN4LnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuY3gucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jeC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplIDwgMCBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMuY3gsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5jeC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kKTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucG9zLCBuZXh0RW5kLCBpc05vZGUgPyA4IDogNCk7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICB0aGlzLnNjb3JlIC09IDIwMCAvKiBUb2tlbiAqLztcbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIC8vLyBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICAvLy8gZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICAvLy8gZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLmN4LnBhcnNlci5zdGF0ZVNsb3Qoc2ltLnRvcCwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLmN4LnBhcnNlci5oYXNBY3Rpb24oc2ltLnRvcCwgdGVybSk7XG4gICAgICAgICAgICBpZiAoKGFjdGlvbiAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgc2ltLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBGaW5kIHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcnVsZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwYXJzZWQuXG4gICAgZ2V0IHJ1bGVTdGFydCgpIHtcbiAgICAgICAgZm9yIChsZXQgc3RhdGUgPSB0aGlzLnN0YXRlLCBiYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7Oykge1xuICAgICAgICAgICAgbGV0IGZvcmNlID0gdGhpcy5jeC5wYXJzZXIuc3RhdGVTbG90KHN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgICAgICBpZiAoIShmb3JjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgYmFzZSAtPSAzICogKGZvcmNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8pO1xuICAgICAgICAgICAgaWYgKChmb3JjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLykgPCB0aGlzLmN4LnBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrW2Jhc2UgKyAxXTtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gRmluZCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYW4gaW5zdGFuY2Ugb2YgYW55IG9mIHRoZSBnaXZlbiB0ZXJtXG4gICAgLy8vIHR5cGVzLCBvciByZXR1cm4gYG51bGxgIHdoZW4gbm9uZSBvZiB0aGVtIGFyZSBmb3VuZC5cbiAgICAvLy9cbiAgICAvLy8gKipOb3RlOioqIHRoaXMgaXMgb25seSByZWxpYWJsZSB3aGVuIHRoZXJlIGlzIGF0IGxlYXN0IHNvbWVcbiAgICAvLy8gc3RhdGUgdGhhdCB1bmFtYmlndW91c2x5IG1hdGNoZXMgdGhlIGdpdmVuIHJ1bGUgb24gdGhlIHN0YWNrLlxuICAgIC8vLyBJLmUuIGlmIHlvdSBoYXZlIGEgZ3JhbW1hciBsaWtlIHRoaXMsIHdoZXJlIHRoZSBkaWZmZXJlbmNlXG4gICAgLy8vIGJldHdlZW4gYGFgIGFuZCBgYmAgaXMgb25seSBhcHBhcmVudCBhdCB0aGUgdGhpcmQgdG9rZW46XG4gICAgLy8vXG4gICAgLy8vICAgICBhIHsgYiB8IGMgfVxuICAgIC8vLyAgICAgYiB7IFwieFwiIFwieVwiIFwieFwiIH1cbiAgICAvLy8gICAgIGMgeyBcInhcIiBcInlcIiBcInpcIiB9XG4gICAgLy8vXG4gICAgLy8vIFRoZW4gYSBwYXJzZSBzdGF0ZSBhZnRlciBgXCJ4XCJgIHdpbGwgbm90IHJlbGlhYmx5IHRlbGwgeW91IHRoYXRcbiAgICAvLy8gYGJgIGlzIG9uIHRoZSBzdGFjay4gWW91IF9jYW5fIHBhc3MgYFtiLCBjXWAgdG8gcmVsaWFibHkgY2hlY2tcbiAgICAvLy8gZm9yIGVpdGhlciBvZiB0aG9zZSB0d28gcnVsZXMgKGFzc3VtaW5nIHRoYXQgYGFgIGlzbid0IHBhcnQgb2ZcbiAgICAvLy8gc29tZSBydWxlIHRoYXQgaW5jbHVkZXMgb3RoZXIgdGhpbmdzIHN0YXJ0aW5nIHdpdGggYFwieFwiYCkuXG4gICAgLy8vXG4gICAgLy8vIFdoZW4gYGJlZm9yZWAgaXMgZ2l2ZW4sIHRoaXMga2VlcHMgc2Nhbm5pbmcgdXAgdGhlIHN0YWNrIHVudGlsXG4gICAgLy8vIGl0IGZpbmRzIGEgbWF0Y2ggdGhhdCBzdGFydHMgYmVmb3JlIHRoYXQgcG9zaXRpb24uXG4gICAgc3RhcnRPZih0eXBlcywgYmVmb3JlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGUsIGZyYW1lID0gdGhpcy5zdGFjay5sZW5ndGgsIHsgcGFyc2VyIH0gPSB0aGlzLmN4O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCA1IC8qIEZvcmNlZFJlZHVjZSAqLyk7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSBmb3JjZSA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gZm9yY2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5kZXhPZih0ZXJtKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBmcmFtZSAtICgzICogKGZvcmNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8pKSwgcG9zID0gdGhpcy5zdGFja1tiYXNlICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBudWxsIHx8IGJlZm9yZSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFtZSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICBmcmFtZSAtPSAzO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1tmcmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFtZSAtPSAzICogKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW2ZyYW1lIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gICAgLy8gaW5zZXJ0cyBzb21lIG1pc3NpbmcgdG9rZW4gb3IgcnVsZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBNYXhJbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMuY3gucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogTWF4TmV4dCAqLyB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBuZXh0U3RhdGVzLmZpbHRlcihzID0+IHMgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLmN4LnBhcnNlci5oYXNBY3Rpb24ocywgbmV4dCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIERhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGJlc3QubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdC5pbmRleE9mKG5leHRTdGF0ZXNbaV0pIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldKTtcbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZXh0U3RhdGVzW2ldID09IHRoaXMuc3RhdGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHN0YWNrLnBvcywgc3RhY2sucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShuZXh0U3RhdGVzW2ldLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogVG9rZW4gKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgcmVkdWNlID0gdGhpcy5jeC5wYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuY3gucGFyc2VyLnZhbGlkQWN0aW9uKHRoaXMuc3RhdGUsIHJlZHVjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogRXJyICovLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVkdWNlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkdWNlKHJlZHVjZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VBbGwoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5jeC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSAmJiB0aGlzLmZvcmNlUmVkdWNlKCkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICAvLy8gc29tZWhvdykuIEBpbnRlcm5hbFxuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLmN4O1xuICAgICAgICByZXR1cm4gcGFyc2VyLmRhdGFbcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBFbmQgKi8gJiZcbiAgICAgICAgICAgICFwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8vLyBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgLy8vIHdoZW4gdGhpcy5zdGFjay5sZW5ndGggPT0gMyAoc3RhdGUgaXMgZGlyZWN0bHkgYmVsb3cgdGhlIHRvcFxuICAgIC8vLyBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgIGdldCBwYXJzZXIoKSB7IHJldHVybiB0aGlzLmN4LnBhcnNlcjsgfVxuICAgIC8vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgLy8vIHRoZSB0ZXJtcyBmaWxlKSBpcyBlbmFibGVkLlxuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5jeC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG59XG52YXIgUmVjb3ZlcjtcbihmdW5jdGlvbiAoUmVjb3Zlcikge1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIlRva2VuXCJdID0gMjAwXSA9IFwiVG9rZW5cIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2spIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnRvcCA9IHN0YWNrLnN0YXRlO1xuICAgICAgICB0aGlzLnJlc3QgPSBzdGFjay5zdGFjaztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLnJlc3QubGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBSZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdCA9PSB0aGlzLnN0YWNrLnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzdCA9IHRoaXMucmVzdC5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN0LnB1c2godGhpcy50b3AsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0IC09IChkZXB0aCAtIDEpICogMztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ290byA9IHRoaXMuc3RhY2suY3gucGFyc2VyLmdldEdvdG8odGhpcy5yZXN0W3RoaXMub2Zmc2V0IC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnRvcCA9IGdvdG87XG4gICAgfVxufVxuLy8gVGhpcyBpcyBnaXZlbiB0byBgVHJlZS5idWlsZGAgdG8gYnVpbGQgYSBidWZmZXIsIGFuZCBlbmNhcHN1bGF0ZXNcbi8vIHRoZSBwYXJlbnQtc3RhY2std2Fsa2luZyBuZWNlc3NhcnkgdG8gcmVhZCB0aGUgbm9kZXMuXG5jbGFzcyBTdGFja0J1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2ssIHBvcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHN0YWNrLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgsIHN0YWNrLmJ1ZmZlci5sZW5ndGgpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG4vLy8gVG9rZW5pemVycyB3cml0ZSB0aGUgdG9rZW5zIHRoZXkgcmVhZCBpbnRvIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB0b2tlbi4gVGhpcyBpcyBzZXQgYnkgdGhlIHBhcnNlciwgYW5kIHNob3VsZCBub3RcbiAgICAgICAgLy8vIGJlIG11dGF0ZWQgYnkgdGhlIHRva2VuaXplci5cbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICAvLy8gVGhpcyBzdGFydHMgYXQgLTEsIGFuZCBzaG91bGQgYmUgdXBkYXRlZCB0byBhIHRlcm0gaWQgd2hlbiBhXG4gICAgICAgIC8vLyBtYXRjaGluZyB0b2tlbiBpcyBmb3VuZC5cbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICAvLy8gV2hlbiBzZXR0aW5nIGAudmFsdWVgLCB5b3Ugc2hvdWxkIGFsc28gc2V0IGAuZW5kYCB0byB0aGUgZW5kXG4gICAgICAgIC8vLyBwb3NpdGlvbiBvZiB0aGUgdG9rZW4uIChZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZSB0aGUgYGFjY2VwdGBcbiAgICAgICAgLy8vIG1ldGhvZC4pXG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgfVxuICAgIC8vLyBBY2NlcHQgYSB0b2tlbiwgc2V0dGluZyBgdmFsdWVgIGFuZCBgZW5kYCB0byB0aGUgZ2l2ZW4gdmFsdWVzLlxuICAgIGFjY2VwdCh2YWx1ZSwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxufVxuLy8vIEBpbnRlcm5hbFxuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgdG9rZW4sIHN0YWNrKSB7IHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCB0b2tlbiwgc3RhY2ssIHRoaXMuaWQpOyB9XG59XG5Ub2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8vLyBFeHBvcnRzIHRoYXQgYXJlIHVzZWQgZm9yIGBAZXh0ZXJuYWwgdG9rZW5zYCBpbiB0aGUgZ3JhbW1hciBzaG91bGRcbi8vLyBleHBvcnQgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdG9rZW5pemVyLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGZ1bmN0aW9uIHRoYXQsXG4gICAgLy8vIGdpdmVuIGFuIGlucHV0IHN0cmVhbSBhbmQgYSB0b2tlbiBvYmplY3QsXG4gICAgLy8vIFtmaWxsc10oI2xlemVyLlRva2VuLmFjY2VwdCkgdGhlIHRva2VuIG9iamVjdCBpZiBpdCByZWNvZ25pemVzIGFcbiAgICAvLy8gdG9rZW4uIGB0b2tlbi5zdGFydGAgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvXG4gICAgLy8vIHNjYW4gZnJvbS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuY29udGV4dHVhbCA9ICEhb3B0aW9ucy5jb250ZXh0dWFsO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gISFvcHRpb25zLmZhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4dGVuZCA9ICEhb3B0aW9ucy5leHRlbmQ7XG4gICAgfVxufVxuLy8gVG9rZW5pemVyIGRhdGEgaXMgc3RvcmVkIGEgYmlnIHVpbnQxNiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaFxuLy8gc3RhdGU6XG4vL1xuLy8gIC0gQSBncm91cCBiaXRtYXNrLCBpbmRpY2F0aW5nIHdoYXQgdG9rZW4gZ3JvdXBzIGFyZSByZWFjaGFibGUgZnJvbVxuLy8gICAgdGhpcyBzdGF0ZSwgc28gdGhhdCBwYXRocyB0aGF0IGNhbiBvbmx5IGxlYWQgdG8gdG9rZW5zIG5vdCBpblxuLy8gICAgYW55IG9mIHRoZSBjdXJyZW50IGdyb3VwcyBjYW4gYmUgY3V0IG9mZiBlYXJseS5cbi8vXG4vLyAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3RhdGUncyBzZXF1ZW5jZSBvZiBhY2NlcHRpbmdcbi8vICAgIHRva2Vuc1xuLy9cbi8vICAtIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBzdGF0ZVxuLy9cbi8vICAtIFRoZSBhY2NlcHRpbmcgdG9rZW5zLCBhcyAodG9rZW4gaWQsIGdyb3VwIG1hc2spIHBhaXJzXG4vL1xuLy8gIC0gVGhlIG91dGdvaW5nIGVkZ2VzLCBhcyAoc3RhcnQgY2hhcmFjdGVyLCBlbmQgY2hhcmFjdGVyLCBzdGF0ZVxuLy8gICAgaW5kZXgpIHRyaXBsZXMsIHdpdGggZW5kIGNoYXJhY3RlciBiZWluZyBleGNsdXNpdmVcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGludGVycHJldHMgdGhhdCBkYXRhLCBydW5uaW5nIHRocm91Z2ggYSBzdHJlYW0gYXNcbi8vIGxvbmcgYXMgbmV3IHN0YXRlcyB3aXRoIHRoZSBhIG1hdGNoaW5nIGdyb3VwIG1hc2sgY2FuIGJlIHJlYWNoZWQsXG4vLyBhbmQgdXBkYXRpbmcgYHRva2VuYCB3aGVuIGl0IG1hdGNoZXMgYSB0b2tlbi5cbmZ1bmN0aW9uIHJlYWRUb2tlbihkYXRhLCBpbnB1dCwgdG9rZW4sIHN0YWNrLCBncm91cCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIGRpYWxlY3QgPSBzdGFjay5jeC5wYXJzZXIuZGlhbGVjdDtcbiAgICBzY2FuOiBmb3IgKGxldCBwb3MgPSB0b2tlbi5zdGFydDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udmFsdWUgPT0gLTEgfHwgdG9rZW4udmFsdWUgPT0gdGVybSB8fCBzdGFjay5jeC5wYXJzZXIub3ZlcnJpZGVzKHRlcm0sIHRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uYWNjZXB0KHRlcm0sIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5nZXQocG9zKyspO1xuICAgICAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHN0YXRlJ3MgZWRnZXNcbiAgICAgICAgZm9yIChsZXQgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTsgbG93IDwgaGlnaDspIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFjY0VuZCArIG1pZCArIChtaWQgPDwgMSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRhdGFbaW5kZXhdLCB0byA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSB0bylcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRklYTUUgZmluZCBzb21lIHdheSB0byByZWR1Y2UgcmVjb3Zlcnkgd29yayBkb25lIHdoZW4gdGhlIGlucHV0XG4vLyBkb2Vzbid0IG1hdGNoIHRoZSBncmFtbWFyIGF0IGFsbC5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xuZnVuY3Rpb24gY3V0QXQodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUuY3Vyc29yKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8PSBwb3MgOiBjdXJzb3IuZnJvbSA+PSBwb3MpICYmICFjdXJzb3IudHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyBjdXJzb3IudG8gLSAxIDogY3Vyc29yLmZyb20gKyAxO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gcG9zICYmIHN0YXJ0ICsgbmV4dC5sZW5ndGggPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgPT0gcG9zICYmIHN0YXJ0ID49IHRoaXMuc2FmZUZyb20gPyBuZXh0IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgbGV6ZXJUcmVlLlRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IHBvcykgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2FjaGVkVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICB9XG4gICAgY2xlYXIoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgIH1cbn1cbmNvbnN0IGR1bW15VG9rZW4gPSBuZXcgVG9rZW47XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBkdW1teVRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrLCBpbnB1dCkge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2suY3gsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2ssIGlucHV0KTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIEVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbWFpbiA9IGR1bW15VG9rZW47XG4gICAgICAgICAgICBtYWluLnN0YXJ0ID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFpbi5hY2NlcHQoc3RhY2suY3gucGFyc2VyLmVvZlRlcm0sIHN0YWNrLnBvcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWFpbi5hY2NlcHQoMCAvKiBFcnIgKi8sIHN0YWNrLnBvcyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2ssIGlucHV0KSB7XG4gICAgICAgIHRva2VuLmNsZWFyKHN0YWNrLnBvcyk7XG4gICAgICAgIHRva2VuaXplci50b2tlbihpbnB1dCwgdG9rZW4sIHN0YWNrKTtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2suY3g7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKGlucHV0LnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLmN4LnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXh0ZW5kZWQgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YWNrLnBvcyA9PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuLmFjY2VwdChzdGFjay5jeC5wYXJzZXIuZW9mVGVybSwgc3RhY2sucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLmFjY2VwdCgwIC8qIEVyciAqLywgc3RhY2sucG9zICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLmN4LCB7IGRhdGEgfSA9IHBhcnNlcjtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZXIuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFNraXAgKi8gOiAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxudmFyIFJlYztcbihmdW5jdGlvbiAoUmVjKSB7XG4gICAgUmVjW1JlY1tcIkRpc3RhbmNlXCJdID0gNV0gPSBcIkRpc3RhbmNlXCI7XG4gICAgUmVjW1JlY1tcIk1heFJlbWFpbmluZ1BlclN0ZXBcIl0gPSAzXSA9IFwiTWF4UmVtYWluaW5nUGVyU3RlcFwiO1xuICAgIFJlY1tSZWNbXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiXSA9IDIwMF0gPSBcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCI7XG4gICAgUmVjW1JlY1tcIkZvcmNlUmVkdWNlTGltaXRcIl0gPSAxMF0gPSBcIkZvcmNlUmVkdWNlTGltaXRcIjtcbn0pKFJlYyB8fCAoUmVjID0ge30pKTtcbi8vLyBBIHBhcnNlIGNvbnRleHQgY2FuIGJlIHVzZWQgZm9yIHN0ZXAtYnktc3RlcCBwYXJzaW5nLiBBZnRlclxuLy8vIGNyZWF0aW5nIGl0LCB5b3UgcmVwZWF0ZWRseSBjYWxsIGAuYWR2YW5jZSgpYCB1bnRpbCBpdCByZXR1cm5zIGFcbi8vLyB0cmVlIHRvIGluZGljYXRlIGl0IGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhcnNlLlxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuc3RhcnRQb3MgPSBzdGFydFBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIHRvIHdoaWNoIHRoZSBwYXJzZSBoYXMgYWR2YW5jZWQuXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gMDtcbiAgICAgICAgdGhpcy5uZXh0U3RhY2tJRCA9IDB4MjY1NDtcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm5lc3RFbmQgPSAwO1xuICAgICAgICB0aGlzLm5lc3RXcmFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBuZXcgVG9rZW5DYWNoZShwYXJzZXIpO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtTdGFjay5zdGFydCh0aGlzLCBwYXJzZXIudG9wWzBdLCB0aGlzLnN0YXJ0UG9zKV07XG4gICAgICAgIGxldCBmcmFnbWVudHMgPSBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cyAmJiBmcmFnbWVudHMubGVuZ3RoID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cykgOiBudWxsO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVzdGVkKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5uZXN0ZWQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLm5lc3RlZC5wb3M7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQodGhpcy5zdGFja3NbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICBsZXQgbWF5YmVOZXN0O1xuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCBuZXN0O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXN0ID0gdGhpcy5jaGVja05lc3Qoc3RhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF5YmVOZXN0IHx8IG1heWJlTmVzdC5zdGFjay5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gbmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG5ld1N0YWNrcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2sgPSB0aGlzLnRva2Vucy5tYWluVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVOZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmVzdGVkKG1heWJlTmVzdCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDIwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gMjAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSBuZXdTdGFja3NbMF0ucG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0ucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IGlucHV0LCBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBsZXplclRyZWUuVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgbGV6ZXJUcmVlLlRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2ssIGlucHV0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsb2NhbFN0YWNrLmFwcGx5KGFjdGlvbiwgdGVybSwgZW5kKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQobG9jYWxTdGFjaykgKyBgICh2aWEgJHsoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXN0ID0gdGhpcy5jaGVja05lc3Qoc3RhY2spO1xuICAgICAgICAgICAgaWYgKG5lc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG1heWJlTmVzdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIEZvcmNlUmVkdWNlTGltaXQgKi87IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmb3JjZUJhc2UgKyB0aGlzLnN0YWNrSUQoZm9yY2UpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoZm9yY2UsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0Lmxlbmd0aCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICAgICAgaWYgKG1heWJlTmVzdClcbiAgICAgICAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5zdGFja3MpXG4gICAgICAgICAgICAgICAgaWYgKHMuc2NvcmUgPiBtYXliZU5lc3Quc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVOZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZU5lc3QpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmVzdGVkKG1heWJlTmVzdCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3JjZUZpbmlzaCgpIHtcbiAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zdGFja3NbMF0uc3BsaXQoKTtcbiAgICAgICAgaWYgKHRoaXMubmVzdGVkKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQoc3RhY2ssIHRoaXMubmVzdGVkLmZvcmNlRmluaXNoKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShzdGFjay5mb3JjZUFsbCgpKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaywgcG9zID0gc3RhY2sucG9zKSB7XG4gICAgICAgIHJldHVybiBsZXplclRyZWUuVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRQb3MsXG4gICAgICAgICAgICBsZW5ndGg6IHBvcyAtIHRoaXMuc3RhcnRQb3MsXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBjaGVja05lc3Qoc3RhY2spIHtcbiAgICAgICAgbGV0IGluZm8gPSB0aGlzLnBhcnNlci5maW5kTmVzdGVkKHN0YWNrLnN0YXRlKTtcbiAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzcGVjID0gaW5mby52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHNwZWMgPSBzcGVjKHRoaXMuaW5wdXQsIHN0YWNrKTtcbiAgICAgICAgcmV0dXJuIHNwZWMgPyB7IHN0YWNrLCBpbmZvLCBzcGVjIH0gOiBudWxsO1xuICAgIH1cbiAgICBzdGFydE5lc3RlZChuZXN0KSB7XG4gICAgICAgIGxldCB7IHN0YWNrLCBpbmZvLCBzcGVjIH0gPSBuZXN0O1xuICAgICAgICB0aGlzLnN0YWNrcyA9IFtzdGFja107XG4gICAgICAgIHRoaXMubmVzdEVuZCA9IHRoaXMuc2NhbkZvck5lc3RFbmQoc3RhY2ssIGluZm8uZW5kLCBzcGVjLmZpbHRlckVuZCk7XG4gICAgICAgIHRoaXMubmVzdFdyYXAgPSB0eXBlb2Ygc3BlYy53cmFwVHlwZSA9PSBcIm51bWJlclwiID8gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tzcGVjLndyYXBUeXBlXSA6IHNwZWMud3JhcFR5cGUgfHwgbnVsbDtcbiAgICAgICAgaWYgKHNwZWMuc3RhcnRQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSBzcGVjLnN0YXJ0UGFyc2UodGhpcy5pbnB1dC5jbGlwKHRoaXMubmVzdEVuZCksIHN0YWNrLnBvcywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTmVzdGVkKHN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuRm9yTmVzdEVuZChzdGFjaywgZW5kVG9rZW4sIGZpbHRlcikge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzdGFjay5wb3M7IHBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgICAgZHVtbXlUb2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIGR1bW15VG9rZW4udmFsdWUgPSAtMTtcbiAgICAgICAgICAgIGVuZFRva2VuLnRva2VuKHRoaXMuaW5wdXQsIGR1bW15VG9rZW4sIHN0YWNrKTtcbiAgICAgICAgICAgIGlmIChkdW1teVRva2VuLnZhbHVlID4gLTEgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHRoaXMuaW5wdXQucmVhZChwb3MsIGR1bW15VG9rZW4uZW5kKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5pc2hOZXN0ZWQoc3RhY2ssIHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMubmVzdFdyYXApXG4gICAgICAgICAgICB0cmVlID0gbmV3IGxlemVyVHJlZS5UcmVlKHRoaXMubmVzdFdyYXAsIHRyZWUgPyBbdHJlZV0gOiBbXSwgdHJlZSA/IFswXSA6IFtdLCB0aGlzLm5lc3RFbmQgLSBzdGFjay5wb3MpO1xuICAgICAgICBlbHNlIGlmICghdHJlZSlcbiAgICAgICAgICAgIHRyZWUgPSBuZXcgbGV6ZXJUcmVlLlRyZWUobGV6ZXJUcmVlLk5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdGhpcy5uZXN0RW5kIC0gc3RhY2sucG9zKTtcbiAgICAgICAgbGV0IGluZm8gPSB0aGlzLnBhcnNlci5maW5kTmVzdGVkKHN0YWNrLnN0YXRlKTtcbiAgICAgICAgc3RhY2sudXNlTm9kZSh0cmVlLCB0aGlzLnBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBpbmZvLnBsYWNlaG9sZGVyLCB0cnVlKSk7XG4gICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSB1bm5lc3QpYCk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuLy8vIEEgcGFyc2VyIGhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkXG4vLy8gYnkgYGxlemVyLWdlbmVyYXRvcmAuXG5jbGFzcyBQYXJzZXIge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBsZXplclRyZWUuRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5leHRTdGF0ZUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuY2FjaGVkRGlhbGVjdCA9IG51bGw7XG4gICAgICAgIGlmIChzcGVjLnZlcnNpb24gIT0gMTMgLyogVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxMyAvKiBWZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIGxldCBub2RlTmFtZXMgPSBzcGVjLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgICAgIHRoaXMubWluUmVwZWF0VGVybSA9IG5vZGVOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5yZXBlYXROb2RlQ291bnQ7IGkrKylcbiAgICAgICAgICAgIG5vZGVOYW1lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9wU3BlYy5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcHJvcFNwZWNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChuZXh0LCBwcm9wLCBwcm9wU3BlY1tpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BTcGVjW2kgKyAtbmV4dF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLW5leHQ7IGogPiAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChwcm9wU3BlY1tpKytdLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkoc3BlYy5zcGVjaWFsaXplZCA/IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnNwZWNpYWxpemVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0udGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVyc1tpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0uZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5ldyBsZXplclRyZWUuTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBsZXplclRyZWUuTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLm5lc3RlZCA9IChzcGVjLm5lc3RlZCB8fCBbXSkubWFwKChbbmFtZSwgdmFsdWUsIGVuZFRva2VuLCBwbGFjZWhvbGRlcl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlLCBlbmQ6IG5ldyBUb2tlbkdyb3VwKGRlY29kZUFycmF5KGVuZFRva2VuKSwgMCksIHBsYWNlaG9sZGVyIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5zdGF0ZXMubGVuZ3RoIC8gNiAvKiBTaXplICovOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5uZXh0U3RhdGVDYWNoZVtpXSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIC8vLyBQYXJzZSBhIGdpdmVuIHN0cmluZyBvciBzdHJlYW0uXG4gICAgcGFyc2UoaW5wdXQsIHN0YXJ0UG9zID0gMCwgY29udGV4dCA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbGV6ZXJUcmVlLnN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgbGV0IGN4ID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBzdGFydFBvcywgY29udGV4dCk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gY3guYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFN0YXJ0IGFuIGluY3JlbWVudGFsIHBhcnNlLlxuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIHN0YXJ0UG9zID0gMCwgY29udGV4dCA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbGV6ZXJUcmVlLnN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgc3RhcnRQb3MsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmROZXN0ZWQoc3RhdGUpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogRmxhZ3MgKi8pO1xuICAgICAgICByZXR1cm4gZmxhZ3MgJiA0IC8qIFN0YXJ0TmVzdCAqLyA/IHRoaXMubmVzdGVkW2ZsYWdzID4+IDEwIC8qIE5lc3RTaGlmdCAqL10gOiBudWxsO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdmFsaWRBY3Rpb24oc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uID09IHRoaXMuc3RhdGVTbG90KHN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBwYWlyKHRoaXMuZGF0YSwgaSArIDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHN0YXRlcyB0aGF0IGNhbiBmb2xsb3cgdGhpcyBvbmUgdGhyb3VnaCBzaGlmdCBhY3Rpb25zIG9yXG4gICAgLy8vIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAgIG5leHRTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMubmV4dFN0YXRlQ2FjaGVbc3RhdGVdO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmRhdGFbaSArIDJdICYgKDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8gPj4gMTYpKSA9PSAwICYmIHJlc3VsdC5pbmRleE9mKHRoaXMuZGF0YVtpICsgMV0pIDwgMClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmRhdGFbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFibGUgPSB0aGlzLmdvdG8sIG1heCA9IHRhYmxlWzBdO1xuICAgICAgICBmb3IgKGxldCB0ZXJtID0gMDsgdGVybSA8IG1heDsgdGVybSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0YWJsZVt0ZXJtICsgMV07Oykge1xuICAgICAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlW3Bvc10gPT0gc3RhdGUgJiYgcmVzdWx0LmluZGV4T2YodGFyZ2V0KSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFRhZyAmIDEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRTdGF0ZUNhY2hlW3N0YXRlXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKFBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5uZXN0ZWQpXG4gICAgICAgICAgICBjb3B5Lm5lc3RlZCA9IHRoaXMubmVzdGVkLm1hcChvYmogPT4ge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZy5uZXN0ZWQsIG9iai5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBvYmoubmFtZSwgdmFsdWU6IGNvbmZpZy5uZXN0ZWRbb2JqLm5hbWVdLCBlbmQ6IG9iai5lbmQsIHBsYWNlaG9sZGVyOiBvYmoucGxhY2Vob2xkZXIgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICAvLy8gd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgLy8vIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICAvLy8gc3RvcmVkLlxuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLy8vIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgLy8vIHR5cGVzLiBAaW50ZXJuYWxcbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvLy8gVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBncmFtbWFyIGhhcyBhbnkgbmVzdGVkIGdyYW1tYXJzLlxuICAgIGdldCBoYXNOZXN0ZWQoKSB7IHJldHVybiB0aGlzLm5lc3RlZC5sZW5ndGggPiAwOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGR5bmFtaWNQcmVjZWRlbmNlKHRlcm0pIHtcbiAgICAgICAgbGV0IHByZWMgPSB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcztcbiAgICAgICAgcmV0dXJuIHByZWMgPT0gbnVsbCA/IDAgOiBwcmVjW3Rlcm1dIHx8IDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwYXJzZURpYWxlY3QoZGlhbGVjdCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZWREaWFsZWN0ICYmIHRoaXMuY2FjaGVkRGlhbGVjdC5zb3VyY2UgPT0gZGlhbGVjdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZERpYWxlY3Q7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRGlhbGVjdCA9IG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyAodXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yKSBAaW50ZXJuYWxcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kT2Zmc2V0KGRhdGEsIHN0YXJ0LCB0ZXJtKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBuZXh0OyAobmV4dCA9IGRhdGFbaV0pICE9IDY1NTM1IC8qIEVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBpZiAoc3RhY2sucG9zID09IHN0YWNrLmN4LmlucHV0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc3RhY2suY3gucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5cbmV4cG9ydHMuTm9kZVByb3AgPSBsZXplclRyZWUuTm9kZVByb3A7XG5leHBvcnRzLk5vZGVTZXQgPSBsZXplclRyZWUuTm9kZVNldDtcbmV4cG9ydHMuTm9kZVR5cGUgPSBsZXplclRyZWUuTm9kZVR5cGU7XG5leHBvcnRzLlRyZWUgPSBsZXplclRyZWUuVHJlZTtcbmV4cG9ydHMuVHJlZUN1cnNvciA9IGxlemVyVHJlZS5UcmVlQ3Vyc29yO1xuZXhwb3J0cy5FeHRlcm5hbFRva2VuaXplciA9IEV4dGVybmFsVG9rZW5pemVyO1xuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5leHBvcnRzLlN0YWNrID0gU3RhY2s7XG5leHBvcnRzLlRva2VuID0gVG9rZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY291bnREZWZEZWNsU3RtdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBjb3VudERlZkRlY2xTdG10cyhzdG10cykge1xuICAgIHZhciBmID0gZnVuY3Rpb24gKGFjYywgeCkge1xuICAgICAgICB2YXIgYiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHgudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlZmluZVwiOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXNzaWduXCI6IHJldHVybiAhKHgudHlwZV8gPT0gXCJcIik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gKGFjY1swXSAmJiBiKSA/IFt0cnVlLCBhY2NbMV0gKyAxXSA6IFtmYWxzZSwgYWNjWzFdXTtcbiAgICB9O1xuICAgIHJldHVybiBzdG10cy5yZWR1Y2UoZiwgW3RydWUsIDBdKVsxXTtcbn1cbmV4cG9ydHMuY291bnREZWZEZWNsU3RtdHMgPSBjb3VudERlZkRlY2xTdG10cztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcGlsZSA9IGV4cG9ydHMuY29kZUdlblN0bXQgPSBleHBvcnRzLmhhc1JldHVybnMgPSBleHBvcnRzLmNvZGVHZW5FeHByID0gZXhwb3J0cy5ydW4gPSB2b2lkIDA7XG52YXIgd2FidF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3YWJ0XCIpKTtcbnZhciBhc3RfMSA9IHJlcXVpcmUoXCIuL2FzdFwiKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3BhcnNlclwiKTtcbnZhciB0eXBlY2hlY2tlcl8xID0gcmVxdWlyZShcIi4vdHlwZWNoZWNrZXJcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBydW4od2F0U291cmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2FidEFwaSwgcGFyc2VkLCBiaW5hcnksIHdhc21Nb2R1bGU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHdhYnRfMS5kZWZhdWx0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgd2FidEFwaSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gd2FidEFwaS5wYXJzZVdhdChcImV4YW1wbGVcIiwgd2F0U291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5ID0gcGFyc2VkLnRvQmluYXJ5KHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LmJ1ZmZlciwge30pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHdhc21Nb2R1bGUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmV4dCBsaW5lIGlzIHdhc20taW50ZXJwXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB3YXNtTW9kdWxlLmluc3RhbmNlLmV4cG9ydHMuX3N0YXJ0KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucnVuID0gcnVuO1xuLy8gKHdpbmRvdyBhcyBhbnkpW1wicnVuV2F0XCJdID0gcnVuO1xuZnVuY3Rpb24gY29kZUdlbkV4cHIoZXhwcikge1xuICAgIHN3aXRjaCAoZXhwci50YWcpIHtcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiKGxvY2FsLmdldCAkXCIgKyBleHByLm5hbWUgKyBcIilcIl07XG4gICAgICAgIGNhc2UgXCJsaXRlcmFsXCI6IHtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gZXhwci52YWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAobGl0ZXJhbC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGxpdGVyYWwudmFsdWUpID8gW1wiKGkzMi5jb25zdCAxKVwiXSA6IFtcIihpMzIuY29uc3QgMClcIl07XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiKGkzMi5jb25zdCBcIiArIGxpdGVyYWwudmFsdWUgKyBcIilcIl07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uZSBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gZXhwci5hcmd1bWVudHMubWFwKGNvZGVHZW5FeHByKS5mbGF0KCkuY29uY2F0KFtcIihjYWxsICRcIiArIGV4cHIubmFtZSArIFwiKVwiXSk7XG4gICAgICAgIGNhc2UgXCJ1bmlvcFwiOiB7XG4gICAgICAgICAgICB2YXIgaW5zdHIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci51bmlvcCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm90XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiKGkzMi5jb25zdCAxKVwiLCBcIihpMzIueG9yKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIihpMzIuY29uc3QgLTEpXCIsIFwiKGkzMi5tdWwpXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgYXJnRXhwciA9IGNvZGVHZW5FeHByKGV4cHIuYXJnKTtcbiAgICAgICAgICAgIHJldHVybiBhcmdFeHByLmNvbmNhdChpbnN0cik7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJpbm9wXCI6IHtcbiAgICAgICAgICAgIHZhciBhcmdFeHByMSA9IGNvZGVHZW5FeHByKGV4cHIuYXJnMSk7XG4gICAgICAgICAgICB2YXIgYXJnRXhwcjIgPSBjb2RlR2VuRXhwcihleHByLmFyZzIpO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmdFeHByMS5jb25jYXQoYXJnRXhwcjIpO1xuICAgICAgICAgICAgdmFyIGJpbm9wID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYmlub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIitcIjogcmV0dXJuIFwiYWRkXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6IHJldHVybiBcInN1YlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOiByZXR1cm4gXCJtdWxcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi8vXCI6IHJldHVybiBcImRpdl9zXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIlXCI6IHJldHVybiBcInJlbV9zXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiOiByZXR1cm4gXCJlcVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIT1cIjogcmV0dXJuIFwibmVxXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiOiByZXR1cm4gXCJsZV9zXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiOiByZXR1cm4gXCJnZV9zXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiBcImx0X3NcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj5cIjogcmV0dXJuIFwiZ3Rfc1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXNcIjogdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gYXJncy5jb25jYXQoW1wiKGkzMi5cIiArIGJpbm9wICsgXCIpXCJdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY29kZUdlbkV4cHIgPSBjb2RlR2VuRXhwcjtcbmZ1bmN0aW9uIGhhc1JldHVybnMoc3RtdCkge1xuICAgIHN3aXRjaCAoc3RtdC50YWcpIHtcbiAgICAgICAgY2FzZSBcImlmXCI6XG4gICAgICAgICAgICByZXR1cm4gIXN0bXQuYm9keTEuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICFoYXNSZXR1cm5zKHMpOyB9KVxuICAgICAgICAgICAgICAgIHx8ICFzdG10LmJvZHkyLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiAhaGFzUmV0dXJucyhzKTsgfSlcbiAgICAgICAgICAgICAgICB8fCAhc3RtdC5ib2R5MS5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gcy50YWcgIT0gXCJyZXR1cm5cIjsgfSlcbiAgICAgICAgICAgICAgICB8fCAhc3RtdC5ib2R5Mi5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gcy50YWcgIT0gXCJyZXR1cm5cIjsgfSk7XG4gICAgICAgIGNhc2UgXCJ3aGlsZVwiOlxuICAgICAgICAgICAgcmV0dXJuICFzdG10LmJvZHkuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICFoYXNSZXR1cm5zKHMpOyB9KVxuICAgICAgICAgICAgICAgIHx8ICFzdG10LmJvZHkuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudGFnICE9IFwicmV0dXJuXCI7IH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaGFzUmV0dXJucyA9IGhhc1JldHVybnM7XG5mdW5jdGlvbiBjb2RlR2VuU3RtdChzdG10KSB7XG4gICAgc3dpdGNoIChzdG10LnRhZykge1xuICAgICAgICBjYXNlIFwiZGVmaW5lXCI6IHtcbiAgICAgICAgICAgIHZhciBpbnB1dE91dHB1dCA9IHN0bXQucGFyYW1ldGVycy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIFwiKHBhcmFtICRcIiArIHAubmFtZSArIFwiIGkzMilcIjsgfSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgZGVmaW5lIHN0YXRlbWVudHNcbiAgICAgICAgICAgIHZhciBuID0gYXN0XzEuY291bnREZWZEZWNsU3RtdHMoc3RtdC5ib2R5KTtcbiAgICAgICAgICAgIHZhciBkZWZTdG10cyA9IHN0bXQuYm9keS5zbGljZSgwLCBuKTtcbiAgICAgICAgICAgIHZhciByZXN0XzEgPSBzdG10LmJvZHkuc2xpY2Uobik7XG4gICAgICAgICAgICB2YXIgZGVjbHMgPSBkZWZTdG10cy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudGFnID09IFwiYXNzaWduXCI7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIGlmIChzLnRhZyAhPSBcImFzc2lnblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIGVycm9yLiBDaGVjayBjb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiKGxvY2FsICRcIiArIHMubmFtZSArIFwiIGkzMilcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRlZnMgPSBkZWZTdG10cy5tYXAoY29kZUdlblN0bXQpLmZsYXQoKTtcbiAgICAgICAgICAgIHZhciBwcmVhbWJsZSA9IGRlY2xzLmNvbmNhdChkZWZzKS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiICAgIFwiICsgczsgfSk7XG4gICAgICAgICAgICB2YXIgZGlzdEJldHdlZW5OZXN0ZWRSZXR1cm5fMSA9IHJlc3RfMS5tYXAoZnVuY3Rpb24gKGssIGkpIHsgcmV0dXJuIFtpLCBrXTsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiBoYXNSZXR1cm5zKHRbMV0pOyB9KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBhY2NbMF0uY29uY2F0KFt0WzBdIC0gYWNjWzFdXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthcnIsIHRbMF1dO1xuICAgICAgICAgICAgfSwgW1tdLCAwXSlbMF07XG4gICAgICAgICAgICAvLyBtYW5pcHVsYXRlIHRoZSBBU1QgaW5zdGVhZCBvZiBkb2luZyB0aGlzIG1hbnVhbGx5XG4gICAgICAgICAgICB2YXIgYWRkSWZFbHNlRW5jbG9zdXJlXzEgPSBmdW5jdGlvbiAoY29kZSwgZGlzdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGRpc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJTbGljZSA9IGNvZGUuc2xpY2UoMCwgbiArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBtYXliZUVhcmx5UmV0ID0gY3VyclNsaWNlLm1hcChjb2RlR2VuU3RtdCkuZmxhdCgpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCIgICAgXCIgKyBzOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gY29kZS5zbGljZShuICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlU2tpcDtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVNraXAgPSBhZGRJZkVsc2VFbmNsb3N1cmVfMShyZW1haW5kZXIsIGRpc3RzKS5mbGF0KCkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBcIiAgICBcIiArIHM7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVTa2lwID0gcmVtYWluZGVyLm1hcChjb2RlR2VuU3RtdCkuZmxhdCgpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCIgICAgXCIgKyBzOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF5YmVTa2lwW21heWJlU2tpcC5sZW5ndGggLSAxXSArPSBcIikpXCI7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlQmxvY2sgPSBbXCIobG9jYWwuZ2V0ICRfX19FQVJMWV9SRVQpXCIsIFwiKGkzMi5jb25zdCAxKVwiLFxuICAgICAgICAgICAgICAgICAgICBcIihpMzIueG9yKVwiLCBcIihpZlwiLCBcIiAgKHRoZW5cIl1cbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXliZVNraXApXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiICAgIFwiICsgczsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlRWFybHlSZXQuY29uY2F0KG1heWJlQmxvY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0QmV0d2Vlbk5lc3RlZFJldHVybl8xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZElmRWxzZUVuY2xvc3VyZV8xKHJlc3RfMSwgZGlzdEJldHdlZW5OZXN0ZWRSZXR1cm5fMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdF8xLm1hcChjb2RlR2VuU3RtdCkuZmxhdCgpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCIgICAgXCIgKyBzOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgLy8gaWYgYW55IHN0YXRlbWVudCBjb250YWlucyBuZXN0ZWQgcmV0dXJuIHN0YXRlbWVudHNcbiAgICAgICAgICAgIGlmICghcmVzdF8xLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiAhaGFzUmV0dXJucyhzKTsgfSkgfHwgcmVzdF8xW3Jlc3RfMS5sZW5ndGggLSAxXS50YWcgPT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAgIGlucHV0T3V0cHV0ICs9IFwiIChyZXN1bHQgaTMyKVwiO1xuICAgICAgICAgICAgICAgIHByZWFtYmxlLnVuc2hpZnQoXCIgICAgKGxvY2FsICRfX19SRVRfVkFMIGkzMilcIik7XG4gICAgICAgICAgICAgICAgcHJlYW1ibGUudW5zaGlmdChcIiAgICAobG9jYWwgJF9fX0VBUkxZX1JFVCBpMzIpXCIpO1xuICAgICAgICAgICAgICAgIHByZWFtYmxlLnB1c2goXCIgICAgKGkzMi5jb25zdCAwKVwiKTtcbiAgICAgICAgICAgICAgICBwcmVhbWJsZS5wdXNoKFwiICAgIChsb2NhbC5zZXQgJF9fX0VBUkxZX1JFVClcIik7XG4gICAgICAgICAgICAgICAgcmVtYWluZGVyLnB1c2goXCIgICAgKGxvY2FsLmdldCAkX19fUkVUX1ZBTClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1haW5kZXJbcmVtYWluZGVyLmxlbmd0aCAtIDFdICs9IFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIChbXCIgIChmdW5jICRcIiArIHN0bXQubmFtZSArIFwiIFwiICsgaW5wdXRPdXRwdXRdKS5jb25jYXQocHJlYW1ibGUsIHJlbWFpbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgICAgLy8gVE9ETzogc2VlIGlmIHlvdSBjYW4gb3B0aW1pemUgYXdheSB0aGUgbGFzdCB0d28gaW5zdHJ1Y3Rpb25zIHdoZW4gdGhlcmVcbiAgICAgICAgICAgIC8vIGlzIG5vIGJyYW5jaGluZ1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVHZW5FeHByKHN0bXQudmFsdWUpLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgXCIobG9jYWwuc2V0ICRfX19SRVRfVkFMKVwiLFxuICAgICAgICAgICAgICAgIFwiKGkzMi5jb25zdCAxKVwiLFxuICAgICAgICAgICAgICAgIFwiKGxvY2FsLnNldCAkX19fRUFSTFlfUkVUKVwiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgY2FzZSBcImFzc2lnblwiOiB7XG4gICAgICAgICAgICByZXR1cm4gY29kZUdlbkV4cHIoc3RtdC52YWx1ZSkuY29uY2F0KFtcIihsb2NhbC5zZXQgJFwiICsgc3RtdC5uYW1lICsgXCIpXCJdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXhwclwiOlxuICAgICAgICAgICAgLy8gdGhlIHR5cGVjaGVja2VyIHNob3VsZCBwcmV2ZW50IHRoaXMgRVhDRVBUIGZvciBhIGxvbmUgZXhwcmVzc2lvbiBhdCB0aGVcbiAgICAgICAgICAgIC8vIGVuZCBvZiB0aGUgcHJvZ3JhbSB3aGljaCB3aWxsIGJlIGltcGxpY2l0bHkgcmV0dXJuZWRcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgaW50byBhIHByaW50IHN0YXRlbWVudFxuICAgICAgICAgICAgcmV0dXJuIGNvZGVHZW5FeHByKHN0bXQuZXhwcikuY29uY2F0KFtcIihsb2NhbC5zZXQgJF9fX0lNUExfUkVUKVwiXSk7XG4gICAgICAgIGNhc2UgXCJpZlwiOiB7XG4gICAgICAgICAgICB2YXIgcHJlZCA9IGNvZGVHZW5FeHByKHN0bXQucHJlZCk7XG4gICAgICAgICAgICB2YXIgYm9keTEgPSBzdG10LmJvZHkxLm1hcChjb2RlR2VuU3RtdCkuZmxhdCgpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCIgICAgXCIgKyBzOyB9KTtcbiAgICAgICAgICAgIGJvZHkxW2JvZHkxLmxlbmd0aCAtIDFdID0gYm9keTFbYm9keTEubGVuZ3RoIC0gMV0gKyBcIilcIjtcbiAgICAgICAgICAgIHZhciBib2R5MiA9IHN0bXQuYm9keTIubWFwKGNvZGVHZW5TdG10KS5mbGF0KCkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBcIiAgICBcIiArIHM7IH0pO1xuICAgICAgICAgICAgYm9keTJbYm9keTIubGVuZ3RoIC0gMV0gPSBib2R5Mltib2R5Mi5sZW5ndGggLSAxXSArIFwiKSlcIjtcbiAgICAgICAgICAgIHZhciB0aGVuQ2wgPSAoYm9keTEubGVuZ3RoID4gMCkgPyBcIiAgKHRoZW5cIiA6IFwiICAodGhlbilcIjtcbiAgICAgICAgICAgIHZhciBlbHNlQ2wgPSAoYm9keTIubGVuZ3RoID4gMCkgPyBcIiAgKGVsc2VcIiA6IFwiICAoZWxzZSkpXCI7XG4gICAgICAgICAgICByZXR1cm4gKHByZWQpLmNvbmNhdChbXCIoaWZcIiwgdGhlbkNsXSwgYm9keTEsIFtlbHNlQ2xdLCBib2R5Mik7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIndoaWxlXCI6IHtcbiAgICAgICAgICAgIHZhciBwcmVkID0gY29kZUdlbkV4cHIoc3RtdC5wcmVkKTtcbiAgICAgICAgICAgIHZhciBib2R5ID0gc3RtdC5ib2R5XG4gICAgICAgICAgICAgICAgLm1hcChjb2RlR2VuU3RtdClcbiAgICAgICAgICAgICAgICAuZmxhdCgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChwcmVkLCBbXCIoaTMyLmNvbnN0IDEpXCIsIFwiKGkzMi54b3IpXCIsIFwiKGJyX2lmIDEpXCIsIFwiKGJyIDApKSkpXCJdKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiICAgICAgXCIgKyBzOyB9KTtcbiAgICAgICAgICAgIHJldHVybiAocHJlZCkuY29uY2F0KFtcIihpZlwiLCBcIiAgKHRoZW5cIiwgXCIgICAgKGxvb3BcIl0sIGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJwYXNzXCI6IHJldHVybiBbXTtcbiAgICB9XG59XG5leHBvcnRzLmNvZGVHZW5TdG10ID0gY29kZUdlblN0bXQ7XG5mdW5jdGlvbiBjb21waWxlKHNvdXJjZSkge1xuICAgIHZhciBhc3QgPSBwYXJzZXJfMS5wYXJzZVByb2dyYW0oc291cmNlKTtcbiAgICB0cnkge1xuICAgICAgICB0eXBlY2hlY2tlcl8xLnR5cGVDaGVja1Byb2dyYW0oYXN0KTtcbiAgICAgICAgdmFyIHZhcnNfMSA9IFtdO1xuICAgICAgICBhc3QuZm9yRWFjaChmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICAgICAgaWYgKHN0bXQudGFnID09PSBcImFzc2lnblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyc18xLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmdW5zXzEgPSBbXTtcbiAgICAgICAgYXN0LmZvckVhY2goZnVuY3Rpb24gKHN0bXQsIGkpIHtcbiAgICAgICAgICAgIGlmIChzdG10LnRhZyA9PT0gXCJkZWZpbmVcIikge1xuICAgICAgICAgICAgICAgIGZ1bnNfMS5wdXNoKGNvZGVHZW5TdG10KHN0bXQpLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFsbEZ1bnMgPSBmdW5zXzEuam9pbihcIlxcblxcblwiKTtcbiAgICAgICAgdmFyIHN0bXRzID0gYXN0LmZpbHRlcihmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC50YWcgIT09IFwiZGVmaW5lXCI7IH0pO1xuICAgICAgICB2YXIgdmFyRGVjbHNfMSA9IFtdO1xuICAgICAgICB2YXJEZWNsc18xLnB1c2goXCIobG9jYWwgJF9fX0lNUExfUkVUIGkzMilcIik7XG4gICAgICAgIHZhcnNfMS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHZhckRlY2xzXzEucHVzaChcIihsb2NhbCAkXCIgKyB2ICsgXCIgaTMyKVwiKTsgfSk7XG4gICAgICAgIHZhciBhbGxTdG10cyA9IHN0bXRzLm1hcChjb2RlR2VuU3RtdCkuZmxhdCgpO1xuICAgICAgICB2YXIgb3VyQ29kZSA9IHZhckRlY2xzXzEuY29uY2F0KGFsbFN0bXRzKS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiICAgIFwiICsgczsgfSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgdmFyIGxhc3RTdG10ID0gYXN0W2FzdC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzRXhwciA9IGxhc3RTdG10LnRhZyA9PT0gXCJleHByXCI7XG4gICAgICAgIHZhciBzY2FmZm9sZCA9IFtcbiAgICAgICAgICAgIFwiKG1vZHVsZVwiLFxuICAgICAgICAgICAgYWxsRnVucyxcbiAgICAgICAgICAgIFwiICAoZnVuYyAoZXhwb3J0IFxcXCJfc3RhcnRcXFwiKSBcIiArICgoaXNFeHByKSA/IFwiKHJlc3VsdCBpMzIpXCIgOiBcIlwiKSxcbiAgICAgICAgICAgIChpc0V4cHIpID8gb3VyQ29kZSA6IG91ckNvZGUgKyBcIikpXCIsXG4gICAgICAgICAgICAoaXNFeHByKSA/IFwiICAgIChsb2NhbC5nZXQgJF9fX0lNUExfUkVUKSkpXCIgOiBcIlwiXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBzY2FmZm9sZC5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGFsZXJ0KGVyci5tZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbXBpbGVyRXJyb3IoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmlhcnlPcFR5cGVFcnJvciA9IGV4cG9ydHMuUGFyc2VFcnJvciA9IGV4cG9ydHMuRnVuY0NhbGxUeXBFcnJvciA9IGV4cG9ydHMuR2VuZXJhbFR5cGVFcnJvciA9IGV4cG9ydHMuTWlzc2luZ1JldHVybiA9IGV4cG9ydHMuTm90RGVjbGFyZWRJblNjb3BlID0gZXhwb3J0cy5Ob3RBVmFyaWFibGUgPSBleHBvcnRzLk5vdEFGdW5jdGlvbk9yQ2xhc3MgPSBleHBvcnRzLkR1cGxpY2F0ZURlY2xhcmF0aW9uID0gZXhwb3J0cy5Db25kaXRpb25hbEV4cHJUeXBlRXJyb3IgPSBleHBvcnRzLkNvbXBpbGVyRXJyb3IgPSBleHBvcnRzLkJpbmFyeU9wVHlwZUVycm9yID0gdm9pZCAwO1xudmFyIEJpbmFyeU9wVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5hcnlPcFR5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5hcnlPcFR5cGVFcnJvcihvcCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJDYW5ub3QgYXBwbHkgb3BlcmF0b3IgYFwiICsgb3AgKyBcImAgb24gdHlwZXMgYFwiICsgdDEgKyBcImAgYW5kIGBcIiArIHQyICsgXCJgXCIpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdCaW5hcnlPcFR5cGVFcnJvcic7XG4gICAgICAgIF90aGlzLm9wID0gb3A7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCaW5hcnlPcFR5cGVFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQmluYXJ5T3BUeXBlRXJyb3IgPSBCaW5hcnlPcFR5cGVFcnJvcjtcbnZhciBDb21waWxlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBpbGVyRXJyb3IoKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTm90QVZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uYW1lID0gJ0NvbXBpbGVyRXJyb3InO1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZXJFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQ29tcGlsZXJFcnJvciA9IENvbXBpbGVyRXJyb3I7XG52YXIgQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25kaXRpb25hbEV4cHJUeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yKGNvbmRpdGlvbmFsVHlwZSkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiBjYW5ub3QgYmUgb2YgdHlwZSBgXCIgKyBjb25kaXRpb25hbFR5cGUgKyBcImBcIikgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTm90QVZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uYW1lID0gJ0NvbmRpdGlvbmFsRXhwclR5cGVFcnJvcic7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbmFsVHlwZSA9IGNvbmRpdGlvbmFsVHlwZTtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwclR5cGVFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yID0gQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yO1xudmFyIER1cGxpY2F0ZURlY2xhcmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEdXBsaWNhdGVEZWNsYXJhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEdXBsaWNhdGVEZWNsYXJhdGlvbihpZGVudCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiRHVwbGljYXRlIGRlY2xhcmF0aW9uIG9mIGlkZW50aWZpZXIgaW4gc2FtZSBzY29wZTogXCIgKyBpZGVudCkgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgRHVwbGljYXRlRGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5hbWUgPSAnRHVwbGljYXRlRGVjbGFyYXRpb24nO1xuICAgICAgICBfdGhpcy5pZGVudCA9IGlkZW50O1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRHVwbGljYXRlRGVjbGFyYXRpb247XG59KEVycm9yKSk7XG5leHBvcnRzLkR1cGxpY2F0ZURlY2xhcmF0aW9uID0gRHVwbGljYXRlRGVjbGFyYXRpb247XG52YXIgTm90QUZ1bmN0aW9uT3JDbGFzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90QUZ1bmN0aW9uT3JDbGFzcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RBRnVuY3Rpb25PckNsYXNzKG9iak5hbWUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIk5vdCBhIGZ1bmN0aW9uIG9yIGNsYXNzOiBcIiArIG9iak5hbWUpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdEFWYXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdOb3RBRnVuY3Rpb25PckNsYXNzJztcbiAgICAgICAgX3RoaXMub2JqTmFtZSA9IG9iak5hbWU7XG4gICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb3RBRnVuY3Rpb25PckNsYXNzO1xufShFcnJvcikpO1xuZXhwb3J0cy5Ob3RBRnVuY3Rpb25PckNsYXNzID0gTm90QUZ1bmN0aW9uT3JDbGFzcztcbnZhciBOb3RBVmFyaWFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdEFWYXJpYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RBVmFyaWFibGUodmFyTmFtZSkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiTm90IGEgdmFyaWFibGU6IFwiICsgdmFyTmFtZSkgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTm90QVZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uYW1lID0gJ05vdEFWYXJpYWJsZSc7XG4gICAgICAgIF90aGlzLnZhck5hbWUgPSB2YXJOYW1lO1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTm90QVZhcmlhYmxlO1xufShFcnJvcikpO1xuZXhwb3J0cy5Ob3RBVmFyaWFibGUgPSBOb3RBVmFyaWFibGU7XG52YXIgTm90RGVjbGFyZWRJblNjb3BlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3REZWNsYXJlZEluU2NvcGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm90RGVjbGFyZWRJblNjb3BlKHZhck5hbWUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIkNhbm5vdCBhc3NpZ24gdG8gdmFyaWFibGUgdGhhdCBpcyBub3QgZXhwbGljaXRseSBkZWNhbGFyZWQgaW4gdGhpcyBzY29wZTogXCIgKyB2YXJOYW1lKSB8fCB0aGlzO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBOb3REZWNsYXJlZEluU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5hbWUgPSAnTm90RGVjbGFyZWRJblNjb3BlJztcbiAgICAgICAgX3RoaXMudmFyTmFtZSA9IHZhck5hbWU7XG4gICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb3REZWNsYXJlZEluU2NvcGU7XG59KEVycm9yKSk7XG5leHBvcnRzLk5vdERlY2xhcmVkSW5TY29wZSA9IE5vdERlY2xhcmVkSW5TY29wZTtcbnZhciBNaXNzaW5nUmV0dXJuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaXNzaW5nUmV0dXJuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1pc3NpbmdSZXR1cm4oZikge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChmID09PSB2b2lkIDApIHsgZiA9IFwiY29udGFpbnNcIjsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIkFsbCBwYXRocyBpbiB0aGlzIGZ1bmN0aW9uL21ldGhvZCBtdXN0IGhhdmUgYSByZXR1cm4gc3RhdGVtZW50OiBcIiArIGYpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdNaXNzaW5nUmV0dXJuJztcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1pc3NpbmdSZXR1cm47XG59KEVycm9yKSk7XG5leHBvcnRzLk1pc3NpbmdSZXR1cm4gPSBNaXNzaW5nUmV0dXJuO1xudmFyIEdlbmVyYWxUeXBlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdlbmVyYWxUeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2VuZXJhbFR5cGVFcnJvcihhY3R1YWxUeXBlLCBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIkV4cGVjdGVkIHR5cGUgYFwiICsgZXhwZWN0ZWRUeXBlICsgXCJgOyBnb3QgdHlwZSBgXCIgKyBhY3R1YWxUeXBlICsgXCJgXCIpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdHZW5lcmFsVHlwZUVycm9yJztcbiAgICAgICAgX3RoaXMuYWN0dWFsVHlwZSA9IGFjdHVhbFR5cGU7XG4gICAgICAgIF90aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYWxUeXBlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkdlbmVyYWxUeXBlRXJyb3IgPSBHZW5lcmFsVHlwZUVycm9yO1xudmFyIEZ1bmNDYWxsVHlwRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmNDYWxsVHlwRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVuY0NhbGxUeXBFcnJvcihhY3R1YWxUeXBlLCBleHBlY3RlZFR5cGUsIHBhcmFtTikge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiRXhwZWN0ZWQgdHlwZSBgXCIgKyBleHBlY3RlZFR5cGUgKyBcImA7IGdvdCB0eXBlIGBcIiArIGFjdHVhbFR5cGUgKyBcImBcIikgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgRnVuY0NhbGxUeXBFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdGdW5jQ2FsbFR5cEVycm9yJztcbiAgICAgICAgX3RoaXMuYWN0dWFsVHlwZSA9IGFjdHVhbFR5cGU7XG4gICAgICAgIF90aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgX3RoaXMucGFyYW1OID0gcGFyYW1OO1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRnVuY0NhbGxUeXBFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuRnVuY0NhbGxUeXBFcnJvciA9IEZ1bmNDYWxsVHlwRXJyb3I7XG52YXIgUGFyc2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJzZUVycm9yKHRva2VuKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJQYXJzZSBlcnJvciBuZWFyIHRva2VuIFwiICsgdG9rZW4pIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdQYXJzZUVycm9yJztcbiAgICAgICAgX3RoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlBhcnNlRXJyb3IgPSBQYXJzZUVycm9yO1xudmFyIFVuaWFyeU9wVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbmlhcnlPcFR5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmlhcnlPcFR5cGVFcnJvcihvcCwgdCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiQ2Fubm90IGFwcGx5IG9wZXJhdG9yIGBcIiArIG9wICsgXCJgIG9uIHR5cGUgYFwiICsgdCArIFwiYFwiKSB8fCB0aGlzO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBOb3REZWNsYXJlZEluU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5hbWUgPSAnVW5pYXJ5T3BUeXBlRXJyb3InO1xuICAgICAgICBfdGhpcy5vcCA9IG9wO1xuICAgICAgICBfdGhpcy50ID0gdDtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVuaWFyeU9wVHlwZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5VbmlhcnlPcFR5cGVFcnJvciA9IFVuaWFyeU9wVHlwZUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYXZlcnNlRXhwciA9IGV4cG9ydHMudHJhdmVyc2VQYXJhbWV0ZXJzID0gZXhwb3J0cy50cmF2ZXJzZVN0bXQgPSBleHBvcnRzLnBhcnNlRm9sbG93aW5nU3RtdHMgPSBleHBvcnRzLnBhcnNlUHJvZ3JhbSA9IHZvaWQgMDtcbnZhciBsZXplcl9weXRob25fMSA9IHJlcXVpcmUoXCJsZXplci1weXRob25cIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBwYXJzZVByb2dyYW0oc291cmNlKSB7XG4gICAgdmFyIHQgPSBsZXplcl9weXRob25fMS5wYXJzZXIucGFyc2Uoc291cmNlKS5jdXJzb3IoKTtcbiAgICAvLyBUaGUgdG9wIG5vZGUgaW4gdGhlIHByb2dyYW0gaXMgYSBTY3JpcHQgbm9kZSB3aXRoIGEgbGlzdCBvZiBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHZhcmlvdXMgc3RhdGVtZW50c1xuICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgIHJldHVybiBwYXJzZUZvbGxvd2luZ1N0bXRzKHNvdXJjZSwgdCk7XG59XG5leHBvcnRzLnBhcnNlUHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbTtcbmZ1bmN0aW9uIHBhcnNlRm9sbG93aW5nU3RtdHMocywgdCkge1xuICAgIHZhciBzdG10cyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHN0bXQgPSB0cmF2ZXJzZVN0bXQocywgdCk7XG4gICAgICAgIHN0bXRzLnB1c2goc3RtdCk7XG4gICAgICAgIC8vIGRyb3AgYWxsIHN0YXRlbWVudHMgYWZ0ZXIgcGFzcyBvciBlYXJseSByZXR1cm5cbiAgICAgICAgaWYgKHN0bXQudGFnID09IFwicGFzc1wiIHx8IHN0bXQudGFnID09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAodC5uZXh0U2libGluZygpKTsgLy8gdC5uZXh0U2libGluZygpIHJldHVybnMgZmFsc2Ugd2hlbiBpdCByZWFjaGVzXG4gICAgLy8gIHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICByZXR1cm4gc3RtdHM7XG59XG5leHBvcnRzLnBhcnNlRm9sbG93aW5nU3RtdHMgPSBwYXJzZUZvbGxvd2luZ1N0bXRzO1xuLypcbiAgSW52YXJpYW50IOKAkyB0IG11c3QgZm9jdXMgb24gdGhlIHNhbWUgbm9kZSBhdCB0aGUgZW5kIG9mIHRoZSB0cmF2ZXJzYWxcbiovXG5mdW5jdGlvbiB0cmF2ZXJzZVN0bXQocywgdCkge1xuICAgIHN3aXRjaCAodC50eXBlLm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgcmV0dXJuIGtleXdvcmRcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJyZXR1cm5cIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkFzc2lnblN0YXRlbWVudFwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gZm9jdXNlZCBvbiBuYW1lICh0aGUgZmlyc3QgY2hpbGQpXG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGRlY2xhcmVkIHR5cGUgKGlmIGFueSlcbiAgICAgICAgICAgIHZhciB0eXBlXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQuZmlyc3RDaGlsZCgpKSB7IC8vIDogaW4gdGhlIHR5cGUgZGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyB0aGUgYWN0dWFsIGRlY2xhcmVkIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnN0ciA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdHIgPT0gXCJib29sXCIgfHwgc3Vic3RyID09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzdHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBmb2N1c2VkIG9uID0gc2lnbi4gTWF5IG5lZWQgdGhpcyBmb3IgY29tcGxleCB0YXNrcywgbGlrZSArPSFcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZm9jdXNlZCBvbiB0aGUgdmFsdWUgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJhc3NpZ25cIiwgbmFtZTogbmFtZV8xLCB0eXBlXzogdHlwZV8sIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6IHtcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBUaGUgY2hpbGQgaXMgc29tZSBraW5kIG9mIGV4cHJlc3Npb24sIHRoZVxuICAgICAgICAgICAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCBpcyBqdXN0IGEgd3JhcHBlciB3aXRoIG5vIGluZm9ybWF0aW9uXG4gICAgICAgICAgICB2YXIgZXhwciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiZXhwclwiLCBleHByOiBleHByIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIklmU3RhdGVtZW50XCI6IHtcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBpZiBzdGF0ZW1lbnRcbiAgICAgICAgICAgIHZhciB0cmF2ZXJzZUlmc18xID0gZnVuY3Rpb24gKHMsIHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKFtcImlmXCIsIFwiZWxpZlwiXSkuaW5jbHVkZXModC5ub2RlLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyB0aGUgcHJlZGljYXRlXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVkID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyA6IGJlZm9yZSB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIHRoZSBmaXJzdCBzdGF0ZW1lbnQgb2YgdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkxID0gcGFyc2VGb2xsb3dpbmdTdG10cyhzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9keSBpbW1lZGlhdGVseSBhZnRlciBpZiBjYW5ub3QgYmUgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkxLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VFcnJvcihcIkRFREVOVFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBCb2R5XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZWxpZi9lbHNlIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbeyB0YWc6IFwiaWZcIiwgcHJlZDogcHJlZCwgYm9keTE6IGJvZHkxLCBib2R5MjogdHJhdmVyc2VJZnNfMShzLCB0KSB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodC5ub2RlLnR5cGUubmFtZSA9PSBcImVsc2VcIikgeyAvLyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIDogYmVmb3JlIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGZpcnN0IHN0YXRlbWVudCBvZiB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keV8xID0gcGFyc2VGb2xsb3dpbmdTdG10cyhzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHlfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIGVycm9yLiBDaGVjayBjb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGlmc3RtdCA9IHRyYXZlcnNlSWZzXzEocywgdCk7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIGlmc3RtdFswXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjoge1xuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIHdoaWxlXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIHByZWRpY2F0ZVxuICAgICAgICAgICAgdmFyIHByZWQgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEJvZHlcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBjb2xvblxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBzdGF0ZW1lbnRcbiAgICAgICAgICAgIHZhciBib2R5XzIgPSBwYXJzZUZvbGxvd2luZ1N0bXRzKHMsIHQpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwid2hpbGVcIiwgcHJlZDogcHJlZCwgYm9keTogYm9keV8yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIlBhc3NTdGF0ZW1lbnRcIjogcmV0dXJuIHsgdGFnOiBcInBhc3NcIiB9O1xuICAgICAgICBjYXNlIFwiRnVuY3Rpb25EZWZpbml0aW9uXCI6XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgb24gZGVmXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIG5hbWUgb2YgZnVuY3Rpb25cbiAgICAgICAgICAgIHZhciBuYW1lXzIgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBQYXJhbUxpc3RcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdHJhdmVyc2VQYXJhbWV0ZXJzKHMsIHQpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIG91dHB1dFR5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0Lm5vZGUudHlwZS5uYW1lID09IFwiVHlwZURlZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIHRoZSBhY3R1YWwgZGVjbGFyZWQgdHlwZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic3RyID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0ciA9PSBcImJvb2xcIiB8fCBzdWJzdHIgPT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnN0cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIEJvZHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRUeXBlXzEgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiA6XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICAgIHZhciBib2R5ID0gcGFyc2VGb2xsb3dpbmdTdG10cyhzLCB0KTtcbiAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlRXJyb3IoXCJFT0ZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gQm9keVxuICAgICAgICAgICAgdC5wYXJlbnQoKTsgLy8gUG9wIHRvIEZ1bmN0aW9uRGVmaW5pdGlvblxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImRlZmluZVwiLCBuYW1lOiBuYW1lXzIsIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsIG91dHB1dFR5cGU6IG91dHB1dFR5cGUsIGJvZHk6IGJvZHkgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyYXZlcnNlU3RtdCA9IHRyYXZlcnNlU3RtdDtcbmZ1bmN0aW9uIHRyYXZlcnNlUGFyYW1ldGVycyhzLCB0KSB7XG4gICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXNlcyBvbiBvcGVuIHBhcmVuXG4gICAgZG8ge1xuICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzZXMgb24gYSBWYXJpYWJsZU5hbWVcbiAgICAgICAgdmFyIG5hbWVfMyA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgIGlmIChuYW1lXzMgPT0gXCIpXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIHR5cGVkZWYsIGlmIGFueVxuICAgICAgICBpZiAodC5ub2RlLnR5cGUubmFtZSA9PSBcIlR5cGVEZWZcIikge1xuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIDogaW4gdGhlIHR5cGUgZGVjbGFyYXRpb25cbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGFjdHVhbCBkZWNsYXJlZCB0eXBlXG4gICAgICAgICAgICB2YXIgdHlwZV8gPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTsgLy8gYmFjayB0byBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh7IG5hbWU6IG5hbWVfMywgdHlwZV86IHR5cGVfIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2UgZXJyb3IgbmVhciB0b2tlbiBSUEFSRU46IFwiICsgcy5zdWJzdHJpbmcodC5ub2RlLmZyb20sIHQubm9kZS50bykpO1xuICAgICAgICB9XG4gICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gLCBvciApXG4gICAgfSB3aGlsZSAocy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSAhPSBcIilcIik7XG4gICAgdC5wYXJlbnQoKTsgLy8gUG9wIHRvIFBhcmFtTGlzdFxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuZXhwb3J0cy50cmF2ZXJzZVBhcmFtZXRlcnMgPSB0cmF2ZXJzZVBhcmFtZXRlcnM7XG5mdW5jdGlvbiB0cmF2ZXJzZUV4cHIocywgdCkge1xuICAgIHN3aXRjaCAodC50eXBlLm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIk51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwibGl0ZXJhbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IE51bWJlcihzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJCb29sZWFuXCI6IHtcbiAgICAgICAgICAgIHZhciBib29sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRydWVcIjogcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJGYWxzZVwiOiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGFnOiBcImxpdGVyYWxcIixcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYm9vbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIlZhcmlhYmxlTmFtZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImlkXCIsIG5hbWU6IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykgfTtcbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6IHtcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBuYW1lXG4gICAgICAgICAgICB2YXIgbmFtZV80ID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgQXJnTGlzdFxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIEZvY3VzIG9wZW4gcGFyZW5cbiAgICAgICAgICAgIHZhciBhcmdMaXN0ID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICBhcmdMaXN0LnB1c2godHJhdmVyc2VFeHByKHMsIHQpKTtcbiAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uICwgb3IgKVxuICAgICAgICAgICAgfSB3aGlsZSAocy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSAhPSBcIilcIik7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJjYWxsXCIsIG5hbWU6IG5hbWVfNCwgYXJndW1lbnRzOiBhcmdMaXN0IH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIHZhciB1bmlvcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6IHJldHVybiBcIm5lZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm90XCI6IHJldHVybiBcIm5vdFwiO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkIGF0IFwiICsgdC5mcm9tICsgXCIgXCIgKyB0LnRvICsgXCI6IFwiICsgcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICAgIHZhciBhcmcgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcInVuaW9wXCIsIGFyZzogYXJnLCB1bmlvcDogdW5pb3AgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIHZhciBhcmcxID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIGJpbm9wID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgICAgICB2YXIgaW50T3BzID0gW1wiK1wiLCBcIi1cIiwgXCIqXCIsIFwiLy9cIiwgXCIlXCIsIFwiPT1cIiwgXCIhPVwiLCBcIj49XCIsIFwiPD1cIiwgXCI+XCIsIFwiPFwiXTtcbiAgICAgICAgICAgICAgICBpZiAoaW50T3BzLmluY2x1ZGVzKHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCBhdCBcIiArIHQuZnJvbSArIFwiIFwiICsgdC50byArIFwiOiBcIiArIHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgYXJnMiA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiYmlub3BcIiwgYXJnMTogYXJnMSwgYXJnMjogYXJnMiwgYmlub3A6IGJpbm9wIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnRyYXZlcnNlRXhwciA9IHRyYXZlcnNlRXhwcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50eXBlQ2hlY2tQcm9ncmFtID0gdm9pZCAwO1xudmFyIGFzdF8xID0gcmVxdWlyZShcIi4vYXN0XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLy8gRklYTUU6IHRoZSByaHMgb2YgdmFyaWFibGUgZGVjbGFyYXRpb24gY2FuIG9ubHkgYmUgbGl0ZXJhbHNcbmZ1bmN0aW9uIHR5cGVDaGVja1Byb2dyYW0ocHJvZykge1xuICAgIHR5cGVDaGVjayhwcm9nLCBuZXcgTWFwLCBuZXcgTWFwLCBcIm5vbmVcIik7XG59XG5leHBvcnRzLnR5cGVDaGVja1Byb2dyYW0gPSB0eXBlQ2hlY2tQcm9ncmFtO1xuLy8gQSBmYWlsdXJlIGluIHRoZSB0eXBlY2hlY2tpbmcgcHJvY2VzcyBsZWFkcyB0byBhbiB1bnJlY292ZXJhYmxlIGZhaWx1cmUgc28gd2Vcbi8vIG1pZ2h0IGFzIHdlbGwgdGhyb3cgYW4gZXJyb3IgYW5kIGV4aXQuIEEgcGFzcyBhdCB0aGlzIHN0YWdlIGhvd2V2ZXIgZG9lcyBub3Rcbi8vIHdhcnJhbnQgYW55IGFjdGlvbi5cbmZ1bmN0aW9uIHR5cGVDaGVjayhzdG10cywgb3V0ZXJWYXJTY29wZSwgb3V0ZXJGdW5jU2NvcGUsIHJldFR5cGUpIHtcbiAgICAvLyBBbGwgdGhlIGZ1bmN0aW9uIGRlZmluaXRpb25zIGFuZCB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgbXVzdCBiZSBhdCB0aGUgdG9wXG4gICAgLy8gb2YgdGhlIHNjb3BlLiBUaGUgb3JkZXIgb2YgZGVmcyBvciBkZWNscyBkb2Vzbid0IG1hdHRlci0tdGhleSBjYW4gZXZlbiBiZVxuICAgIC8vIGludGVyd2VhdmVkLCBhcyBsb25nIGFzIG5vIGNvbXB1dGF0aW9uIGhhcHBlbnMgYmVmb3JlIHRoZW4gZW5kIG9mIHRoaXNcbiAgICAvLyBibG9jay4gV2UnbGwgY2FsbCB0aGlzIHRoZSBwcmVhbWJsZS5cbiAgICAvLyBHZXQgdGhlIHN0YXRlbWVudCBudW1iZXIgd2hlcmUgdGhlIHByZWFtYmxlIGVuZHNcbiAgICB2YXIgbiA9IGFzdF8xLmNvdW50RGVmRGVjbFN0bXRzKHN0bXRzKTtcbiAgICAvLyBleHRyYWN0IHRoZSBhc3NpZ25tZW50IGFuZCBkZWZpbml0aW9uIHN0YXRlbWVudHNcbiAgICB2YXIgZGVjbEJsb2NrID0gc3RtdHMuc2xpY2UoMCwgbikuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRhZyA9PSBcImFzc2lnblwiOyB9KTtcbiAgICB2YXIgZGVmQmxvY2sgPSBzdG10cy5zbGljZSgwLCBuKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudGFnID09IFwiZGVmaW5lXCI7IH0pO1xuICAgIC8vIGNoZWNrIGZvciBkZXBsaWNhdGUgZGVjbGFyYXRpb24gb2YgaWRlbnRpZmllcnNcbiAgICB2YXIgaWRlbnRzID0gbmV3IE1hcDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc3RtdHMuc2xpY2UoMCwgbik7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzdG10ID0gX2FbX2ldO1xuICAgICAgICBpZiAoc3RtdC50YWcgIT0gXCJhc3NpZ25cIiAmJiBzdG10LnRhZyAhPSBcImRlZmluZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21waWxlciBlcnJvci4gQ2hlY2sgY29kZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoaWRlbnRzLmhhcyhzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuRHVwbGljYXRlRGVjbGFyYXRpb24oc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlkZW50cy5zZXQoc3RtdC5uYW1lLCBzdG10KTtcbiAgICB9XG4gICAgLy8gS2VlcCBhIHRhYmxlIG9mIHZhcmlhYmxlcyBhbmQgdGhlaXIgdHlwZXNcbiAgICAvLyBOb3RlOiBkZWZpbml0aW9ucyBpbiB0aGUgY3VycmVudCBzY29wZSB3aWxsIG92ZXJ3cml0ZSBkZWZpbml0aW9ucyBmcm9tXG4gICAgLy8gb3V0ZXJzY29wZSBpZiB0aGVyZSBhcmUgY29uZmxpY3RzXG4gICAgdmFyIHZhclNjb3BlID0gZGVjbEJsb2NrLm1hcChmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICBpZiAoc3RtdC50YWcgIT0gXCJhc3NpZ25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcGlsZXIgZXJyb3IuIENoZWNrIGNvZGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHN0bXQudHlwZV8gPT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEFWYXJpYWJsZShzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAvLyBNZXJnZSB3aXRoIG91dGVyIHNjb3BlLiBPdmVyd3JpdGUgdHlwZSBkZWNsYXJhdGlvbnMgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChtYXAsIHQpIHtcbiAgICAgICAgbWFwLnNldCh0Lm5hbWUsIHQudHlwZV8pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIG91dGVyVmFyU2NvcGUpO1xuICAgIC8vIEtlZXAgYSB0YWJsZSBvZiBhbGwgY3VycmVudGx5IGRlZmluZWQgZnVuY3Rpb25zLiBPdmVyd3JpdGUgZGVmaW5pdGlvbnMgZnJvbVxuICAgIC8vIHRoZSBvdXRlciBzY29wZSBpZiBuZWNlc3NhcnlcbiAgICB2YXIgZnVuY1Njb3BlID0gZGVmQmxvY2sucmVkdWNlKGZ1bmN0aW9uIChtYXAsIHQpIHtcbiAgICAgICAgaWYgKHQudGFnICE9IFwiZGVmaW5lXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIGVycm9yLiBDaGVjayBjb2RlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHZhciBmdHlwZSA9IHtcbiAgICAgICAgICAgIHBhcmFtZXRlclR5cGVzOiB0LnBhcmFtZXRlcnMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnR5cGVfOyB9KSxcbiAgICAgICAgICAgIG91dHB1dFR5cGU6IHQub3V0cHV0VHlwZVxuICAgICAgICB9O1xuICAgICAgICBtYXAuc2V0KHQubmFtZSwgZnR5cGUpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIG91dGVyRnVuY1Njb3BlKTtcbiAgICAvLyBUeXBlY2hlY2sgZWFjaCBzdGF0ZW1lbnRcbiAgICBmb3IgKHZhciBfYiA9IDAsIHN0bXRzXzEgPSBzdG10czsgX2IgPCBzdG10c18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICB2YXIgc3RtdCA9IHN0bXRzXzFbX2JdO1xuICAgICAgICBpZiAoc3RtdC50YWcgPT0gXCJhc3NpZ25cIikge1xuICAgICAgICAgICAgdmFyIHJoc1R5cGUgPSBpbmZlckV4cHJUeXBlKHN0bXQudmFsdWUsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgdmFyIGxoc1R5cGUgPSB2YXJTY29wZS5nZXQoc3RtdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChyaHNUeXBlICE9IGxoc1R5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuR2VuZXJhbFR5cGVFcnJvcihsaHNUeXBlLCByaHNUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LnRhZyA9PSBcImV4cHJcIikge1xuICAgICAgICAgICAgY2hlY2tFeHByVHlwZShzdG10LmV4cHIsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0bXQudGFnID09IFwiZGVmaW5lXCIpIHtcbiAgICAgICAgICAgIC8vIENob2NvUHkgZnVuY3Rpb25zIGRvbid0IGNhcHR1cmUgdmFyaWFibGVzLiBSZXNldCBzY29wZSB0byBiZSB0aGVcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICB2YXIgdmFyU2NvcGVfMSA9IHN0bXQucGFyYW1ldGVycy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgcCkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQocC5uYW1lLCBwLnR5cGVfKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgfSwgbmV3IE1hcCk7XG4gICAgICAgICAgICAvLyBjaGVjayBzdGF0ZW1lbnRzIGluIHRoZSBib2R5LCBpbmNsdWRpbmcgbWF0Y2hpbmcgcmV0dXJuIHR5cGVzIHRvIHRoZVxuICAgICAgICAgICAgLy8gc3RhdGVkIG91dHB1dCB0eXBlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHR5cGVDaGVjayhzdG10LmJvZHksIHZhclNjb3BlXzEsIGZ1bmNTY29wZSwgc3RtdC5vdXRwdXRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgZXJyb3JzXzEuTm90QVZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJTY29wZV8xLmhhcyhlcnIudmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3REZWNsYXJlZEluU2NvcGUoZXJyLnZhck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrUmV0dXJuVHlwZShzdG10Lm5hbWUsIHN0bXQuYm9keSwgdmFyU2NvcGVfMSwgZnVuY1Njb3BlLCBzdG10Lm91dHB1dFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0bXQudGFnID09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIHZhciB0ID0gaW5mZXJFeHByVHlwZShzdG10LnZhbHVlLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIGlmIChyZXRUeXBlICE9IHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuR2VuZXJhbFR5cGVFcnJvcihyZXRUeXBlLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LnRhZyA9PSBcImlmXCIpIHtcbiAgICAgICAgICAgIHZhciB0ID0gaW5mZXJFeHByVHlwZShzdG10LnByZWQsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgaWYgKHQgIT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZUNoZWNrKHN0bXQuYm9keTEsIHZhclNjb3BlLCBmdW5jU2NvcGUsIHJldFR5cGUpO1xuICAgICAgICAgICAgdHlwZUNoZWNrKHN0bXQuYm9keTIsIHZhclNjb3BlLCBmdW5jU2NvcGUsIHJldFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0bXQudGFnID09IFwid2hpbGVcIikge1xuICAgICAgICAgICAgdmFyIHQgPSBpbmZlckV4cHJUeXBlKHN0bXQucHJlZCwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICBpZiAodCAhPSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25kaXRpb25hbEV4cHJUeXBlRXJyb3IodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlQ2hlY2soc3RtdC5ib2R5LCB2YXJTY29wZSwgZnVuY1Njb3BlLCByZXRUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG5mdW5jdGlvbiBjaGVja1JldHVyblR5cGUobmFtZSwgc3RtdHMsIHZhclNjb3BlLCBmdW5jU2NvcGUsIHJldFR5cGUpIHtcbiAgICB2YXIgY2hlY2tMYXN0U3RtdFJldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN0bXRzLmxlbmd0aCA9PSAwIHNob3VsZCBiZSBjYXVnaHQgYmUgYSBQYXJzZUVycm9yXG4gICAgICAgIHZhciBsYXN0U3RtdCA9IHN0bXRzW3N0bXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFN0bXQudGFnID09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIHZhciB0ID0gaW5mZXJFeHByVHlwZShsYXN0U3RtdC52YWx1ZSwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICBpZiAocmV0VHlwZSAhPSB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkdlbmVyYWxUeXBlRXJyb3IodCwgcmV0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG5vIHJldHVybiBzaW5jZSBcInJldHVyblwiIGlzIGFsd2F5cyB0aGUgbGFzdCBzdGF0ZW1lbnRcbiAgICAgICAgICAgIGlmIChyZXRUeXBlICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk1pc3NpbmdSZXR1cm4obmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIG5vIG5lc3RlZCBzdGF0ZW1lbnRzIChhc2lkZSBmcm9tIGZ1bmMgZGVmcywgd2hpY2ggZG9uJ3QgY291bnQpXG4gICAgaWYgKHN0bXRzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRhZyAhPSBcImlmXCIgJiYgcy50YWcgIT0gXCJ3aGlsZVwiOyB9KSkge1xuICAgICAgICBjaGVja0xhc3RTdG10UmV0VHlwZSgpO1xuICAgICAgICAvLyBUaGVyZSBleGlzdHMgYXQgbGVhc3Qgb25lIGlmIG9yIHdoaWxlIHN0YXRlbWVudCBpbiB0aGUgYXJyYXlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBjaGVjayBuZXN0ZWQgc3RhdGVtZW50c1xuICAgICAgICAgICAgdmFyIHN0bXRHcm91cHMgPSBzdG10cy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudGFnID09IFwiaWZcIiB8fCBzLnRhZyA9PSBcIndoaWxlXCI7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocy50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3MuYm9keTEsIHMuYm9keTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcy5ib2R5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0bXRHcm91cHNfMSA9IHN0bXRHcm91cHM7IF9pIDwgc3RtdEdyb3Vwc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gc3RtdEdyb3Vwc18xW19pXTtcbiAgICAgICAgICAgICAgICBjaGVja1JldHVyblR5cGUobmFtZSwgcywgdmFyU2NvcGUsIGZ1bmNTY29wZSwgcmV0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGVycm9yc18xLk1pc3NpbmdSZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBjaGVja0xhc3RTdG10UmV0VHlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tFeHByVHlwZShleHByLCB2YXJTY29wZSwgZnVuY1Njb3BlKSB7XG4gICAgLy8gbGV2ZXJhZ2UgdGhlIHR5cGUgY2hla2NpbmcgY29kZSBpbiB0aGUgaW5mZXJlbmNlIGFsZ29yaXRobVxuICAgIGluZmVyRXhwclR5cGUoZXhwciwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG59XG5mdW5jdGlvbiBpbmZlckV4cHJUeXBlKGV4cHIsIHZhclNjb3BlLCBmdW5jU2NvcGUpIHtcbiAgICBzd2l0Y2ggKGV4cHIudGFnKSB7XG4gICAgICAgIGNhc2UgXCJsaXRlcmFsXCI6IHtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gZXhwci52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobGl0ZXJhbC50YWcgPT0gXCJudW1iZXJcIikgPyBcImludFwiIDogbGl0ZXJhbC50YWc7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImlkXCI6IHJldHVybiB2YXJTY29wZS5nZXQoZXhwci5uYW1lKTtcbiAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgaWYgKGZ1bmNTY29wZS5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBmdHlwZSA9IGZ1bmNTY29wZS5nZXQoZXhwci5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBwYXJhbWV0ZXIgdHlwZXNcbiAgICAgICAgICAgICAgICB2YXIgemlwcGVkID0gZnR5cGUucGFyYW1ldGVyVHlwZXMubWFwKGZ1bmN0aW9uIChrLCBpKSB7IHJldHVybiBbaSwgaywgZXhwci5hcmd1bWVudHNbaV1dOyB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHppcHBlZF8xID0gemlwcGVkOyBfaSA8IHppcHBlZF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHVwbGUgPSB6aXBwZWRfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbU4gPSB0dXBsZVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gdHVwbGVbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0MiA9IGluZmVyRXhwclR5cGUodHVwbGVbMl0sIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodDEgIT0gdDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5GdW5jQ2FsbFR5cEVycm9yKHQxLCB0MiwgcGFyYW1OKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnR5cGUub3V0cHV0VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RBRnVuY3Rpb25PckNsYXNzKGV4cHIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaW9wXCI6IHtcbiAgICAgICAgICAgIHZhciB0ID0gaW5mZXJFeHByVHlwZShleHByLmFyZywgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIudW5pb3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibm90XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgIT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbmlhcnlPcFR5cGVFcnJvcihcIm5vdFwiLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJvb2xcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwibmVnXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgIT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuaWFyeU9wVHlwZUVycm9yKFwibmVnXCIsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJpbm9wXCI6IHtcbiAgICAgICAgICAgIHZhciB0MSA9IGluZmVyRXhwclR5cGUoZXhwci5hcmcxLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHZhciB0MiA9IGluZmVyRXhwclR5cGUoZXhwci5hcmcyLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHZhciBpbnRPcHMgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvL1wiLCBcIiVcIiwgXCI9PVwiLCBcIiE9XCIsIFwiPj1cIiwgXCI8PVwiLCBcIj5cIiwgXCI8XCJdO1xuICAgICAgICAgICAgaWYgKGludE9wcy5pbmNsdWRlcyhleHByLmJpbm9wKSkge1xuICAgICAgICAgICAgICAgIGlmICh0MSAhPSBcImludFwiIHx8IHQyICE9IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gZXhwci5iaW5vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkJpbmFyeU9wVHlwZUVycm9yKG9wLCB0MSwgdDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvL1wiLCBcIiVcIl0pLmluY2x1ZGVzKGV4cHIuYmlub3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJvb2xcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGUgXCJpc1wiIG9wZXJhdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodDEgPT0gXCJpbnRcIiB8fCB0MSA9PSBcImJvb2xcIiB8fCB0MiA9PSBcImludFwiIHx8IHQyID09IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5CaW5hcnlPcFR5cGVFcnJvcihcImlzXCIsIHQxLCB0Mik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJib29sXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9jb21waWxlclwiKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJ1bkJ1dHRvbiwgdXNlckNvZGU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBydW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJ1blwiKTtcbiAgICAgICAgdXNlckNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVzZXItY29kZVwiKTtcbiAgICAgICAgcnVuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb2dyYW0sIHdhdCwgY29kZSwgb3V0cHV0LCByZXN1bHQsIGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0gPSB1c2VyQ29kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdCA9IGNvbXBpbGVyXzEuY29tcGlsZShwcm9ncmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdlbmVyYXRlZC1jb2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZS50ZXh0Q29udGVudCA9IHdhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0cHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29tcGlsZXJfMS5ydW4od2F0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50ZXh0Q29udGVudCA9IFN0cmluZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6IGJsYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50ZXh0Q29udGVudCA9IFN0cmluZyhlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6IHJlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgfSk7XG59KTsgfSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHdhYnQ7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL3dlYnN0YXJ0LnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==