/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lezer-python/dist/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/lezer-python/dist/index.cjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezer = __webpack_require__(/*! lezer */ "./node_modules/lezer/dist/index.cjs");

// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  printKeyword = 1,
  newline = 164,
  newlineBracketed = 165,
  newlineEmpty = 166,
  eof = 167,
  continueBody = 168,
  endBody = 169,
  ParenthesizedExpression = 21,
  TupleExpression = 48,
  ComprehensionExpression = 49,
  ArrayExpression = 53,
  ArrayComprehensionExpression = 56,
  DictionaryExpression = 57,
  DictionaryComprehensionExpression = 60,
  SetExpression = 61,
  SetComprehensionExpression = 62,
  compoundStatement = 231;

const newline$1 = 10, carriageReturn = 13, space = 32, tab = 9, hash = 35, parenOpen = 40, dot = 46;

const bracketed = [
  ParenthesizedExpression, TupleExpression, ComprehensionExpression, ArrayExpression, ArrayComprehensionExpression,
  DictionaryExpression, DictionaryComprehensionExpression, SetExpression, SetComprehensionExpression
], parentStatement = [compoundStatement];

const caches = new WeakMap;

// Per-input-stream indentation cache. `prev` maps indentation depths
// to the last position at which a statement indented to that depth
// was seen. There's an extra set of slots for the _current_
// indentation, since that needs to be available alongside a previous
// indentation position at the same level.
class Cache {
  constructor() {
    this.last = this.lastIndent = -1;
    this.prev = [];
  }

  get(pos) {
    if (this.last == pos) return this.lastIndent
    for (let i = 0; i < this.prev.length; i++) if (this.prev[i] == pos) return i
    return -1
  }

  set(pos, indent) {
    if (pos == this.last) return
    if (this.last > -1) this.setPrev(this.last, this.lastIndent);
    this.last = pos;
    this.lastIndent = indent;
  }

  setPrev(pos, indent) {
    while (this.prev.length < indent) this.prev.push(-1);
    this.prev[indent] = pos;
  }

  static for(input) {
    let found = caches.get(input);
    if (!found) caches.set(input, found = new Cache);
    return found
  }
}

const maxIndent = 50;

function getIndent(input, pos) {
  let cache = Cache.for(input), found = cache.get(pos);
  if (found > -1) return found

  // This shouldn't happen very often (or even at all) in normal
  // parsing, since the indentations are stored by the newline
  // tokenizer ahead of time. But it's kind of tricky to prove whether
  // that always happens in incremental parsing scenarios, so here's a
  // fallback anyway.
  let before = input.read(Math.max(0, pos - maxIndent), pos);
  let count = 0, start = before.length;
  for (; start > 0; start--) {
    let next = before.charCodeAt(start - 1);
    if (next == newline$1 || next == carriageReturn) break
  }
  for (let i = start; i < before.length; i++) {
    let ch = before.charCodeAt(i);
    if (ch == space) count++;
    else if (ch == tab) count += 8 - (count % 8);
    else break
  }
  cache.setPrev(pos, count);
  return count
}

const newlines = new lezer.ExternalTokenizer((input, token, stack) => {
  let next = input.get(token.start);
  if (next < 0) {
    token.accept(eof, token.start);
    return
  }
  if (next != newline$1 && next != carriageReturn) return
  if (stack.startOf(bracketed) != null) {
    token.accept(newlineBracketed, token.start + 1);
    return
  }
  let scan = token.start + 1, indent = 0;
  for (; scan < input.length; scan++) {
    let ch = input.get(scan);
    if (ch == space) indent++;
    else if (ch == tab) indent += 8 - (indent % 8);
    else if (ch == newline$1 || indent == carriageReturn || ch == hash) {
      token.accept(newlineEmpty, token.start + 1);
      return
    } else {
      break
    }
  }
  token.accept(newline, token.start + 1);
  Cache.for(input).set(scan, indent);
}, {contextual: true, fallback: true});

const bodyContinue = new lezer.ExternalTokenizer((input, token, stack) => {
  let parent = stack.startOf(parentStatement);
  let parentIndent = parent == null ? 0 : getIndent(input, parent);
  let indentHere = getIndent(input, token.start);
  token.accept(indentHere <= parentIndent ? endBody : continueBody, token.start);
}, {contextual: true, fallback: true});

const legacyPrint = new lezer.ExternalTokenizer((input, token) => {
  let pos = token.start;
  for (let print = "print", i = 0; i < print.length; i++, pos++)
    if (input.get(pos) != print.charCodeAt(i)) return
  let end = pos;
  if (/\w/.test(String.fromCharCode(input.get(pos)))) return
  for (;; pos++) {
    let next = input.get(pos);
    if (next == space || next == tab) continue
    if (next != parenOpen && next != dot && next != newline$1 && next != carriageReturn && next != hash)
      token.accept(printKeyword, end);
    return
  }
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,await:40, or:48, and:50, in:54, not:56, is:58, if:64, else:66, lambda:70, self:74, yield:90, from:92, async:100, for:102, None:154, True:156, False:156, del:170, pass:174, break:178, continue:182, return:186, raise:194, import:198, as:200, global:204, nonlocal:206, assert:210, elif:220, while:224, try:230, except:232, finally:234, with:238, def:242, class:252};
const parser = lezer.Parser.deserialize({
  version: 13,
  states: "!;[O`Q!LTOOO%fQ!LUO'#GcOOQ!LQ'#Cm'#CmOOQ!LQ'#Cn'#CnO'UQ!LSO'#ClO(zQ!LUO'#GbOOQ!LQ'#Gc'#GcOOQ!LQ'#DS'#DSOOQ!LQ'#Gb'#GbO)hQ!LSO'#CqO)xQ!LSO'#DcO*YQ!LSO'#DgOOQ!LQ'#Dt'#DtO*mOWO'#DtO*uO`O'#DtO*}OpO'#DuO+YO!bO'#DuO+eO#tO'#DuO+pO&jO'#DuO-rQ!LUO'#GSOOQ!LQ'#GS'#GSO'UQ!LSO'#GRO/UQ!LUO'#GROOQ!LQ'#E^'#E^O/mQ!LSO'#E_OOQ!LQ'#GQ'#GQO/wQ!LSO'#GPOOQ&FV'#GP'#GPO0SQ!LSO'#FQOOQ!LQ'#Ft'#FtO0XQ!LSO'#FPOOQ&FV'#H]'#H]OOQ&FV'#GO'#GOOOQ!LR'#FS'#FSQ`Q!LTOOO'UQ!LSO'#CoO0gQ!LSO'#CzO0nQ!LSO'#DOO1PQ!LSO'#GgO1aQ!LUO'#ERO'UQ!LSO'#ESOOQ!LQ'#EU'#EUOOQ!LQ'#EW'#EWOOQ!LQ'#EY'#EYO1uQ!LSO'#E[O2]Q!LSO'#E`O0SQ!LSO'#EbO2pQ!LUO'#EbO0SQ!LSO'#EeO/mQ!LSO'#EhO/mQ!LSO'#ElO/mQ!LSO'#EoO2{Q!LSO'#EqO3SQ!LSO'#EvO3_Q!LSO'#ErO/mQ!LSO'#EvO0SQ!LSO'#ExO0SQ!LSO'#E}OOQ!LQ'#Cc'#CcOOQ!LQ'#Cd'#CdOOQ!LQ'#Ce'#CeOOQ!LQ'#Cf'#CfOOQ!LQ'#Cg'#CgOOQ!LQ'#Ch'#ChOOQ!LQ'#Cj'#CjO'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O'UQ!LSO,58|O3dQ!LSO'#DnOOQ!LQ,5:X,5:XO3wQ!LSO,5:[O4UQ#)WO,5:[O4ZQ!LUO,59WO0gQ!LSO,59_O0gQ!LSO,59_O0gQ!LSO,59_O6yQ!LSO,59_O7OQ!LSO,59_O7VQ!LSO,59gO7^Q!LSO'#GbO8dQ!LSO'#GaOOQ!LQ'#Ga'#GaOOQ!LQ'#DY'#DYO8{Q!LSO,59]O'UQ!LSO,59]O9ZQ!LSO,59]O9`Q!LSO,5:QO'UQ!LSO,5:QOOQ!LQ,59},59}O9nQ!LSO,59}O9sQ!LSO,5:WO'UQ!LSO,5:WO'UQ!LSO,5:UOOQ!LQ,5:R,5:RO:UQ!LSO,5:RO:ZQ!LSO,5:VOOOO'#F]'#F]O:`OWO,5:`OOQ!LQ,5:`,5:`OOOO'#F^'#F^O:hO`O,5:`O:pQ!LSO'#DvOOOO'#F_'#F_O;QOpO,5:aOOQ!LQ,5:a,5:aOOOO'#Fb'#FbO;]O!bO,5:aOOOO'#Fc'#FcO;hO#tO,5:aOOOO'#Fd'#FdO;sO&jO,5:aOOQ!LQ'#Fe'#FeO<OQ!LUO,5:eO>pQ!LUO,5<mO?ZQ#4^O'#FfO?}Q!LUO,5<mOOQ!LQ,5:y,5:yO@fQ!LTO'#FmOAuQ!LSO,5;UOOQ&FV,5<k,5<kOBQQ!LUO'#HYOBiQ!LSO,5;lOOQ!LQ-E9r-E9rOOQ&FV,5;k,5;kO3YQ!LSO'#ExOOQ!LR-E9Q-E9QOBqQ!LUO,59ZODxQ!LUO,59fOEcQ!LSO'#GdOEnQ!LSO'#GdO0SQ!LSO'#GdOEyQ!LSO'#DQOFRQ!LSO,59jOFWQ!LSO'#GhO'UQ!LSO'#GhO/mQ!LSO,5=ROOQ!LQ,5=R,5=RO/mQ!LSO'#D}OOQ!LQ'#EO'#EOOFuQ!LSO'#FgOGVQ!LSO,58zOGeQ!LSO,58zO)kQ!LSO,5:kOGjQ!LUO'#GjOOQ!LQ,5:n,5:nOOQ!LQ,5:v,5:vOG}Q!LSO,5:zOH`Q!LSO,5:|OOQ!LQ'#Fj'#FjOHnQ!LUO,5:|OH|Q!LSO,5:|OIRQ!LSO'#H[OOQ!LQ,5;P,5;POIaQ!LSO'#HXOOQ!LQ,5;S,5;SO3_Q!LSO,5;WO3_Q!LSO,5;ZOIrQ!LUO'#H^O'UQ!LSO'#H^OI|Q!LSO,5;]O2{Q!LSO,5;]O/mQ!LSO,5;bO0SQ!LSO,5;dOJRQ!LTO'#EmOK[Q&FXO,5;^ONsQ!LSO'#H_O3_Q!LSO,5;bO! OQ!LSO,5;dO! TQ!LSO,5;iO!#xQ!LUO1G.hO!$PQ!LUO1G.hO!&pQ!LUO1G.hO!&zQ!LUO1G.hO!)eQ!LUO1G.hO!)xQ!LUO1G.hO!*]Q!LUO1G.hO!,{Q!LSO'#GpO!-ZQ!LUO'#GSO/mQ!LSO'#GpO!-eQ!LSO'#GoOOQ!LQ,5:Y,5:YO!-mQ!LSO,5:YO!-rQ!LSO'#GqO!-}Q!LSO'#GqO!.bQ!LSO1G/vOOQ!LQ'#Dr'#DrOOQ!LQ1G/v1G/vOOQ!LQ1G.y1G.yO!/bQ!LUO1G.yO!/iQ!LUO1G.yO0gQ!LSO1G.yO!0UQ!LSO1G/ROOQ!LQ'#DX'#DXO/mQ!LSO,59rOOQ!LQ1G.w1G.wO!0]Q!LSO1G/dO!0mQ!LSO1G/dO!0uQ!LSO1G/eO'UQ!LSO'#GiO!0zQ!LSO'#GiO!1PQ!LUO1G.wO!1aQ!LSO,59fO!2gQ!LSO'#FXO!2zQ!LSO,5=XO!3SQ!LSO1G/lO!3XQ!LUO1G/lOOQ!LQ1G/i1G/iO!3iQ!LSO'#FUO!4cQ!LSO,5=SO/mQ!LSO1G/pO!5QQ!LSO1G/rO!5VQ!LUO1G/rO!5gQ!LUO1G/pOOQ!LQ1G/m1G/mOOQ!LQ1G/q1G/qOOOO-E9Z-E9ZOOQ!LQ1G/z1G/zOOOO-E9[-E9[O!5wQ!LSO'#G|O/mQ!LSO'#G|O!6VQ!LSO,5:bOOOO-E9]-E9]OOQ!LQ1G/{1G/{OOOO-E9`-E9`OOOO-E9a-E9aOOOO-E9b-E9bOOQ!LQ-E9c-E9cO!6bQ!LUO1G2XO'UQ!LSO,5<QOOQ!LQ,5<Q,5<QOOQ!LQ-E9d-E9dOOQ!LQ,5<X,5<XOOQ!LQ-E9k-E9kOOQ&FV1G0p1G0pO0SQ!LSO'#FiO!6yQ!LUO,5=tOOQ!LQ1G1W1G1WO!7bQ!LSO1G1WOOQ!LQ'#DT'#DTO/mQ!LSO,5=OOOQ!LQ,5=O,5=OO!7gQ!LSO'#FTO!7uQ!LSO,59lO!7}Q!LSO1G/UO!8XQ!LUO,5=SOOQ!LQ1G2m1G2mOOQ!LQ,5:i,5:iO!8xQ!LSO'#GROOQ!LQ,5<R,5<ROOQ!LQ-E9e-E9eO!9ZQ!LSO1G.fOOQ!LQ1G0V1G0VO!9iQ!LSO'#FWO!9|Q!LSO,5=UO/mQ!LSO1G0fO/mQ!LSO1G0fO0SQ!LSO1G0hOOQ!LQ-E9h-E9hO!:_Q!LSO1G0hO!:jQ!LSO1G0hO!:oQ!LSO'#FlO!;QQ!LSO,5=vO!;`Q!LSO'#FhO!;yQ!LSO,5=sO!<[Q&FXO1G0rO!?pQ&FXO1G0uO!CRQ!LSO'#FpO!C`Q!LSO,5=xO!ChQ!LUO,5=xO/mQ!LSO1G0wO!CrQ!LSO1G0wO3_Q!LSO1G0|O! OQ!LSO1G1OOOQ&FV,5;X,5;XO!CwQ!LTO,5;XO!EjQ&FXO1G0xO!IRQ!LSO'#FqO3_Q!LSO1G0xO3_Q!LSO1G0xO!I`Q!LSO'#FrO!IpQ!LSO,5=yO0SQ!LSO,5=yOOQ&FV1G0|1G0|O!JZQ!LSO'#EzO!JbQ#)WO1G1OOOQ&FV1G1T1G1TO3_Q!LSO1G1TOOQ!LQ,5=[,5=[OOQ!LQ'#Do'#DoO/mQ!LSO,5=[O!JjQ!LSO'#FZO!KQQ!LSO,5=ZOOQ!LQ1G/t1G/tO!KYQ!LSO'#F[O!KmQ!LSO,5=]O!KuQ!LSO,5=]O!LYQ!LSO,5=]O!LjQ!LSO,5=]OOQ!LQ7+%b7+%bOOQ!LQ7+$e7+$eO!7}Q!LSO7+$mO!N]Q!LSO1G.yO!NdQ!LSO1G.yOOQ!LQ1G/^1G/^OOQ!LQ,5;q,5;qO'UQ!LSO,5;qOOQ!LQ7+%O7+%OO!NkQ!LSO7+%OOOQ!LQ-E9T-E9TOOQ!LQ7+%P7+%PO!N{Q!LSO,5=TO'UQ!LSO,5=TOOQ!LQ7+$c7+$cO# QQ!LSO7+%OO# YQ!LSO7+%POOQ!LQ,5;s,5;sO'UQ!LSO,5;sOOQ!LQ-E9V-E9VOOQ!LQ7+%W7+%WO# _Q!LSO1G2sO# gQ!LSO7+%WOOQ!LQ,5;p,5;pO'UQ!LSO,5;pOOQ!LQ-E9S-E9SO# lQ!LSO7+%[OOQ!LQ7+%^7+%^O# zQ!LSO1G2nO#!iQ!LSO7+%^O#!nQ!LSO'#FYO##RQ!LSO1G2tO##ZQ!LSO7+%[O##`Q!LSO'#F`O##yQ!LSO,5=hO##yQ!LSO,5=hO#$XOMhO'#DxO#$dOQO'#G}OOOO1G/|1G/|O#$iQ!LSO1G/|O#$qQ!LUO1G1lOOQ!LQ,5<T,5<TOOQ!LQ-E9g-E9gOOQ!LQ7+&r7+&rOOQ!LQ1G2j1G2jOOQ!LQ,5;o,5;oOOQ!LQ-E9R-E9ROOQ!LQ7+$p7+$pO#%[Q!LSO'#FfO#%xQ!LSO,5<mO#&ZQ!LUO,5;rOOQ!LQ-E9U-E9UOOQ!LQ7+&Q7+&QO#&nQ!LSO7+&QOOQ!LQ7+&S7+&SO#&|Q!LSO'#HZO0SQ!LSO7+&SO#'bQ!LSO7+&SOOQ!LQ,5<W,5<WOOQ!LQ-E9j-E9jOOQ!LQ,5<S,5<SOOQ!LQ-E9f-E9fO#'mQ&FXO7+&^O!IRQ!LSO'#FoO3_Q!LSO7+&^O3_Q!LSO7+&aO#+RQ!LUO,5<[O'UQ!LSO,5<[OOQ!LQ-E9n-E9nO#+]Q!LSO1G3dO3_Q!LSO7+&cO/mQ!LSO7+&cOOQ&FV7+&h7+&hO!JbQ#)WO7+&jO#+eQ&FWO1G0sOOQ&FV-E9o-E9oO3_Q!LSO7+&dO3_Q!LSO7+&dOOQ&FV,5<],5<]O#+pQ!LSO,5<]OOQ&FV7+&d7+&dO#+{Q&FXO7+&dO#/^Q!LSO,5<^OOQ!LQ-E9p-E9pO#/iQ!LSO1G3eO#/qQ!LSO'#HaO#0PQ!LSO'#HaO0SQ!LSO'#HaOOQ!LQ'#Ha'#HaO#0[Q!LSO'#H`OOQ!LQ,5;f,5;fO#0dQ!LSO,5;fO/mQ!LSO'#E|OOQ&FV7+&j7+&jO3_Q!LSO7+&jOOQ&FV7+&o7+&oOOQ!LQ1G2v1G2vOOQ!LQ,5;u,5;uOOQ!LQ-E9X-E9XO#0iQ!LSO,5;vO#0tQ!LSO,5;vOOQ!LQ-E9Y-E9YO#1XQ!LSO1G2wO#1aQ!LSO1G2wO#1qQ!LSO1G2wO#1XQ!LSO1G2wOOQ!LQ<<HX<<HXO#1|Q!LUO1G1]OOQ!LQ<<Hj<<HjP#2WQ!LSO'#FVO7VQ!LSO1G2oO#2eQ!LSO1G2oO#2jQ!LSO<<HjOOQ!LQ<<Hk<<HkO#2zQ!LUO1G1_OOQ!LQ<<Hr<<HrO#3UQ!LUO1G1[O#3uQ!LSO7+(`O#3}Q!LSO<<HvOOQ!LQ<<Hx<<HxO#4SQ!LSO,5;tO'UQ!LSO,5;tOOQ!LQ-E9W-E9WOOQ!LQ<<Hv<<HvOOQ!LQ,5;z,5;zO/mQ!LSO,5;zOOQ!LQ-E9^-E9^O#4XQ!LSO1G3SOOOO'#Fa'#FaO#4gOMhO,5:dOOOO,5=i,5=iOOOO7+%h7+%hO#4rQ!LSO1G2XO/mQ!LSO<<IlO#5TQ!LSO'#FkO#5iQ!LSO,5=uO0SQ!LSO,5=uO#5zQ!LSO<<InOOQ!LQ<<In<<InO0SQ!LSO<<InOOQ&FV-E9m-E9mO3_Q!LSO<<IxOOQ&FV,5<Z,5<ZO3_Q!LSO,5<ZOOQ&FV<<Ix<<IxOOQ&FV<<I{<<I{O#6PQ!LUO1G1vO#6ZQ&FXO<<I}O3_Q!LSO<<I}OOQ&FV<<JU<<JUO3_Q!LSO<<JUO!CwQ!LTO'#FnO#9lQ&FWO7+&_OOQ&FV7+&_7+&_OOQ&FV<<JO<<JOO#9wQ&FXO<<JOOOQ&FV1G1w1G1wO0SQ!LSO1G1wO3_Q!LSO<<JOO0SQ!LSO1G1xO#=YQ!LSO7+)POOQ!LQ'#E{'#E{O/mQ!LSO,5={O#=bQ!LSO,5={OOQ!LQ,5={,5={O#=mQ!LSO'#FsO#=wQ!LSO,5=zOOQ!LQ1G1Q1G1QOOQ!LQ,5;h,5;hO#>PQ!LSO1G1bO#>dQ!LSO1G1bO#>tQ!LSO1G1bO#?PQ!LSO7+(cO#?PQ!LSO7+(cO#?XQ!LSO7+(cO#?iQ!LSO7+(ZO7VQ!LSO7+(ZOOQ!LQAN>UAN>UOOQ!LQAN>bAN>bO/mQ!LSO1G1`O#@SQ!LUO1G1`OOQ!LQ1G1f1G1fOOOO-E9_-E9_OOQ!LQAN?WAN?WO#@^Q!LSO,5<VOOQ!LQ-E9i-E9iO#@rQ!LSO1G3aOOQ!LQAN?YAN?YO#ATQ!LSOAN?YOOQ&FVAN?dAN?dOOQ&FV1G1u1G1uO3_Q!LSOAN?iO#AYQ&FXOAN?iOOQ&FVAN?pAN?pOOQ&FU,5<Y,5<YOOQ&FU-E9l-E9lOOQ&FV<<Iy<<IyO3_Q!LSOAN?jO3_Q!LSO7+'cOOQ&FVAN?jAN?jOOQ!LQ7+'d7+'dOOQ!LQ1G3g1G3gO/mQ!LSO1G3gOOQ!LQ,5<_,5<_OOQ!LQ-E9q-E9qO#DkQ!LSO7+&|O#D{Q!LSO7+&|OOQ!LQ7+&|7+&|O#EWQ!LSO<<K}O#EWQ!LSO<<K}O#E`Q!LSO'#GkOOQ!LQ<<Ku<<KuO#EjQ!LSO<<KuOOQ!LQ7+&z7+&zO0SQ!LSO1G1qO#FTQ!LSO7+({OOQ!LQG24tG24tOOQ&FVG25TG25TO3_Q!LSOG25TOOQ&FVG25UG25UOOQ&FV<<J}<<J}OOQ!LQ7+)R7+)ROOQ!LQ<<Jh<<JhO#FfQ!LSO<<JhO#FvQ!LSOANAiO#GOQ!LSO'#GlOOQ!LQ'#Gl'#GlO0nQ!LSO'#DbO#GiQ!LSO,5=VOOQ!LQANAaANAaOOQ!LQ7+']7+']OOQ&FVLD*oLD*oOOQ!LQAN@SAN@SO#HQQ!LSO,59|OOQ!LQ1G2q1G2qO#E`Q!LSO1G/hOOQ!LQ7+%S7+%SO7VQ!LSO'#CzO7VQ!LSO,59_O7VQ!LSO,59_O7VQ!LSO,59_O#HVQ!LUO,5<mO7VQ!LSO1G.yO/mQ!LSO1G/UO/mQ!LSO7+$mO'UQ!LSO'#GRO#HjQ!LSO,59_O#HoQ!LSO,59_O#HvQ!LSO,59jO#H{Q!LSO1G/RO0nQ!LSO'#DOO7VQ!LSO,59g",
  stateData: "#I^~O$qOS$lOS$kOSQOS~OPhOTeOdsOfXOltOp!SOsuOudO}vO!O!PO!S!VO!T!UO!WYO![ZO!gdO!ndO!odO!pdO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO$jqO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$w![O$x!]O$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aO~Oh%VXi%VXj%VXk%VXl%VXm%VXp%VXx%VXy%VX!t%VX#_%VX$j%VX$m%VX%X%VX!P%VX!S%VX!T%VX%Y%VX!X%VX!]%VX!O%VX#W%VXq%VX!k%VX~P$bOdsOfXOudO!WYO![ZO!gdO!ndO!odO!pdO$|QO$}QO%RRO%SVO%g[O%h]O%k^O%n_O%t`O%waO%ybO~Ox%UXy%UX#_%UX$j%UX$m%UX%X%UX~Oh!pOi!qOj!oOk!oOl!rOm!sOp!tO!t%UX~P(fOT!zOl,qOs-OO}vO~P'UOT!}Ol,qOs-OO!X#OO~P'UOT#RO_#SOl,qOs-OO!]#TO~P'UO%i#WO%j#YO~O%l#ZO%m#YO~O![#]O%o#^O%s#`O~O![#]O%u#aO%v#`O~O![#]O%j#`O%x#cO~O![#]O%m#`O%z#eO~OT$vX]$vX_$vXf$vXh$vXi$vXj$vXk$vXl$vXm$vXp$vXx$vX!W$vX!e$vX$w$vX$x$vX$y$vX$z$vX${$vX$|$vX$}$vX%O$vX%P$vX%Q$vX!P$vX!S$vX!T$vX~O%g[O%h]O%k^O%n_O%t`O%waO%ybOy$vX!t$vX#_$vX$j$vX$m$vX%X$vX%Y$vX!X$vX!]$vX!O$vX#W$vXq$vX!k$vX~P+{Ox#jOy$uX!t$uX#_$uX$j$uX$m$uX%X$uX~Ol,qOs-OO~P'UO#_#mO$j#oO$m#oO~O%SVO~O!S#tO#m!YO#r!ZO#ulO~OltO~P'UOT#yO_#zOu#xO%SVOytP~OT$OOl,qOs-OO!O$PO~P'UOy$RO!t$WO%X$SO#_!uX$j!uX$m!uX~OT$OOl,qOs-OO#_#OX$j#OX$m#OX~P'UOl,qOs-OO#_#SX$j#SX$m#SX~P'UO!e$^O!n$^O%SVO~OT$hO~P'UO!T$jO#k$kO#m$lO~Oy$mO~OT$|O_$|Ol,qOs-OO!P%OO~P'UOl,qOs-OOy%RO~P'UO%f%TO~O_!bOf!jO!W!lO!e!mOT`a]`ah`ai`aj`ak`al`am`ap`ax`ay`a!t`a#_`a$j`a$m`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%P`a%Q`a%X`a!P`a!S`a!T`a%Y`a!X`a!]`a!O`a#W`aq`a!k`a~Ok%YO~Ol%YO~P'UOl,qO~P'UOh,sOi,tOj,rOk,rOl,zOm,{Op-PO!P%UX!S%UX!T%UX%Y%UX!X%UX!]%UX!O%UX#W%UX!k%UX~P(fO%Y%[Ox%TX!P%TX!S%TX!T%TX!X%TXy%TX~Ox%_O!P%^O!S%cO!T%bO~O!P%^O~Ox%fO!S%cO!T%bO!X%aX~O!X%jO~Ox%kOy%mO!S%cO!T%bO!]%[X~O!]%qO~O!]%rO~O%i#WO%j%tO~O%l#ZO%m%tO~OT%wOl,qOs-OO}vO~P'UO![#]O%o#^O%s%zO~O![#]O%u#aO%v%zO~O![#]O%j%zO%x#cO~O![#]O%m%zO%z#eO~OT!ma]!ma_!maf!mah!mai!maj!mak!mal!mam!map!max!may!ma!W!ma!e!ma!t!ma#_!ma$j!ma$m!ma$w!ma$x!ma$y!ma$z!ma${!ma$|!ma$}!ma%O!ma%P!ma%Q!ma%X!ma!P!ma!S!ma!T!ma%Y!ma!X!ma!]!ma!O!ma#W!maq!ma!k!ma~P#yOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~P$bOT&QOltOsuOx$YXy$YX!t$YX#_$YX$j$YX$m$YX%X$YX~P'UOx#jOy$ua!t$ua#_$ua$j$ua$m$ua%X$ua~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#_$aX$j$aX$m$aX~P'UO#_#mO$j&VO$m&VO~O!e&WOf%|X$j%|X#W%|X#_%|X$m%|X#V%|X~Of!jO$j&YO~Ohcaicajcakcalcamcapcaxcayca!tca#_ca$jca$mca%Xca!Pca!Sca!Tca%Yca!Xca!]ca!Oca#Wcaqca!kca~P$bOpnaxnayna#_na$jna$mna%Xna~Oh!pOi!qOj!oOk!oOl!rOm!sO!tna~PDaO%X&[Ox%WXy%WX~O%SVOx%WXy%WX~Ox&_OytX~Oy&aO~Ox%kO#_%[X$j%[X$m%[X!P%[Xy%[X!]%[X!k%[X%X%[X~OT,yOl,qOs-OO}vO~P'UO%X$SO#_Sa$jSa$mSa~O%X$SO~Ox&jO#_%^X$j%^X$m%^Xk%^X~P$bOx&mO!O&lO#_#Sa$j#Sa$m#Sa~O#W&nO#_#Ua$j#Ua$m#Ua~O!e$^O!n$^O#V&pO%SVO~O#V&pO~Ox&rO#_&OX$j&OX$m&OX~Ox&tO#_%{X$j%{X$m%{Xy%{X~Ox&xOk&QX~P$bOk&{O~OPhOTeOltOsuO}vO!O!PO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO$j'QO~P'UOq'UO#h'SO#i'TOP#faT#fad#faf#fal#fap#fas#fau#fa}#fa!O#fa!S#fa!T#fa!W#fa![#fa!g#fa!n#fa!o#fa!p#fa!w#fa!y#fa!{#fa!}#fa#P#fa#T#fa#V#fa#Y#fa#Z#fa#]#fa#d#fa#g#fa#k#fa#m#fa#r#fa#u#fa$i#fa$j#fa$|#fa$}#fa%R#fa%S#fa%g#fa%h#fa%k#fa%n#fa%t#fa%w#fa%y#fa$m#fa$n#fa$o#fa~Ox'VO#W'XOy&RX~Of'ZO~Of!jOy$mO~OT!aO]!aO_!bOf!jO!W!lO!e!mO$y!^O$z!_O${!_O$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$x!]O~P! ]O$xUi~P! ]OT!aO]!aO_!bOf!jO!W!lO!e!mO$|!`O$}!`O%O!aO%P!aO%Q!aOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O$z!_O${!_O~P!$WO$zUi${Ui~P!$WO_!bOf!jO!W!lO!e!mOhUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~OT!aO]!aO%O!aO%P!aO%Q!aO~P!'UOTUi]Ui%OUi%PUi%QUi~P!'UOf!jO!W!lO!e!mOTUi]Ui_UihUiiUijUikUilUimUipUixUiyUi!tUi#_Ui$jUi$mUi$wUi$xUi$yUi$zUi${Ui$|Ui$}Ui%OUi%PUi%QUi%XUi!PUi!SUi!TUi%YUi!XUi!]Ui!OUi#WUiqUi!kUi~O!S%cO!T%bOx%dX!P%dX~O%X'`O%Y'`O~P+{Ox'bO!P%cX~O!P'dO~Ox'eOy'gO!X%eX~Ol,qOs-OOx'eOy'hO!X%eX~P'UO!X'jO~Oj!oOk!oOl!rOm!sOhgipgixgiygi!tgi#_gi$jgi$mgi%Xgi~Oi!qO~P!.gOigi~P!.gOh,sOi,tOj,rOk,rOl,zOm,{O~Oq'lO~P!/pOT'qOl,qOs-OO!P'rO~P'UOx'sO!P'rO~O!P'uO~O!T'wO~Ox'sO!P'xO!S%cO!T%bO~P$bOh,sOi,tOj,rOk,rOl,zOm,{O!Pna!Sna!Tna%Yna!Xna!]na!Ona#Wnaqna!kna~PDaOT'|Ol,qOs-OOx#{X!X#{X~P'UOx%fO!X%aa~O!X(OO~Ox%fO!S%cO!T%bO!X%aa~P$bOT(SOl,qOs-OOx#xX!]#xX#_#xX$j#xX$m#xX!P#xXy#xX!k#xX%X#xX~P'UOx%kO!]%[a#_%[a$j%[a$m%[a!P%[ay%[a!k%[a%X%[a~O!](VO~Ox%kO!S%cO!T%bO!]%[a~P$bOx(YO!S%cO!T%bO!]%ba~P$bOx(]Oy%pX!]%pX!k%pX~Oy(`O!](bO!k(cO~Ox#jOy$ui!t$ui#_$ui$j$ui$m$ui%X$ui~O!e&WOf%|a$j%|a#W%|a#_%|a$m%|a#V%|a~O$j(gO~OT#yO_#zOu#xO%SVO~Ox&_Oyta~OltOsuO~P'UOx%kO#_%[a$j%[a$m%[a!P%[ay%[a!]%[a!k%[a%X%[a~P$bOx(lO#_$uX$j$uX$m$uX%X$uX~O%X$SO#_Si$jSi$mSi~Ox#zX#_#zX$j#zX$m#zXk#zX~P'UOx&jO#_%^a$j%^a$m%^ak%^a~OT(rOf(tO%SVO~O#V(uO~O%SVOx$`X#_$`X$j$`X$m$`X~Ox&rO#_&Oa$j&Oa$m&Oa~Ol,qOs-OOx$[X#_$[X$j$[X$m$[Xy$[X~P'UOx&tO#_%{a$j%{a$m%{ay%{a~Oq(|O#b({OP#`iT#`id#`if#`il#`ip#`is#`iu#`i}#`i!O#`i!S#`i!T#`i!W#`i![#`i!g#`i!n#`i!o#`i!p#`i!w#`i!y#`i!{#`i!}#`i#P#`i#T#`i#V#`i#Y#`i#Z#`i#]#`i#d#`i#g#`i#k#`i#m#`i#r#`i#u#`i$i#`i$j#`i$|#`i$}#`i%R#`i%S#`i%g#`i%h#`i%k#`i%n#`i%t#`i%w#`i%y#`i$m#`i$n#`i$o#`i~Oq(}OP#ciT#cid#cif#cil#cip#cis#ciu#ci}#ci!O#ci!S#ci!T#ci!W#ci![#ci!g#ci!n#ci!o#ci!p#ci!w#ci!y#ci!{#ci!}#ci#P#ci#T#ci#V#ci#Y#ci#Z#ci#]#ci#d#ci#g#ci#k#ci#m#ci#r#ci#u#ci$i#ci$j#ci$|#ci$}#ci%R#ci%S#ci%g#ci%h#ci%k#ci%n#ci%t#ci%w#ci%y#ci$m#ci$n#ci$o#ci~OT)POk$dXx$dX~P'UOx&xOk&Qa~Ox&xOk&Qa~P$bOk)TO~OPhOTeOltOp!SOsuO}vO!O!PO!S!VO!T!UO!wxO!yyO!{zO!}{O#P|O#T}O#V!OO#Y!QO#Z!QO#]!RO#d!TO#g!WO#k!XO#m!YO#r!ZO#ulO~P'UOq)ZO#h'SO#i)YOP#fiT#fid#fif#fil#fip#fis#fiu#fi}#fi!O#fi!S#fi!T#fi!W#fi![#fi!g#fi!n#fi!o#fi!p#fi!w#fi!y#fi!{#fi!}#fi#P#fi#T#fi#V#fi#Y#fi#Z#fi#]#fi#d#fi#g#fi#k#fi#m#fi#r#fi#u#fi$i#fi$j#fi$|#fi$}#fi%R#fi%S#fi%g#fi%h#fi%k#fi%n#fi%t#fi%w#fi%y#fi$m#fi$n#fi$o#fi~Ol,qOs-OOy$mO~P'UOl,qOs-OOx$fXy$fX~P'UOx'VOy&Ra~OT)dO_)eOu)cO%O)fO%SVO~O!P)hO~P!IxOy$mO&U)jO~OT$|O_$|Ol,qOs-OOx#}X!P#}X~P'UOx'bO!P%ca~Ol,qOs-OOy)rOx$OX!X$OX~P'UOx'eO!X%ea~Ol,qOs-OOx'eOy)uO!X%ea~P'UOl,qOs-OOx'eO!X%ea~P'UOx'eOy)uO!X%ea~Oj,rOk,rOl,zOm,{Ohgipgixgi!Pgi!Sgi!Tgi%Ygi!Xgiygi!]gi#_gi$jgi$mgi!Ogi#Wgiqgi!kgi%Xgi~Oi,tO~P!LuOigi~P!LuOT'qOl,qOs-OO!P)zO~P'UOk)|O~Ox*OO!P)zO~O!P*PO~Ox%fO!X%ai~O!X*RO~Ox(YO!S%cO!T%bO!]%bi~Ox%kO!]%[i#_%[i$j%[i$m%[i!P%[iy%[i!k%[i%X%[i~O!]*VO~O_*XOl,qOs-OOx#|X!]#|X~P'UOx(YO!]%bi~O!]*ZO~OT*]Ol,qOs-OOx$SXy$SX!]$SX!k$SX~P'UOx(]Oy%pa!]%pa!k%pa~O![#]O%r*`O!]!lX~O!]*bO~Oy(`O!]*cO~Ox$Yiy$Yi!t$Yi#_$Yi$j$Yi$m$Yi%X$Yi~P$bOT&QOl,qOs-OOx$YX#_$YX$j$YX$m$YX%X$YX~P'UOx(lO#_$ua$j$ua$m$ua%X$ua~Ox#za#_#za$j#za$m#zak#za~P$bOx*eO#_#Sq$j#Sq$m#Sq~Ox*fO#W*hO#_%}X$j%}X$m%}X!P%}X~OT*jOf*kO%SVO~Oq*mO#b({OP#`qT#`qd#`qf#`ql#`qp#`qs#`qu#`q}#`q!O#`q!S#`q!T#`q!W#`q![#`q!g#`q!n#`q!o#`q!p#`q!w#`q!y#`q!{#`q!}#`q#P#`q#T#`q#V#`q#Y#`q#Z#`q#]#`q#d#`q#g#`q#k#`q#m#`q#r#`q#u#`q$i#`q$j#`q$|#`q$}#`q%R#`q%S#`q%g#`q%h#`q%k#`q%n#`q%t#`q%w#`q%y#`q$m#`q$n#`q$o#`q~Ok$dax$da~P$bOx&xOk&Qi~O$m*yO$n*wO$o*yO~Ox*}Oy$mO#W*}O~O#i+OOP#fqT#fqd#fqf#fql#fqp#fqs#fqu#fq}#fq!O#fq!S#fq!T#fq!W#fq![#fq!g#fq!n#fq!o#fq!p#fq!w#fq!y#fq!{#fq!}#fq#P#fq#T#fq#V#fq#Y#fq#Z#fq#]#fq#d#fq#g#fq#k#fq#m#fq#r#fq#u#fq$i#fq$j#fq$|#fq$}#fq%R#fq%S#fq%g#fq%h#fq%k#fq%n#fq%t#fq%w#fq%y#fq$m#fq$n#fq$o#fq~O#W+POx$fay$fa~Ox'VOy&Ri~Oy$RO%X+ROx&TX!P&TX~O%SVOx&TX!P&TX~Ox+VO!P&SX~O!P+XO~Oy+ZOx$Oa!X$Oa~Ol,qOs-OOy+[Ox$Oa!X$Oa~P'UOx'eO!X%ei~Ol,qOs-OOx'eO!X%ei~P'UOx'eOy+`O!X%ei~Ox#yi!P#yi~P$bOT'qOl,qOs-OO~P'UOk+bO~OT'qOl,qOs-OO!P+cO~P'UOx#{i!X#{i~P$bOx#xi!]#xi#_#xi$j#xi$m#xi!P#xiy#xi!k#xi%X#xi~P$bOx(YO!]%bq~O!]+dO~Oy+eO~Ox(]Oy%pi!]%pi!k%pi~O![#]O%r*`O!]!la~Ox(lO#_$ui$j$ui$m$ui%X$ui~O%SVOx$_X#_$_X$j$_X$m$_X!P$_X~Ox*fO#_%}a$j%}a$m%}a!P%}a~O!P+mO~Ok$dix$di~P$bOq+qOP#eyT#eyd#eyf#eyl#eyp#eys#eyu#ey}#ey!O#ey!S#ey!T#ey!W#ey![#ey!g#ey!n#ey!o#ey!p#ey!w#ey!y#ey!{#ey!}#ey#P#ey#T#ey#V#ey#Y#ey#Z#ey#]#ey#d#ey#g#ey#k#ey#m#ey#r#ey#u#ey$i#ey$j#ey$|#ey$}#ey%R#ey%S#ey%g#ey%h#ey%k#ey%n#ey%t#ey%w#ey%y#ey$m#ey$n#ey$o#ey~O$m+vO$n*wO$o+vO~O#i+wOP#fyT#fyd#fyf#fyl#fyp#fys#fyu#fy}#fy!O#fy!S#fy!T#fy!W#fy![#fy!g#fy!n#fy!o#fy!p#fy!w#fy!y#fy!{#fy!}#fy#P#fy#T#fy#V#fy#Y#fy#Z#fy#]#fy#d#fy#g#fy#k#fy#m#fy#r#fy#u#fy$i#fy$j#fy$|#fy$}#fy%R#fy%S#fy%g#fy%h#fy%k#fy%n#fy%t#fy%w#fy%y#fy$m#fy$n#fy$o#fy~Ox'VOy&Rq~O%X+ROx&Ta!P&Ta~Ox$gX!P$gX~P!IxOx+VO!P&Sa~Ol,qOs-OOy,POx$Oi!X$Oi~P'UOl,qOs-OOx$Oi!X$Oi~P'UOy,POx$Oi!X$Oi~Ox'eO!X%eq~Ol,qOs-OOx'eO!X%eq~P'UOp,UO!S%cO!T%bO!P%]q!X%]q!]%]qx%]q~P!/pOx#|i!]#|i~P$bO#W,YOx$_a#_$_a$j$_a$m$_a!P$_a~Ox*fO#_%}i$j%}i$m%}i!P%}i~O!P,[O~Oq,^OP#e!RT#e!Rd#e!Rf#e!Rl#e!Rp#e!Rs#e!Ru#e!R}#e!R!O#e!R!S#e!R!T#e!R!W#e!R![#e!R!g#e!R!n#e!R!o#e!R!p#e!R!w#e!R!y#e!R!{#e!R!}#e!R#P#e!R#T#e!R#V#e!R#Y#e!R#Z#e!R#]#e!R#d#e!R#g#e!R#k#e!R#m#e!R#r#e!R#u#e!R$i#e!R$j#e!R$|#e!R$}#e!R%R#e!R%S#e!R%g#e!R%h#e!R%k#e!R%n#e!R%t#e!R%w#e!R%y#e!R$m#e!R$n#e!R$o#e!R~Ol,qOs-OOx$Oq!X$Oq~P'UOy,cOx$Oq!X$Oq~Ox'eO!X%ey~Ol,qOs,gO~P'UOp,UO!S%cO!T%bO!P%]y!X%]y!]%]yx%]y~P!/pOx*fO#_%}q$j%}q$m%}q!P%}q~Ol,qOs-OOx$Oy!X$Oy~P'UOx'eO!X%e!R~Op%`X!P%`X!S%`X!T%`X!X%`X!]%`Xx%`X~P!/pOp,UO!S%cO!T%bO!P%_a!X%_a!]%_ax%_a~Oy,oO~Ox(lO#_$ua$j$ua$m$ua%X$ua~P$bOk,vO~Ol,vO~P'UOy,wO~Oq,xO~P!/pO%h%k%w%y%g%n%t%S%g~",
  goto: "!&h&UPPPP&VP&_(|)d){*e+O+jP,VP&_,t,t&_P&_P/cPPPPPP/c1bPP1bP2}P3W7`PP7c7o7rPPP&_&_PP8O&_PP&_&_PP&_&_&_&_8S8x&_P8{P9O9O;qP<V&_PPP<Z<a&VP&V&VP&VP&VP&VP&VP&V&V&VP&VPP&VPP&VP<gP<n<tP<nP<n<nPPP<nP>mP>v>|?S>mP<n?YP?a?g?m?y@T@Z@e@o@uAcAiAoAuBPBVB]BcBiBoCRC]CcCiCoCyDPDVD]DcDmDsD}ETPPPPPPPPPE^EhEqE{FWPPPPPPPPPPPPI}JgNU!!qPP!!y!#X!#b!$W!#}!$a!$g!$j!$m!$p!$vPPPPPPPPPP!$y!$|PPPPPPPPP!%S!%`!%l!%x!%{!&R!&X!&_!&b]iOr#m$m'Q*w&XdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-Py!cP#i#v$X$g%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u{!dP#i#v$X$g$s%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u}!eP#i#v$X$g$s$t%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!P!fP#i#v$X$g$s$t$u%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!R!gP#i#v$X$g$s$t$u$v%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!T!hP#i#v$X$g$s$t$u$v$w%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u!X!iP!n#i#v$X$g$s$t$u$v$w$x%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,u&XSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-P$yUOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-P$TWOXYZhrv|}!R!S!T!X!j!l#]#j#m$P$R$T$W$k$m$|%R%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){*O*]*e*w+S+Z+[+`+e+|,P,c,w,xQ#|uQ,m,gR,|-O&SdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PW#pl!O!P$_W#xu&_,g-OQ$a!QQ$q!YQ$r!ZS${!j'bS&^#y#zQ'O$lQ(e&WQ(r&nW(s&p(t(u*kQ(v&rQ)b'XS)c'Z+VS+U)d)eQ+j*fQ+l*hQ+x*}Q+z+PR,j,YR&]#xe!wXY!S!T%_%f's({){*OR%]!vQ!{XQ%x#]Q&f$TR&i$WT,f,U,o!Y!kP!n#i#v$X$g$s$t$u$v$w$x$y%d%i%o%p&b&z(d(n)O)y*Q*S*r+f,uQ&Z#qR'^$rR'a${R%U!m&WcOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!j!l!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m$|%R%Y%]%_%b%f%k%m%w&Q&]&a&j&l&m&t&x&{'Q'S'V'a'b'e'g'h'l'q's'w'|(S(Y(](l({)P)T)j)r)u){)|*O*X*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,y,{-PT#gc#hS#^_#_S#a`#bS#ca#dS#eb#fT*`(`*aT(a%x(cQ$VwR+T)cX$Tw$U$V&hZkOr$m'Q*wXoOr'Q*wQ$n!WQ&v$eQ&w$fQ'Y$pQ']$rQ)U&}Q)['SQ)^'TQ)_'UQ)k'[Q)m'^Q*n({Q*p(|Q*q(}Q*s)SS*u)V)lQ*z)YQ*{)ZQ*|)]Q+o*mQ+p*oQ+r*tQ+s*vQ+y+OQ,]+qQ,_+wQ,`+xR,k,^WoOr'Q*wR#snQ'[$qR)V'OQ+S)cR+|+TQ)l'[R*v)VZmOnr'Q*wQrOR#urQ&`#{R(j&`S%l#Q#}S(T%l(WT(W%o&bQ%`!yS't%`'yR'y%dQ&k$XR(o&kQ%g!|S'}%g(PR(P%iQ(Z%pQ*T(UT*Y(Z*TQ'c$}R)p'cS'f%Q%RY)s'f)t+^,S,dU)t'g'h'iU+^)u)v)wS,S+_+`R,d,TQ#X]R%s#XQ#[^R%u#[Q#__R%y#_Q(^%vS*^(^*_R*_(_Q*a(`R+h*aQ#b`R%{#bQ#daR%|#dQ#fbR%}#fQ#hcR&O#hQ#kfQ&P#iW&S#k&P(m*dQ(m&eR*d,uQ$UwS&g$U&hR&h$VQ&u$cR(y&uQ&X#pR(f&XQ$_!PR&o$_Q*g(sS+k*g,ZR,Z+lQ&s$aR(w&sQ#njR&U#nQ*x)WR+u*xQ(z&vR*l(zQ&y$gS)Q&y)RR)R&zQ'R$nR)X'RQ'W$oS)a'W+QR+Q)bQ+W)gR,O+WWnOr'Q*wR#rnSqOrQ)W'QR+t*wWpOr'Q*wR'P$mYjOr$m'Q*wR&T#m[wOr#m$m'Q*wR&f$T$xPOXYZhrtv|}!R!S!T!X!j!l!o!p!q!s!t#]#j#m$P$R$T$W$k$m$|%R%Y%]%_%f%k%m%w&]&a&l&m&t&{'Q'S'V'a'b'e'g'h'l's(Y(](l({)T)j)r)u){)|*O*]*e*w+S+Z+[+`+b+e+|,P,U,c,o,q,r,s,t,v,w,x,{-PQ!nSQ#ieQ#vsU$Xx%b'wS$g!U$jQ$s!cQ$t!dQ$u!eQ$v!fQ$w!gQ$x!hQ$y!iQ%d!zQ%i!}Q%o#RQ%p#SQ&b$OQ&z$hQ(d&QQ(n&jQ)O&xQ)y'qQ*Q'|Q*S(SQ*r)PQ+f*XR,u,yQ!yXQ!|YQ$e!SQ$f!TW'p%_'s){*OQ'{%fR*o({[fOr#m$m'Q*wd!vXY!S!T%_%f's({){*OQ#QZQ#lhS#}v|Q$[}W$c!R$W&{)TS$o!X$kS$z!j'bQ%Q!lQ%v#]S&R#j(lQ&c$PQ&d$RQ&e$TQ'_$|Q'i%RQ'o%]Q(R%kQ(U%mQ(_%wQ(h&]S(k&a,wQ(p&lQ(q&mQ(x&tQ)]'SQ)`'VQ)n'aQ)q'eQ)v'gQ)w'hS)x'l,xQ*W(YQ*[(]Q+Y)jQ+])rQ+_)uQ+g*]Q+i*eQ+{+SQ,Q+ZQ,R+[Q,T+`Q,X+eQ,a+|Q,b,PR,l,cbTOr#j#m$m&a'Q'l*w#p!uXYZhv|}!R!S!T!X!j!l#]$P$R$T$W$k$|%R%]%_%f%k%m%w&]&l&m&t&{'S'V'a'b'e'g'h's(Y(](l({)T)j)r)u){*O*]*e+S+Z+[+`+e+|,P,c,w,xQ#wtW%V!o!s,r,{Q%W!pQ%X!qQ%Z!tQ%e,qS'k%Y,vQ'm,sQ'n,tQ+a)|Q,W+bS,e,U,oR,}-PU#{u,g-OR(i&_[gOr#m$m'Q*wX!xX#]$T$WQ#VZQ$QvR$Z|Q%a!yQ%h!|Q%n#QQ'_$zQ'z%dQ(Q%iQ(X%oQ([%pQ*U(UQ,V+aQ,i,WR,n,hQ$YxQ'v%bR)}'wQ,h,UR,p,oR#PYR#UZR%P!jQ$}!jR)o'bR%S!lR%x#]Q(b%xR*c(cQ$d!RQ&i$WQ)S&{R*t)TQ#qlQ$]!OQ$`!PR&q$_Q(r&pQ*i(tQ*j(uR+n*kR$b!QXpOr'Q*wQ$i!UR&|$jQ$p!XR&}$kR)i'ZQ)g'ZR+}+V",
  nodeNames: "âš  print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ParenthesizedExpression ( BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList self VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from ) TupleExpression ComprehensionExpression async for LambdaExpression ArrayExpression [ ] ArrayComprehensionExpression DictionaryExpression { } DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
  maxTerm: 236,
  nodeProps: [
    [lezer.NodeProp.group, -14,4,81,83,84,86,88,90,92,94,95,96,98,101,104,"Statement Statement",-23,6,16,19,21,37,38,48,49,53,56,57,60,61,62,63,66,69,70,71,75,76,77,78,"Expression",-9,106,108,111,113,114,118,120,125,127,"Statement"]
  ],
  skippedNodes: [0,2],
  repeatNodeCount: 33,
  tokenData: "!E}MgR!^OX$}XY%wY[$}[]%w]p$}pq%wqr(crs*Ust2Otu$}uv4Qvw5Uwx5xxyAWyzAtz{Bb{|Cr|}Df}!OES!O!PFZ!P!QKa!Q!RLq!R![!(P![!]!)i!]!^!*m!^!_!+Z!_!`!,k!`!a!-_!a!b$}!b!c!.l!c!d!/b!d!e!1f!e!h!/b!h!i!8O!i!t!/b!t!u!=b!u!w!/b!w!x!?`!x!}!/b!}#O!@t#O#P!Ab#P#Q!Bc#Q#R!CP#R#S!/b#S#T$}#T#U!/b#U#V!1f#V#Y!/b#Y#Z!8O#Z#f!/b#f#g!=b#g#i!/b#i#j!?`#j#o!/b#o#p!Cs#p#q!D[#q#r!EO#r#s!Ea#s$g$}$g~!/b<r%`R%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i7[%nR%r7[O#o%i#p#q%i#r~%iMg&[Z%o`%up%r7[%x!b%z#t%iS%lW$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'UZ%r7[$q1sOX%iXY&}Y[%i[]&}]p%ipq&}q#O%i#O#P'w#P#o%i#p#q%i#r~%iHP'|V%r7[OY%iYZ&}Z]%i]^&}^#o%i#p#q%i#r~%i<u(tY%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#T%i#T#U)t#U#f%i#f#g)t#g#h)t#h#o%i#p#q%i#r~%i7_)kRjR%r7[O#o%i#p#q%i#r~%i7_){R!kR%r7[O#o%i#p#q%i#r~%iG{*e]%vp%o`%r7[%x!b%iS%g,XOY+^YZ.{Z]+^]^.{^r+^rs/]s#O+^#O#P0|#P#o+^#o#p1b#p#q+^#q#r1b#r~+^Bm+g]%r7[%lW%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be,g]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs-`s#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be-gR%r7[%g,XO#o%i#p#q%i#r~%iBe-uT%r7[O#o,`#o#p.U#p#q,`#q#r.U#r~,`,X.ZV%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.U,X.uO%g,X,X.xPO~.U7d/SR%r7[%lWO#o%i#p#q%i#r~%iEc/dX%r7[%g,XOr.{rs0Ps#O.{#O#P0c#P#o.{#o#p0w#p#q.{#q#r0w#r~.{Ec0YR%m#|%r7[%k,XO#o%i#p#q%i#r~%i7d0hT%r7[O#o.{#o#p0w#p#q.{#q#r0w#r~.{W0|O%lWBm1RT%r7[O#o+^#o#p1b#p#q+^#q#r1b#r~+^,a1iV%lW%g,XOY.UZ].U^r.Urs.ps#O.U#O#P.u#P~.UMg2cXQ1s%o`%up%r7[%x!b%z#t%iS%lWOY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3OHP3VXQ1s%r7[OY3OYZ%iZ]3O]^%i^#o3O#o#p3r#p#q3O#q#r3r#r~3O1s3wRQ1sOY3rZ]3r^~3rGz4eT%PQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iBd4{R!t,W%r7[O#o%i#p#q%i#r~%iGz5iT$yQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{6X_%s`%up%r7[%z#t%lW%g,XOY7WYZ:dZ]7W]^:d^r7Wrs:xsw7Wwx;|x#O7W#O#P>n#P#o7W#o#p?t#p#q7W#q#r?S#r~7WFq7e]%r7[%x!b%z#t%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be8e]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be9cT%r7[O#o8^#o#p9r#p#q8^#q#r9r#r~8^,X9wV%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r,X:aPO~9r;h:oR%r7[%x!b%z#t%iSO#o%i#p#q%i#r~%iC{;T]%r7[%x!b%iS%g,XOY8^YZ%iZ]8^]^%i^w8^wx-`x#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Fq<VZ%r7[%z#t%g,XOr:drs<xsw:dwx=[x#O:d#O#P=p#P#o:d#o#p>_#p#q:d#q#r>U#r~:d8r=RR%r7[%x!b%iSO#o%i#p#q%i#r~%iFq=gR%j!f%r7[%z#t%h,XO#o%i#p#q%i#r~%i;h=uT%r7[O#o:d#o#p>U#p#q:d#q#r>U#r~:d%[>_O%x!b%z#t%iS%[>dP%iS#o#p>g%W>nO%x!b%z#tFq>sT%r7[O#o7W#o#p?S#p#q7W#q#r?S#r~7W0e?_V%x!b%z#t%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9r0e?{X%iS%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P#o9r#o#p@h#p~9r0a@qV%x!b%z#t%g,XOY9rZ]9r^w9rwx.px#O9r#O#P:^#P~9rG{AkRf,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i<uBXR!PR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{BuVT,X%o`%up%r7[%x!b%z#t%iS%lWOz%iz{C[{!_%i!_!`4t!`#o%i#p#q%i#r~%iBeCcT_R%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DVT$|,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iG{DyRx,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMgEgU$},X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`!aEy!a#o%i#p#q%i#r~%i<vFQR&U&j%r7[O#o%i#p#q%i#r~%iG{FnV!eQ%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!PGT!P!Q%i!Q![Gy![#o%i#p#q%i#r~%iBeGYT%r7[O!O%i!O!PGi!P#o%i#p#q%i#r~%iBeGpR!n,X%r7[O#o%i#p#q%i#r~%iBcHQ_!g,V%r7[O!Q%i!Q![Gy![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#SGy#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBcIUX%r7[O{%i{|Iq|}%i}!OIq!O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcIvT%r7[O!Q%i!Q![JV![#o%i#p#q%i#r~%iBcJ^Z!g,V%r7[O!Q%i!Q![JV![!l%i!l!mKP!m#R%i#R#SJV#S#^%i#^#_KP#_#o%i#p#q%i#r~%iBcKWR!g,V%r7[O#o%i#p#q%i#r~%iG{KtV%OR%o`%up%r7[%x!b%z#t%iS%lWO!P%i!P!QLZ!Q!_%i!_!`4t!`#o%i#p#q%i#r~%iBdLbT%QQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iGyMUm!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!d%i!d!e!#w!e!g%i!g!hIP!h!l%i!l!mKP!m!q%i!q!r!%V!r!z%i!z!{!&_!{#R%i#R#S!!k#S#U%i#U#V!#w#V#X%i#X#YIP#Y#^%i#^#_KP#_#c%i#c#d!%V#d#l%i#l#m!&_#m#o%i#p#q%i#r~%iBc! UT%r7[O!Q%i!Q![! e![#o%i#p#q%i#r~%iBc! l_!g,V%r7[O!Q%i!Q![! e![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S! e#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!!ra!g,V%r7[O!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iBc!#|W%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!$mW!g,V%r7[O!Q%i!Q!R!$f!R!S!$f!S#R%i#R#S!$f#S#o%i#p#q%i#r~%iBc!%[V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!%xV!g,V%r7[O!Q%i!Q!Y!%q!Y#R%i#R#S!%q#S#o%i#p#q%i#r~%iBc!&dZ%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iBc!'^Z!g,V%r7[O!Q%i!Q![!'V![!c%i!c!i!'V!i#R%i#R#S!'V#S#T%i#T#Z!'V#Z#o%i#p#q%i#r~%iGy!(da!g,V%o`%up%r7[%x!b%z#t%iS%lWO!O%i!O!P! P!P!Q%i!Q![!!k![!g%i!g!hIP!h!l%i!l!mKP!m#R%i#R#S!!k#S#X%i#X#YIP#Y#^%i#^#_KP#_#o%i#p#q%i#r~%iMg!)|Ty1s%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`!*]!`#o%i#p#q%i#r~%i7_!*dR%YR%r7[O#o%i#p#q%i#r~%iG{!+QR#_,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iG{!+nVjR%o`%up%r7[%x!b%z#t%iS%lWO!^%i!^!_!,T!_!`)d!`!a)d!a#o%i#p#q%i#r~%iBd!,[T$zQ%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!-OT%X,X%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`#o%i#p#q%i#r~%iG{!-rUjR%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`)d!`!a!.U!a#o%i#p#q%i#r~%iBd!.]T${Q%r7[O!_%i!_!`4t!`#o%i#p#q%i#r~%iG{!/RT]Q#uP%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iMg!/wZ%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jHP!0sZ%r7[%f&j%S,XO!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!1{c%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!6v#g#o!0j#p#q%i#r$g%i$g~!0jBe!3_]%r7[%g,XOY,`YZ%iZ],`]^%i^r,`rs!4Ws#O,`#O#P-p#P#o,`#o#p.U#p#q,`#q#r.U#r~,`Be!4_T%r7[%g,XOr%irs!4ns#o%i#p#q%i#r~%iBe!4uR%r7[%k,XO#o%i#p#q%i#r~%iBe!5V]%r7[%g,XOY8^YZ%iZ]8^]^%i^w8^wx!6Ox#O8^#O#P9^#P#o8^#o#p9r#p#q8^#q#r9r#r~8^Be!6VT%r7[%g,XOw%iwx!6fx#o%i#p#q%i#r~%iBe!6mR%r7[%h,XO#o%i#p#q%i#r~%iHP!7P_%r7[%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!8ec%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!t!0j!t!u!<Y!u!}!0j!}#R%i#R#S!0j#S#T%i#T#f!0j#f#g!<Y#g#o!0j#p#q%i#r$g%i$g~!0jBe!9wT%r7[%t,XOr%irs!:Ws#o%i#p#q%i#r~%iBe!:]T%r7[Or%irs!:ls#o%i#p#q%i#r~%iBe!:sR%r7[%y,XO#o%i#p#q%i#r~%iBe!;TT%r7[%n,XOw%iwx!;dx#o%i#p#q%i#r~%iBe!;iT%r7[Ow%iwx!;xx#o%i#p#q%i#r~%iBe!<PR%r7[%w,XO#o%i#p#q%i#r~%iHP!<c_%r7[%f&j%S,XOr%irs!9psw%iwx!:|x!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jMg!=wg%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!h!0j!h!i!<Y!i!t!0j!t!u!6v!u!}!0j!}#R%i#R#S!0j#S#T%i#T#U!0j#U#V!6v#V#Y!0j#Y#Z!<Y#Z#o!0j#p#q%i#r$g%i$g~!0jMg!?u_%o`%up%r7[%x!b%z#t%iS%lW%f&j%S,XOr%irs!3Wsw%iwx!5Ox!Q%i!Q![!0j![!c%i!c!}!0j!}#R%i#R#S!0j#S#T%i#T#o!0j#p#q%i#r$g%i$g~!0jG{!AXR!W,X%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iMg!AgX%r7[OY$}YZ%wZ]$}]^%w^#o$}#o#p!BS#p#q$}#q#r!BS#r~$}&f!BcO%o`%up%x!b%z#t%iS%lW<u!BvR!XR%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%iGz!CdT$xQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%iGy!C|P![Gm%iS%lW#o#p!DP&Y!D[O%o`%up%x!b%z#tGz!DoT$wQ%o`%up%r7[%x!b%z#t%iS%lWO!_%i!_!`4t!`#o%i#p#q%i#r~%i<u!EaO!]7_%o`%up%x!b%z#t%iS%lWGy!EtR%R,V%o`%up%r7[%x!b%z#t%iS%lWO#o%i#p#q%i#r~%i",
  tokenizers: [legacyPrint, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines, bodyContinue],
  topRules: {"Script":[0,3]},
  specialized: [{term: 188, get: value => spec_identifier[value] || -1}],
  tokenPrec: 6076
});

exports.parser = parser;


/***/ }),

/***/ "./node_modules/lezer-tree/dist/tree.cjs":
/*!***********************************************!*\
  !*** ./node_modules/lezer-tree/dist/tree.cjs ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

/// The default maximum length of a `TreeBuffer` node.
const DefaultBufferLength = 1024;
let nextPropID = 0;
const CachedNode = new WeakMap();
/// Each [node type](#tree.NodeType) can have metadata associated with
/// it in props. Instances of this class represent prop names.
class NodeProp {
    /// Create a new node prop type. You can optionally pass a
    /// `deserialize` function.
    constructor({ deserialize } = {}) {
        this.id = nextPropID++;
        this.deserialize = deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// Create a string-valued node prop whose deserialize function is
    /// the identity function.
    static string() { return new NodeProp({ deserialize: str => str }); }
    /// Create a number-valued node prop whose deserialize function is
    /// just `Number`.
    static number() { return new NodeProp({ deserialize: Number }); }
    /// Creates a boolean-valued node prop whose deserialize function
    /// returns true for any input.
    static flag() { return new NodeProp({ deserialize: () => true }); }
    /// Store a value for this prop in the given object. This can be
    /// useful when building up a prop object to pass to the
    /// [`NodeType`](#tree.NodeType) constructor. Returns its first
    /// argument.
    set(propObj, value) {
        propObj[this.id] = value;
        return propObj;
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#tree.NodeSet.extend) or
    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop
    /// values for each node type in the set. Takes a [match
    /// object](#tree.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src)
                    src[0].set(props, src[1]);
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#tree.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#tree.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a number array. Each parser
/// [has](#lezer.Parser.nodeSet) a node set, and [tree
/// buffers](#tree.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536)
/// node types in it, so that the ids fit into 16-bit typed array
/// slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#tree.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    add[0].set(newProps, add[1]);
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the `TreeCursor` interface instead, which provides a view on
/// some part of this data structure, and can be used to move around
/// to adjacent nodes.
class Tree {
    /// Construct a new tree. You usually want to go through
    /// [`Tree.build`](#tree.Tree^build) instead.
    constructor(type, 
    /// The tree's child nodes. Children small enough to fit in a
    /// `TreeBuffer will be represented as such, other children can be
    /// further `Tree` instances with their own internal structure.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
    }
    /// @internal
    toString() {
        let children = this.children.map(c => c.toString()).join();
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular
    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)
    /// nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, true);
    }
    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#tree.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        return this.cursor(pos, side).node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, the given node
    /// will not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor();;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Balance the direct children of this tree.
    balance(maxBufferLength = DefaultBufferLength) {
        return this.children.length <= BalanceBranchFactor ? this
            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer @internal
    constructor(
    /// @internal
    buffer, 
    // The total length of the group of nodes in the buffer.
    length, 
    /// @internal
    set, type = NodeType.none) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
        this.type = type;
    }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, after) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (after != -100000000 /* None */) {
                let start = buffer[i + 1], end = buffer[i + 2];
                if (dir > 0) {
                    if (end > after)
                        pick = i;
                    if (end > after)
                        break;
                }
                else {
                    if (start < after)
                        pick = i;
                    if (end >= after)
                        break;
                }
            }
            else {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
}
class TreeNode {
    constructor(node, from, index, _parent) {
        this.node = node;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get to() { return this.from + this.node.length; }
    nextChild(i, dir, after, full = false) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))
                    continue;
                if (next instanceof TreeBuffer) {
                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if (full || (!next.type.isAnonymous || hasChild(next))) {
                    let inner = new TreeNode(next, start, i, parent);
                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
                }
            }
            if (full || !parent.type.isAnonymous)
                return null;
            i = parent.index + dir;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }
    childAfter(pos) { return this.nextChild(0, 1, pos); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
    }
    get prevSibling() {
        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, after) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, -100000000 /* None */); }
    get lastChild() { return this.child(-1, -100000000 /* None */); }
    childAfter(pos) { return this.child(1, pos); }
    childBefore(pos) { return this.child(-1, pos); }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, full = false) {
        this.full = full;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enter(dir, after) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enter(1, -100000000 /* None */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enter(-1, -100000000 /* None */); }
    /// Move the cursor to the first child that starts at or after `pos`.
    childAfter(pos) { return this.enter(1, pos); }
    /// Move to the last child that ends at or before `pos`.
    childBefore(pos) { return this.enter(-1, pos); }
    /// Move the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                let child = parent.node.children[i];
                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
                    return false;
            }
        }
        return true;
    }
    move(dir) {
        if (this.enter(dir, -100000000 /* None */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty, its next sibling or the next sibling of
    /// the first parent node that has one.
    next() { return this.move(1); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by ist last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev() { return this.move(-1); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        for (;;) {
            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
                break;
            if (this.from == this.to ||
                (side < 1 ? this.from >= pos : this.from > pos) ||
                (side > -1 ? this.to <= pos : this.to < pos)) {
                this.parent();
                break;
            }
        }
        return this;
    }
    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#tree.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#tree.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
const BalanceBranchFactor = 8;
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        while (id == inRepeat) {
            cursor.next();
            ({ id, start, end, size } = cursor);
        }
        let startPos = start - parentStart;
        if (size < 0) { // Reused node
            children.push(reused[id]);
            positions.push(startPos);
            cursor.next();
            return;
        }
        let type = types[id], node, buffer;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index, inRepeat);
            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            while (cursor.pos > endPos)
                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);
            else
                node = new Tree(type, localChildren, localPositions, end - start);
        }
        children.push(node);
        positions.push(startPos);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let nodeSize = fork.size, startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0)
                    break scan;
                if (fork.id >= minRepeatType)
                    localSkipped += 4;
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index, inRepeat) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (id == inRepeat)
            return index;
        let startIndex = index;
        if (size > 4) {
            let endPos = cursor.pos - (size - 4);
            while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer, index, inRepeat);
        }
        if (id < minRepeatType) { // Don't copy repeat nodes into buffers
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {
    let localChildren = [], localPositions = [];
    if (length <= maxBufferLength) {
        for (let i = from; i < to; i++) {
            localChildren.push(children[i]);
            localPositions.push(positions[i] - start);
        }
    }
    else {
        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i];
            i++;
            for (; i < to; i++) {
                let nextEnd = positions[i] + children[i].length;
                if (nextEnd - groupStart > maxChild)
                    break;
            }
            if (i == groupFrom + 1) {
                let only = children[groupFrom];
                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse
                    for (let j = 0; j < only.children.length; j++) {
                        localChildren.push(only.children[j]);
                        localPositions.push(only.positions[j] + groupStart - start);
                    }
                    continue;
                }
                localChildren.push(only);
            }
            else if (i == groupFrom + 1) {
                localChildren.push(children[groupFrom]);
            }
            else {
                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart);
                if (innerType != NodeType.none && !containsType(inner.children, innerType))
                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);
                localChildren.push(inner);
            }
            localPositions.push(groupStart - start);
        }
    }
    return new Tree(outerType, localChildren, localPositions, length);
}
function containsType(nodes, type) {
    for (let elt of nodes)
        if (elt.type == type)
            return true;
    return false;
}
/// Tree fragments are used during [incremental
/// parsing](#lezer.ParseOptions.fragments) to track parts of old
/// trees that can be reused in a new parse. An array of fragments is
/// used to track regions of an old tree whose nodes might be reused
/// in new parses. Use the static
/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update
/// fragments for document changes.
class TreeFragment {
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, open) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = open;
    }
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        let cI = 0, pos = 0, off = 0;
        for (;;) {
            let nextC = cI < changes.length ? changes[cI++] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null :
                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the token at its
    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
}
// Creates an `Input` that is backed by a single, flat string.
function stringInput(input) { return new StringInput(input); }
class StringInput {
    constructor(string, length = string.length) {
        this.string = string;
        this.length = length;
    }
    get(pos) {
        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
    }
    lineAfter(pos) {
        if (pos < 0)
            return "";
        let end = this.string.indexOf("\n", pos);
        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
    }
    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }
    clip(at) { return new StringInput(this.string, at); }
}

exports.DefaultBufferLength = DefaultBufferLength;
exports.NodeProp = NodeProp;
exports.NodeSet = NodeSet;
exports.NodeType = NodeType;
exports.Tree = Tree;
exports.TreeBuffer = TreeBuffer;
exports.TreeCursor = TreeCursor;
exports.TreeFragment = TreeFragment;
exports.stringInput = stringInput;
//# sourceMappingURL=tree.cjs.map


/***/ }),

/***/ "./node_modules/lezer/dist/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/lezer/dist/index.cjs ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var lezerTree = __webpack_require__(/*! lezer-tree */ "./node_modules/lezer-tree/dist/tree.cjs");

/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// A group of values that the stack will share with all
    /// split instances
    ///@internal
    cx, 
    /// Holds state, pos, value stack pos (15 bits array index, 15 bits
    /// buffer index) triplets for all but the top state
    /// @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.cx = cx;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(cx, state, pos = 0) {
        return new Stack(cx, [], state, pos, pos, 0, [], 0, null);
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.cx;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            // Zero-depth reductions are a special caseâ€”they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let start = this.pos, nextState = action, { parser } = this.cx;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            if (next <= this.cx.parser.maxNode)
                this.buffer.push(next, this.pos, nextEnd, 4);
            this.pos = nextEnd;
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt node into the buffer. This may be a reused node or
    // the result of running a nested parser.
    /// @internal
    useNode(value, next) {
        let index = this.cx.reused.length - 1;
        if (index < 0 || this.cx.reused[index] != value) {
            this.cx.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.cx.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 200 /* Token */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    /// Find the start position of the rule that is currently being parsed.
    get ruleStart() {
        for (let state = this.state, base = this.stack.length;;) {
            let force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);
            if (!(force & 65536 /* ReduceFlag */))
                return 0;
            base -= 3 * (force >> 19 /* ReduceDepthShift */);
            if ((force & 65535 /* ValueMask */) < this.cx.parser.minRepeatTerm)
                return this.stack[base + 1];
            state = this.stack[base];
        }
    }
    /// Find the start position of an instance of any of the given term
    /// types, or return `null` when none of them are found.
    ///
    /// **Note:** this is only reliable when there is at least some
    /// state that unambiguously matches the given rule on the stack.
    /// I.e. if you have a grammar like this, where the difference
    /// between `a` and `b` is only apparent at the third token:
    ///
    ///     a { b | c }
    ///     b { "x" "y" "x" }
    ///     c { "x" "y" "z" }
    ///
    /// Then a parse state after `"x"` will not reliably tell you that
    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check
    /// for either of those two rules (assuming that `a` isn't part of
    /// some rule that includes other things starting with `"x"`).
    ///
    /// When `before` is given, this keeps scanning up the stack until
    /// it finds a match that starts before that position.
    startOf(types, before) {
        let state = this.state, frame = this.stack.length, { parser } = this.cx;
        for (;;) {
            let force = parser.stateSlot(state, 5 /* ForcedReduce */);
            let depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;
            if (types.indexOf(term) > -1) {
                let base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];
                if (before == null || before > pos)
                    return pos;
            }
            if (frame == 0)
                return null;
            if (depth == 0) {
                frame -= 3;
                state = this.stack[frame];
            }
            else {
                frame -= 3 * (depth - 1);
                state = parser.getGoto(this.stack[frame - 3], term, true);
            }
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.cx.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next));
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)
                    if (best.indexOf(nextStates[i]) < 0)
                        best.push(nextStates[i]);
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {
            if (nextStates[i] == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(nextStates[i], this.pos);
            stack.score -= 200 /* Token */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        if (!this.cx.parser.validAction(this.state, reduce)) {
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.cx;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.cx.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.cx.parser.dialect.flags[dialectID]; }
}
var Recover;
(function (Recover) {
    Recover[Recover["Token"] = 200] = "Token";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(stack) {
        this.stack = stack;
        this.top = stack.state;
        this.rest = stack.stack;
        this.offset = this.rest.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.rest == this.stack.stack)
                this.rest = this.rest.slice();
            this.rest.push(this.top, 0, 0);
            this.offset += 3;
        }
        else {
            this.offset -= (depth - 1) * 3;
        }
        let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);
        this.top = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack) {
        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

/// Tokenizers write the tokens they read into instances of this class.
class Token {
    constructor() {
        /// The start of the token. This is set by the parser, and should not
        /// be mutated by the tokenizer.
        this.start = -1;
        /// This starts at -1, and should be updated to a term id when a
        /// matching token is found.
        this.value = -1;
        /// When setting `.value`, you should also set `.end` to the end
        /// position of the token. (You'll usually want to use the `accept`
        /// method.)
        this.end = -1;
    }
    /// Accept a token, setting `value` and `end` to the given values.
    accept(value, end) {
        this.value = value;
        this.end = end;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, token, stack) { readToken(this.data, input, token, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// Exports that are used for `@external tokens` in the grammar should
/// export an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream and a token object,
    /// [fills](#lezer.Token.accept) the token object if it recognizes a
    /// token. `token.start` should be used as the start position to
    /// scan from.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, token, stack, group) {
    let state = 0, groupMask = 1 << group, dialect = stack.cx.parser.dialect;
    scan: for (let pos = token.start;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value))) {
                    token.accept(term, pos);
                    break;
                }
            }
        let next = input.get(pos++);
        // Do a binary search on the state's edges
        for (let low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError)
                    return side < 0 ? cursor.to - 1 : cursor.from + 1;
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments) {
        this.fragments = fragments;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            else if (start == pos && start + next.length <= this.safeTo) {
                return start == pos && start >= this.safeFrom ? next : null;
            }
            if (next instanceof lezerTree.TreeBuffer) {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
            else {
                this.index[last]++;
                if (start + next.length >= pos) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
        }
    }
}
class CachedToken extends Token {
    constructor() {
        super(...arguments);
        this.extended = -1;
        this.mask = 0;
    }
    clear(start) {
        this.start = start;
        this.value = this.extended = -1;
    }
}
const dummyToken = new Token;
class TokenCache {
    constructor(parser) {
        this.tokens = [];
        this.mainToken = dummyToken;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack, input) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.cx, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {
                this.updateCachedToken(token, tokenizer, stack, input);
                token.mask = mask;
            }
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (!main) {
            main = dummyToken;
            main.start = stack.pos;
            if (stack.pos == input.length)
                main.accept(stack.cx.parser.eofTerm, stack.pos);
            else
                main.accept(0 /* Err */, stack.pos + 1);
        }
        this.mainToken = main;
        return this.actions;
    }
    updateCachedToken(token, tokenizer, stack, input) {
        token.clear(stack.pos);
        tokenizer.token(input, token, stack);
        if (token.value > -1) {
            let { parser } = stack.cx;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](input.read(token.start, token.end), stack);
                    if (result >= 0 && stack.cx.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else if (stack.pos == input.length) {
            token.accept(stack.cx.parser.eofTerm, stack.pos);
        }
        else {
            token.accept(0 /* Err */, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.cx, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 1), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec[Rec["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));
/// A parse context can be used for step-by-step parsing. After
/// creating it, you repeatedly call `.advance()` until it returns a
/// tree to indicate it has reached the end of the parse.
class Parse {
    constructor(parser, input, startPos, context) {
        this.parser = parser;
        this.input = input;
        this.startPos = startPos;
        this.context = context;
        // The position to which the parse has advanced.
        this.pos = 0;
        this.recovering = 0;
        this.nextStackID = 0x2654;
        this.nested = null;
        this.nestEnd = 0;
        this.nestWrap = null;
        this.reused = [];
        this.tokens = new TokenCache(parser);
        this.topTerm = parser.top[1];
        this.stacks = [Stack.start(this, parser.top[0], this.startPos)];
        let fragments = context === null || context === void 0 ? void 0 : context.fragments;
        this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        if (this.nested) {
            let result = this.nested.advance();
            this.pos = this.nested.pos;
            if (result) {
                this.finishNested(this.stacks[0], result);
                this.nested = null;
            }
            return null;
        }
        let stacks = this.stacks, pos = this.pos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        let maybeNest;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], nest;
            for (;;) {
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (nest = this.checkNest(stack)) {
                    if (!maybeNest || maybeNest.stack.score < stack.score)
                        maybeNest = nest;
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.mainToken;
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (maybeNest) {
            this.startNested(maybeNest);
            return null;
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.pos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.pos)
                this.pos = newStacks[i].pos;
        return null;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { input, parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.fragments) {
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof lezerTree.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof lezerTree.Tree)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        let actions = this.tokens.getActions(stack, input);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            let nest = this.checkNest(stack);
            if (nest)
                return nest;
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        let maybeNest;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    continue;
                }
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done) {
                    if (done !== true)
                        maybeNest = done;
                    break;
                }
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.input.length > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        if (finished)
            return finished;
        if (maybeNest)
            for (let s of this.stacks)
                if (s.score > maybeNest.stack.score) {
                    maybeNest = undefined;
                    break;
                }
        if (maybeNest)
            this.startNested(maybeNest);
        return null;
    }
    forceFinish() {
        let stack = this.stacks[0].split();
        if (this.nested)
            this.finishNested(stack, this.nested.forceFinish());
        return this.stackToTree(stack.forceAll());
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack, pos = stack.pos) {
        return lezerTree.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.startPos,
            length: pos - this.startPos,
            minRepeatType: this.parser.minRepeatTerm });
    }
    checkNest(stack) {
        let info = this.parser.findNested(stack.state);
        if (!info)
            return null;
        let spec = info.value;
        if (typeof spec == "function")
            spec = spec(this.input, stack);
        return spec ? { stack, info, spec } : null;
    }
    startNested(nest) {
        let { stack, info, spec } = nest;
        this.stacks = [stack];
        this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
        this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
        if (spec.startParse) {
            this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
        }
        else {
            this.finishNested(stack);
        }
    }
    scanForNestEnd(stack, endToken, filter) {
        for (let pos = stack.pos; pos < this.input.length; pos++) {
            dummyToken.start = pos;
            dummyToken.value = -1;
            endToken.token(this.input, dummyToken, stack);
            if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
                return pos;
        }
        return this.input.length;
    }
    finishNested(stack, tree) {
        if (this.nestWrap)
            tree = new lezerTree.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
        else if (!tree)
            tree = new lezerTree.Tree(lezerTree.NodeType.none, [], [], this.nestEnd - stack.pos);
        let info = this.parser.findNested(stack.state);
        stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
        if (verbose)
            console.log(this.stackID(stack) + ` (via unnest)`);
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class Parser {
    /// @internal
    constructor(spec) {
        /// @internal
        this.bufferLength = lezerTree.DefaultBufferLength;
        /// @internal
        this.strict = false;
        this.nextStateCache = [];
        this.cachedDialect = null;
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let tokenArray = decodeArray(spec.tokenData);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        this.nodeSet = new lezerTree.NodeSet(nodeNames.map((name, i) => lezerTree.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {
            return { name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };
        });
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        for (let i = 0, l = this.states.length / 6 /* Size */; i < l; i++)
            this.nextStateCache[i] = null;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    /// Parse a given string or stream.
    parse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        let cx = new Parse(this, input, startPos, context);
        for (;;) {
            let done = cx.advance();
            if (done)
                return done;
        }
    }
    /// Start an incremental parse.
    startParse(input, startPos = 0, context = {}) {
        if (typeof input == "string")
            input = lezerTree.stringInput(input);
        return new Parse(this, input, startPos, context);
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    findNested(state) {
        let flags = this.stateSlot(state, 0 /* Flags */);
        return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let cached = this.nextStateCache[state];
        if (cached)
            return cached;
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && result.indexOf(this.data[i + 1]) < 0)
                result.push(this.data[i + 1]);
        }
        let table = this.goto, max = table[0];
        for (let term = 0; term < max; term++) {
            for (let pos = table[term + 1];;) {
                let groupTag = table[pos++], target = table[pos++];
                for (let end = pos + (groupTag >> 1); pos < end; pos++)
                    if (table[pos] == state && result.indexOf(target) < 0)
                        result.push(target);
                if (groupTag & 1)
                    break;
            }
        }
        return this.nextStateCache[state] = result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(Parser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.nested)
            copy.nested = this.nested.map(obj => {
                if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))
                    return obj;
                return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };
            });
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// Tells you whether this grammar has any nested grammars.
    get hasNested() { return this.nested.length > 0; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        if (this.cachedDialect && this.cachedDialect.source == dialect)
            return this.cachedDialect;
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return this.cachedDialect = new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new Parser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        if (stack.pos == stack.cx.input.length &&
            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}

exports.NodeProp = lezerTree.NodeProp;
exports.NodeSet = lezerTree.NodeSet;
exports.NodeType = lezerTree.NodeType;
exports.Tree = lezerTree.Tree;
exports.TreeCursor = lezerTree.TreeCursor;
exports.ExternalTokenizer = ExternalTokenizer;
exports.Parser = Parser;
exports.Stack = Stack;
exports.Token = Token;
//# sourceMappingURL=index.cjs.map


/***/ }),

/***/ "./ast.ts":
/*!****************!*\
  !*** ./ast.ts ***!
  \****************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.countDefDeclStmts = void 0;
function countDefDeclStmts(stmts) {
    var f = function (acc, x) {
        var b = (function () {
            switch (x.tag) {
                case "define": return true;
                case "assign": return !(x.type_ == "");
                default: return false;
            }
        })();
        return (acc[0] && b) ? [true, acc[1] + 1] : [false, acc[1]];
    };
    return stmts.reduce(f, [true, 0])[1];
}
exports.countDefDeclStmts = countDefDeclStmts;


/***/ }),

/***/ "./compiler.ts":
/*!*********************!*\
  !*** ./compiler.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compile = exports.nestedRets = void 0;
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var parser_1 = __webpack_require__(/*! ./parser */ "./parser.ts");
var typechecker_1 = __webpack_require__(/*! ./typechecker */ "./typechecker.ts");
function declTmpVar(n, m) {
    if (m > n) {
        return ["(local $___TMP" + n + " i32)"].concat(declTmpVar(n + 1, m));
    }
    else {
        return [];
    }
}
function nestedRets(stmt) {
    switch (stmt.tag) {
        case "if":
            return !stmt.body1.every(function (s) { return !nestedRets(s); })
                || !stmt.body2.every(function (s) { return !nestedRets(s); })
                || !stmt.body1.every(function (s) { return s.tag != "return"; })
                || !stmt.body2.every(function (s) { return s.tag != "return"; });
        case "while":
            return !stmt.body.every(function (s) { return !nestedRets(s); })
                || !stmt.body.every(function (s) { return s.tag != "return"; });
        default:
            return false;
    }
}
exports.nestedRets = nestedRets;
var watBuilder = /** @class */ (function () {
    function watBuilder() {
        this.defs = [];
        this.decl = [];
        this.body = [];
        this.stackSize = 0;
        this.implReturn = false;
    }
    watBuilder.prototype.addInstr = function (instr) {
        this.body = this.body.concat(instr);
        return this;
    };
    watBuilder.prototype.addDecl = function (decl) {
        this.decl = this.decl.concat(decl);
        return this;
    };
    watBuilder.prototype.setStackSize = function (size) {
        this.stackSize = size;
        return this;
    };
    watBuilder.prototype.addExpr = function (expr) {
        switch (expr.tag) {
            case "id":
                return this.addInstr(["(local.get $" + expr.name + ")"]);
            case "literal": {
                var literal = expr.value;
                switch (literal.tag) {
                    case "bool":
                        var s = (literal.value) ? ["(i32.const 1)"] : ["(i32.const 0)"];
                        return this.addInstr(s);
                    case "number":
                        return this.addInstr(["(i32.const " + literal.value + ")"]);
                    default:
                        throw new Error("None not implemented yet");
                }
            }
            case "call":
                return this.addCall(expr);
            case "uniop": {
                var instr = (function () {
                    switch (expr.uniop) {
                        case "not":
                            return ["(i32.const 1)", "(i32.xor)"];
                        case "neg":
                            return ["(i32.const -1)", "(i32.mul)"];
                    }
                })();
                return this.addExpr(expr.arg).addInstr(instr);
            }
            case "binop": {
                var binop = (function () {
                    switch (expr.binop) {
                        case "+": return "add";
                        case "-": return "sub";
                        case "*": return "mul";
                        case "//": return "div_s";
                        case "%": return "rem_s";
                        case "==": return "eq";
                        case "!=": return "neq";
                        case "<=": return "le_s";
                        case ">=": return "ge_s";
                        case "<": return "lt_s";
                        case ">": return "gt_s";
                        case "is": throw new Error("Not implemented");
                    }
                })();
                return this.addExpr(expr.arg1)
                    .addExpr(expr.arg2)
                    .addInstr(["(i32." + binop + ")"]);
            }
            case "parens":
                return this.addExpr(expr.expr);
        }
    };
    watBuilder.prototype.addMaxInline = function (arg1, arg2) {
        console.log(this);
        console.log(arg1);
        console.log(this.addExpr(arg1));
        console.log(this.addInstr(["(local.set $___TMP0)"]));
        var tmp = this.addExpr(arg1)
            .addInstr(["(local.set $___TMP0)"])
            .addExpr(arg2)
            .addInstr(["(local.set $___TMP1)",
            "(local.get $___TMP0)",
            "(local.get $___TMP1)",
            "(local.get $___TMP0)",
            "(local.get $___TMP1)",
            "(i32.gt_s)",
            "(select)"]);
        return tmp.addDecl(declTmpVar(tmp.stackSize, 2))
            .setStackSize(Math.max(2, tmp.stackSize));
    };
    watBuilder.prototype.addMinInline = function (arg1, arg2) {
        var tmp = this.addExpr(arg1)
            .addInstr(["(local.set $___TMP0)"])
            .addExpr(arg2)
            .addInstr(["(local.set $___TMP1)",
            "(local.get $___TMP0)",
            "(local.get $___TMP1)",
            "(local.get $___TMP0)",
            "(local.get $___TMP1)",
            "(i32.lt_s)",
            "(select)"]);
        return tmp.addDecl(declTmpVar(tmp.stackSize, 2))
            .setStackSize(Math.max(2, tmp.stackSize));
    };
    watBuilder.prototype.addAbsInline = function (arg) {
        var tmp = this.addExpr(arg)
            .addInstr(["(local.set $___TMP0)",
            "(local.get $___TMP0)",
            "(local.get $___TMP0)",
            "(i32.const -1)",
            "(i32.mul)",
            "(local.get $___TMP0)",
            "(i32.const 0)",
            "(i32.gt_s)",
            "(select)"]);
        return tmp.addDecl(declTmpVar(tmp.stackSize, 1))
            .setStackSize(Math.max(1, tmp.stackSize));
    };
    watBuilder.prototype.addCall = function (expr) {
        if (expr.tag != "call") {
            throw new Error(expr.tag + " is not a function call");
        }
        switch (expr.name) {
            case "max": return this.addMaxInline(expr.arguments[0], expr.arguments[1]);
            case "min": return this.addMinInline(expr.arguments[0], expr.arguments[1]);
            case "abs": return this.addAbsInline(expr.arguments[0]);
            case "print": {
                switch (expr.arguments[0].type_) {
                    case "int": return this.addExpr(expr.arguments[0])
                        .addInstr(["(call $printI32)"]);
                    case "bool": return this.addExpr(expr.arguments[0])
                        .addInstr(["(call $printBool)"]);
                    case "none": return this.addInstr(["(call $printNone)"]);
                }
            }
            default:
                return expr.arguments.reduce(function (acc, e) { return acc.addExpr(e); }, this)
                    .addInstr(["(call $" + expr.name + ")"]);
        }
    };
    // FIXME: add support for nested functions
    watBuilder.prototype.addFunc = function (stmt) {
        if (stmt.tag != "define") {
            throw new Error("Compiler error. Check code.");
        }
        // number of define statements
        var n = ast_1.countDefDeclStmts(stmt.body);
        var defStmts = stmt.body.slice(0, n);
        var rest = stmt.body.slice(n);
        var iout = defStmts
            .filter(function (s) { return s.tag == "assign"; })
            .reduce(function (acc, s) {
            if (s.tag != "assign") {
                throw new Error("Compiler error. Check code.");
            }
            return acc.addStmt(s)
                .addDecl(["(local $" + s.name + " i32)"]);
        }, new watBuilder);
        // distances between early return statements
        var ds = rest.map(function (k, i) { return [i, k]; })
            .filter(function (t) { return nestedRets(t[1]); })
            .reduce(function (acc, t) {
            var arr = acc[0].concat([t[0] - acc[1]]);
            return [arr, t[0]];
        }, [[], 0])[0];
        var earlyRet = function (code, dists) {
            var n = dists.shift();
            var currSlice = code.slice(0, n + 1);
            var remainder = code.slice(n + 1);
            if (remainder.length == 0) {
                return currSlice;
            }
            else {
                var s = {
                    tag: "if",
                    pred: {
                        tag: "binop",
                        binop: "==",
                        arg1: { tag: "id", name: "___EARLY_RET", type_: "bool" },
                        arg2: { tag: "literal", value: { tag: "bool", value: false }, type_: "bool" },
                        type_: "bool"
                    },
                    body1: (dists.length > 0) ? earlyRet(remainder, dists) : remainder,
                    body2: []
                };
                return currSlice.concat([s]);
            }
        };
        var hasRet = function (r) {
            return !r.every(function (s) { return !nestedRets(s); }) || r[r.length - 1].tag == "return";
        };
        var iout2 = iout.addDecl(hasRet(rest) ? ["(local $___RET_VAL i32)",
            "(local $___EARLY_RET i32)",
            "(i32.const 0)",
            "(local.set $___EARLY_RET)"] : [])
            .addStmts((ds.length > 0) ? earlyRet(rest, ds) : rest)
            .addInstr(hasRet(rest) ? ["(local.get $___RET_VAL)"] : []);
        iout2.body[iout2.body.length - 1] += ")";
        // if any statement contains return statements
        var inputOutput = stmt.parameters
            .map(function (p) { return "(param $" + p.name + " i32)"; })
            .concat(hasRet(rest) ? [" (result i32)"] : [])
            .join(" ");
        this.defs = (["(func $" + stmt.name + " " + inputOutput]).concat(iout2.decl.concat(iout2.body));
        return this;
    };
    watBuilder.prototype.addStmts = function (stmts) {
        if (stmts.length == 0) {
            return this;
        }
        else {
            var lastStmt = stmts[stmts.length - 1];
            if (lastStmt.tag == "expr") {
                if (lastStmt.expr.type_ != "none") {
                    this.implReturn = true;
                }
            }
            return stmts.reduce(function (acc, s) { return acc.addStmt(s); }, this);
        }
    };
    watBuilder.prototype.addStmt = function (stmt) {
        switch (stmt.tag) {
            case "define":
                return this.addFunc(stmt);
            case "return":
                // TODO: see if you can optimize away the last two instructions when there
                // is no branching
                return this.addExpr(stmt.value)
                    .addInstr(["(local.set $___RET_VAL)",
                    "(i32.const 1)",
                    "(local.set $___EARLY_RET)"]);
            case "assign": {
                return this.addExpr(stmt.value)
                    .addInstr(["(local.set $" + stmt.name + ")"]);
            }
            case "expr":
                // the typechecker should prevent this EXCEPT for a lone expression at the
                // end of the program which will be implicitly returned
                // TODO: make into a print statement
                if (stmt.expr.type_ == "none") {
                    return this.addExpr(stmt.expr);
                }
                else {
                    return this.addExpr(stmt.expr)
                        .addInstr(["(local.set $___IMPL_RET)"]);
                }
            case "if": {
                var tmp = this.addExpr(stmt.pred)
                    .addInstr(["(if", "(then"]) // typechecker disallows empty body1
                    .addStmts(stmt.body1);
                tmp.body[tmp.body.length - 1] = tmp.body[tmp.body.length - 1] + ")";
                if (stmt.body2.length > 0) {
                    var tmp_ = tmp.addInstr(["(else"])
                        .addStmts(stmt.body2);
                    tmp_.body[tmp_.body.length - 1] = tmp_.body[tmp_.body.length - 1] + "))";
                    return tmp_;
                }
                else {
                    tmp.body[tmp.body.length - 1] = tmp.body[tmp.body.length - 1] + ")";
                    return tmp;
                }
            }
            case "while": {
                // TODO: remove xor and switch 1 and 0 in br_if and br after writing
                // tests for more optimized code
                return this.addExpr(stmt.pred)
                    .addInstr(["(if", "(then", "(loop"])
                    .addStmts(stmt.body)
                    .addExpr(stmt.pred)
                    .addInstr(["(i32.const 1)", "(i32.xor)", "(br_if 1)", "(br 0))))"]);
            }
            case "pass": return this;
        }
    };
    return watBuilder;
}());
// so us mere humans can understand the output
function indent(code) {
    var indented = code.reduce(function (acc, s) {
        var cnt = 0;
        for (var _i = 0, s_1 = s; _i < s_1.length; _i++) {
            var c = s_1[_i];
            if (c == "(") {
                cnt += 1;
            }
            else if (c == ")") {
                cnt -= 1;
            }
        }
        var indentLvl = cnt + acc[0];
        var code_ = acc[1].concat(["  ".repeat(acc[0]) + s]);
        return [indentLvl, code_];
    }, [0, []]);
    return indented[1];
}
;
function compile(source) {
    var ast = parser_1.parseProgram(source);
    var typedAST = typechecker_1.buildTypedAST(ast);
    // number of define statements
    var n = ast_1.countDefDeclStmts(typedAST);
    var defStmts = typedAST.slice(0, n);
    var rest = typedAST.slice(n);
    var iout = defStmts
        .filter(function (s) { return s.tag == "assign"; })
        .reduce(function (acc, s) {
        if (s.tag != "assign") {
            throw new Error("Compiler error. Check code.");
        }
        return acc.addStmt(s)
            .addDecl(["(local $" + s.name + " i32)"]);
    }, new watBuilder)
        .addStmts(defStmts.filter(function (s) { return s.tag == "define"; }))
        .addStmts(rest);
    var progBody = iout.decl.concat(iout.body);
    if (!iout.implReturn) {
        progBody[progBody.length - 1] += "))";
    }
    var out = (iout.implReturn) ? "(result i32)" : "";
    var code = ["(module"].concat(["(func $printI32 (import \"imports\" \"printI32\") (param i32))"], ["(func $printBool (import \"imports\" \"printBool\") (param i32))"], ["(func $printNone (import \"imports\" \"printNone\"))"], ["(func $pow (import \"imports\" \"pow\") (param i32) (param i32) (result i32))"], iout.defs, ["(func (export \"_start\") " + out], ["(local $___IMPL_RET i32)"], progBody, (iout.implReturn) ? ["(local.get $___IMPL_RET)))"] : [""]);
    return indent(code).join("\n");
}
exports.compile = compile;


/***/ }),

/***/ "./errors.ts":
/*!*******************!*\
  !*** ./errors.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UniaryOpTypeError = exports.ParseError = exports.FuncCallTypError = exports.GeneralTypeError = exports.MissingReturn = exports.NotDeclaredInScope = exports.NotAVariable = exports.NotAFunctionOrClass = exports.DuplicateDeclaration = exports.ConditionalExprTypeError = exports.CompilerError = exports.BinaryOpTypeError = void 0;
var BinaryOpTypeError = /** @class */ (function (_super) {
    __extends(BinaryOpTypeError, _super);
    function BinaryOpTypeError(op, t1, t2) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Cannot apply operator `" + op + "` on types `" + t1 + "` and `" + t2 + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'BinaryOpTypeError';
        _this.op = op;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return BinaryOpTypeError;
}(Error));
exports.BinaryOpTypeError = BinaryOpTypeError;
var CompilerError = /** @class */ (function (_super) {
    __extends(CompilerError, _super);
    function CompilerError() {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'CompilerError';
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return CompilerError;
}(Error));
exports.CompilerError = CompilerError;
var ConditionalExprTypeError = /** @class */ (function (_super) {
    __extends(ConditionalExprTypeError, _super);
    function ConditionalExprTypeError(conditionalType) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Conditional expression cannot be of type `" + conditionalType + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'ConditionalExprTypeError';
        _this.conditionalType = conditionalType;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return ConditionalExprTypeError;
}(Error));
exports.ConditionalExprTypeError = ConditionalExprTypeError;
var DuplicateDeclaration = /** @class */ (function (_super) {
    __extends(DuplicateDeclaration, _super);
    function DuplicateDeclaration(ident) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Duplicate declaration of identifier in same scope: " + ident) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, DuplicateDeclaration);
        }
        _this.name = 'DuplicateDeclaration';
        _this.ident = ident;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return DuplicateDeclaration;
}(Error));
exports.DuplicateDeclaration = DuplicateDeclaration;
var NotAFunctionOrClass = /** @class */ (function (_super) {
    __extends(NotAFunctionOrClass, _super);
    function NotAFunctionOrClass(objName) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Not a function or class: " + objName) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'NotAFunctionOrClass';
        _this.objName = objName;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return NotAFunctionOrClass;
}(Error));
exports.NotAFunctionOrClass = NotAFunctionOrClass;
var NotAVariable = /** @class */ (function (_super) {
    __extends(NotAVariable, _super);
    function NotAVariable(varName) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Not a variable: " + varName) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotAVariable);
        }
        _this.name = 'NotAVariable';
        _this.varName = varName;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return NotAVariable;
}(Error));
exports.NotAVariable = NotAVariable;
var NotDeclaredInScope = /** @class */ (function (_super) {
    __extends(NotDeclaredInScope, _super);
    function NotDeclaredInScope(varName) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Cannot assign to variable that is not explicitly decalared in this scope: " + varName) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'NotDeclaredInScope';
        _this.varName = varName;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return NotDeclaredInScope;
}(Error));
exports.NotDeclaredInScope = NotDeclaredInScope;
var MissingReturn = /** @class */ (function (_super) {
    __extends(MissingReturn, _super);
    function MissingReturn(f) {
        var _newTarget = this.constructor;
        if (f === void 0) { f = "contains"; }
        var _this = _super.call(this, "All paths in this function/method must have a return statement: " + f) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'MissingReturn';
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return MissingReturn;
}(Error));
exports.MissingReturn = MissingReturn;
var GeneralTypeError = /** @class */ (function (_super) {
    __extends(GeneralTypeError, _super);
    function GeneralTypeError(actualType, expectedType) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Expected type `" + expectedType + "`; got type `" + actualType + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'GeneralTypeError';
        _this.actualType = actualType;
        _this.expectedType = expectedType;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return GeneralTypeError;
}(Error));
exports.GeneralTypeError = GeneralTypeError;
var FuncCallTypError = /** @class */ (function (_super) {
    __extends(FuncCallTypError, _super);
    function FuncCallTypError(actualType, expectedType, paramN) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Expected type `" + expectedType + "`; got type `" + actualType + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, FuncCallTypError);
        }
        _this.name = 'FuncCallTypError';
        _this.actualType = actualType;
        _this.expectedType = expectedType;
        _this.paramN = paramN;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return FuncCallTypError;
}(Error));
exports.FuncCallTypError = FuncCallTypError;
var ParseError = /** @class */ (function (_super) {
    __extends(ParseError, _super);
    function ParseError(token) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Parse error near token " + token) || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'ParseError';
        _this.token = token;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return ParseError;
}(Error));
exports.ParseError = ParseError;
var UniaryOpTypeError = /** @class */ (function (_super) {
    __extends(UniaryOpTypeError, _super);
    function UniaryOpTypeError(op, t) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, "Cannot apply operator `" + op + "` on type `" + t + "`") || this;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotDeclaredInScope);
        }
        _this.name = 'UniaryOpTypeError';
        _this.op = op;
        _this.t = t;
        _this.__proto__ = _newTarget.prototype;
        return _this;
    }
    return UniaryOpTypeError;
}(Error));
exports.UniaryOpTypeError = UniaryOpTypeError;


/***/ }),

/***/ "./parser.ts":
/*!*******************!*\
  !*** ./parser.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.traverseExpr = exports.traverseParameters = exports.traverseStmt = exports.parseFollowingStmts = exports.parseProgram = void 0;
var lezer_python_1 = __webpack_require__(/*! lezer-python */ "./node_modules/lezer-python/dist/index.cjs");
var errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
function parseProgram(source) {
    var t = lezer_python_1.parser.parse(source).cursor();
    // The top node in the program is a Script node with a list of children
    // that are various statements
    t.firstChild();
    return parseFollowingStmts(source, t);
}
exports.parseProgram = parseProgram;
function parseFollowingStmts(s, t) {
    var stmts = [];
    do {
        var stmt = traverseStmt(s, t);
        stmts.push(stmt);
        // drop all statements after pass or early return
        if (stmt.tag == "pass" || stmt.tag == "return") {
            break;
        }
    } while (t.nextSibling()); // t.nextSibling() returns false when it reaches
    //  the end of the list of children
    return stmts;
}
exports.parseFollowingStmts = parseFollowingStmts;
/*
  Invariant â€“ t must focus on the same node at the end of the traversal
*/
function traverseStmt(s, t) {
    switch (t.type.name) {
        case "ReturnStatement": {
            t.firstChild(); // Focus return keyword
            t.nextSibling(); // Focus expression
            var value = traverseExpr(s, t);
            t.parent();
            return { tag: "return", value: value };
        }
        case "AssignStatement": {
            t.firstChild(); // focused on name (the first child)
            var name_1 = s.substring(t.from, t.to);
            t.nextSibling(); // the declared type (if any)
            var type_ = (function () {
                if (t.firstChild()) { // : in the type declaration
                    t.nextSibling(); // the actual declared type
                    var substr = s.substring(t.from, t.to);
                    t.parent();
                    if (substr == "bool" || substr == "int") {
                        return substr;
                    }
                }
                return "";
            })();
            t.nextSibling(); // focused on = sign. May need this for complex tasks, like +=!
            t.nextSibling(); // focused on the value expression
            var value = traverseExpr(s, t);
            t.parent();
            return { tag: "assign", name: name_1, type_: type_, value: value };
        }
        case "ExpressionStatement": {
            t.firstChild(); // The child is some kind of expression, the
            // ExpressionStatement is just a wrapper with no information
            var expr = traverseExpr(s, t);
            t.parent();
            return { tag: "expr", expr: expr };
        }
        case "IfStatement": {
            t.firstChild(); // if statement
            var traverseIfs_1 = function (s, t) {
                if ((["if", "elif"]).includes(t.node.type.name)) {
                    t.nextSibling(); // the predicate
                    var pred = traverseExpr(s, t);
                    t.nextSibling(); // the body
                    t.firstChild(); // : before the body
                    t.nextSibling(); // the first statement of the body
                    var body1 = parseFollowingStmts(s, t);
                    // Body immediately after if cannot be empty
                    if (body1.length == 0) {
                        throw new errors_1.ParseError("DEDENT");
                    }
                    t.parent(); // Body
                    t.nextSibling(); // elif/else (if any)
                    return [{ tag: "if", pred: pred, body1: body1, body2: traverseIfs_1(s, t) }];
                }
                else if (t.node.type.name == "else") { // else
                    t.nextSibling(); // the body
                    t.firstChild(); // : before the body
                    t.nextSibling(); // the first statement of the body
                    var body_1 = parseFollowingStmts(s, t);
                    t.parent();
                    return body_1;
                }
                else {
                    // no else
                    return [];
                }
            };
            var ifstmt = traverseIfs_1(s, t);
            t.parent();
            return ifstmt[0];
        }
        case "WhileStatement": {
            t.firstChild(); // while
            t.nextSibling(); // predicate
            var pred = traverseExpr(s, t);
            t.nextSibling(); // Body
            t.firstChild(); // colon
            t.nextSibling(); // statement
            var body_2 = parseFollowingStmts(s, t);
            t.parent();
            t.parent();
            return { tag: "while", pred: pred, body: body_2 };
        }
        case "PassStatement": return { tag: "pass" };
        case "FunctionDefinition":
            t.firstChild(); // Focus on def
            t.nextSibling(); // Focus on name of function
            var name_2 = s.substring(t.from, t.to);
            t.nextSibling(); // Focus on ParamList
            var parameters = traverseParameters(s, t);
            t.nextSibling();
            var outputType = (function () {
                if (t.node.type.name == "TypeDef") {
                    t.firstChild();
                    t.nextSibling(); // the actual declared type
                    var substr = s.substring(t.from, t.to);
                    t.parent();
                    if (substr == "bool" || substr == "int") {
                        return substr;
                    }
                    t.nextSibling(); // Focus on Body
                }
                else {
                    var outputType_1 = "none";
                }
            })();
            t.nextSibling(); // Focus on :
            t.firstChild();
            t.nextSibling();
            var body = parseFollowingStmts(s, t);
            if (body.length == 0) {
                throw new errors_1.ParseError("EOF");
            }
            ;
            t.parent(); // Pop to Body
            t.parent(); // Pop to FunctionDefinition
            return { tag: "define", name: name_2, parameters: parameters, outputType: outputType, body: body };
    }
}
exports.traverseStmt = traverseStmt;
function traverseParameters(s, t) {
    var parameters = [];
    t.firstChild(); // Focuses on open paren
    do {
        t.nextSibling(); // Focuses on a VariableName
        var name_3 = s.substring(t.from, t.to);
        if (name_3 == ")") {
            break;
        }
        t.nextSibling(); // Focuses on a typedef, if any
        if (t.node.type.name == "TypeDef") {
            t.firstChild(); // : in the type declaration
            t.nextSibling(); // the actual declared type
            var type_ = s.substring(t.from, t.to);
            t.parent(); // back to parameter
            parameters.push({ name: name_3, type_: type_ });
        }
        else {
            throw new Error("Parse error near token RPAREN: " + s.substring(t.node.from, t.node.to));
        }
        t.nextSibling(); // Focus on , or )
    } while (s.substring(t.from, t.to) != ")");
    t.parent(); // Pop to ParamList
    return parameters;
}
exports.traverseParameters = traverseParameters;
function traverseExpr(s, t) {
    switch (t.type.name) {
        case "Number":
            return {
                tag: "literal",
                value: {
                    tag: "number",
                    value: Number(s.substring(t.from, t.to))
                },
                type_: "int"
            };
        case "Boolean": {
            var bool = (function () {
                switch (s.substring(t.from, t.to)) {
                    case "True": return true;
                    case "False": return false;
                }
            })();
            return {
                tag: "literal",
                value: {
                    tag: "bool",
                    value: bool
                },
                type_: "bool"
            };
        }
        case "VariableName":
            return { tag: "id", name: s.substring(t.from, t.to), type_: "" };
        case "CallExpression": {
            t.firstChild(); // Focus name
            var name_4 = s.substring(t.from, t.to);
            t.nextSibling(); // Focus ArgList
            t.firstChild(); // Focus open paren
            var argList = [];
            do {
                t.nextSibling(); // Focus on parameter
                argList.push(traverseExpr(s, t));
                t.nextSibling(); // Focus on , or )
            } while (s.substring(t.from, t.to) != ")");
            t.parent();
            t.parent();
            return { tag: "call", name: name_4, arguments: argList, type_: "" };
        }
        case "UnaryExpression": {
            t.firstChild();
            var uniop = (function () {
                switch (s.substring(t.from, t.to)) {
                    case "-": return "neg";
                    case "not": return "not";
                    default:
                        throw new Error("Not implemented at " + t.from + " " + t.to + ": " + s.substring(t.from, t.to));
                }
            })();
            t.nextSibling();
            var arg = traverseExpr(s, t);
            t.parent();
            return { tag: "uniop", arg: arg, uniop: uniop, type_: "" };
        }
        case "BinaryExpression": {
            t.firstChild();
            var arg1 = traverseExpr(s, t);
            t.nextSibling();
            var binop = (function () {
                var str = s.substring(t.from, t.to);
                var intOps = ["+", "-", "*", "//", "%", "==", "!=", ">=", "<=", ">", "<"];
                if (intOps.includes(str)) {
                    return str;
                }
                else {
                    throw new Error("Not implemented at " + t.from + " " + t.to + ": " + s.substring(t.from, t.to));
                }
            })();
            t.nextSibling();
            var arg2 = traverseExpr(s, t);
            t.parent();
            return { tag: "binop", arg1: arg1, arg2: arg2, binop: binop, type_: "" };
        }
        case "ParenthesizedExpression": {
            t.firstChild(); // focuses on "("
            t.nextSibling();
            var e = traverseExpr(s, t);
            console.log(e);
            t.parent();
            return { tag: "parens", expr: e, type_: "" };
        }
    }
}
exports.traverseExpr = traverseExpr;


/***/ }),

/***/ "./runner.ts":
/*!*******************!*\
  !*** ./runner.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.run = exports.runPython = exports.importObject = void 0;
var wabt_1 = __importDefault(__webpack_require__(/*! wabt */ "wabt"));
var compiler_1 = __webpack_require__(/*! ./compiler */ "./compiler.ts");
exports.importObject = {
    imports: {
        // we typically define print to mean logging to the console. To make testing
        // the compiler easier, we define print so it logs to a string object.
        //  We can then examine output to see what would have been printed in the
        //  console.
        printI32: function (arg) {
            exports.importObject.output += arg;
            exports.importObject.output += "\n";
        },
        printBool: function (arg) {
            if (arg == 1) {
                exports.importObject.output += "True\n";
            }
            else if (arg == 0) {
                exports.importObject.output += "False\n";
            }
            else {
                throw new Error("Calling printBool on an i32 argument");
            }
        },
        printNone: function () {
            exports.importObject.output += "None\n";
        },
        pow: function (x, y) {
            return Math.pow(x, y);
        },
    },
    output: ""
};
function runPython(pythonSrouce) {
    return __awaiter(this, void 0, void 0, function () {
        var wat;
        return __generator(this, function (_a) {
            wat = compiler_1.compile(pythonSrouce);
            return [2 /*return*/, run(wat)];
        });
    });
}
exports.runPython = runPython;
function run(watSource) {
    return __awaiter(this, void 0, void 0, function () {
        var wabtApi, parsed, binary, wasmModule;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, wabt_1.default()];
                case 1:
                    wabtApi = _a.sent();
                    parsed = wabtApi.parseWat("example", watSource);
                    binary = parsed.toBinary({});
                    return [4 /*yield*/, WebAssembly.instantiate(binary.buffer, exports.importObject)];
                case 2:
                    wasmModule = _a.sent();
                    // This next line is wasm-interp
                    return [2 /*return*/, wasmModule.instance.exports._start()];
            }
        });
    });
}
exports.run = run;


/***/ }),

/***/ "./typechecker.ts":
/*!************************!*\
  !*** ./typechecker.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inferExprType = exports.checkReturnType = exports.fillInStmtsTypeInfo = exports.buildTypedAST = void 0;
var ast_1 = __webpack_require__(/*! ./ast */ "./ast.ts");
var errors_1 = __webpack_require__(/*! ./errors */ "./errors.ts");
// FIXME: the rhs of variable declaration can only be literals
function buildTypedAST(prog) {
    var builtin = new Map;
    builtin.set("print", { parameterTypes: ["polymorphic"], outputType: "none" });
    builtin.set("abs", { parameterTypes: ["int"], outputType: "int" });
    builtin.set("max", { parameterTypes: ["int", "int"], outputType: "int" });
    builtin.set("min", { parameterTypes: ["int", "int"], outputType: "int" });
    builtin.set("pow", { parameterTypes: ["int", "int"], outputType: "int" });
    return fillInStmtsTypeInfo(prog, new Map, builtin, "none");
}
exports.buildTypedAST = buildTypedAST;
// A failure in the typechecking process leads to an unrecoverable failure so we
// might as well throw an error and exit. A pass at this stage however does not
// warrant any action.
function fillInStmtsTypeInfo(stmts, outerVarScope, outerFuncScope, retType) {
    // All the function definitions and variable declarations must be at the top
    // of the scope. The order of defs or decls doesn't matter--they can even be
    // interweaved, as long as no computation happens before then end of this
    // block. We'll call this the preamble.
    // Get the statement number where the preamble ends
    var n = ast_1.countDefDeclStmts(stmts);
    // extract the assignment and definition statements
    var declBlock = stmts.slice(0, n).filter(function (x) { return x.tag == "assign"; });
    var defBlock = stmts.slice(0, n).filter(function (x) { return x.tag == "define"; });
    // check for deplicate declaration of identifiers
    var idents = new Map;
    for (var _i = 0, _a = stmts.slice(0, n); _i < _a.length; _i++) {
        var stmt = _a[_i];
        if (stmt.tag != "assign" && stmt.tag != "define") {
            throw new Error("Compiler error. Check code.");
        }
        ;
        if (idents.has(stmt.name)) {
            throw new errors_1.DuplicateDeclaration(stmt.name);
        }
        ;
        idents.set(stmt.name, stmt);
    }
    // Keep a table of variables and their types
    // Note: definitions in the current scope will overwrite definitions from
    // outerscope if there are conflicts
    var varScope = declBlock.map(function (stmt) {
        if (stmt.tag != "assign") {
            throw new Error("Compiler error. Check code.");
        }
        ;
        if (stmt.type_ == "") {
            throw new errors_1.NotAVariable(stmt.name);
        }
        else {
            return stmt;
        }
    })
        // Merge with outer scope. Overwrite type declarations if necessary.
        .reduce(function (map, t) {
        map.set(t.name, t.type_);
        return map;
    }, outerVarScope);
    // Keep a table of all currently defined functions. Overwrite definitions from
    // the outer scope if necessary
    var funcScope = defBlock.reduce(function (map, t) {
        if (t.tag != "define") {
            throw new Error("Compiler error. Check code.");
        }
        ;
        var ftype = {
            parameterTypes: t.parameters.map(function (p) { return p.type_; }),
            outputType: t.outputType
        };
        map.set(t.name, ftype);
        return map;
    }, outerFuncScope);
    // Typecheck each statement
    var addTypes = function (stmt) {
        switch (stmt.tag) {
            case "assign": {
                var rhsType = inferExprType(stmt.value, varScope, funcScope);
                var lhsType = varScope.get(stmt.name);
                if (rhsType != lhsType) {
                    throw new errors_1.GeneralTypeError(lhsType, rhsType);
                }
                return __assign(__assign({}, stmt), { value: fillInExprTypeInfo(stmt.value, varScope, funcScope) });
            }
            case "expr": {
                return __assign(__assign({}, stmt), { expr: fillInExprTypeInfo(stmt.expr, varScope, funcScope) });
            }
            case "define": {
                // ChocoPy functions don't capture variables. Reset scope to be the
                // supplied parameters.
                var varScope_1 = stmt.parameters
                    .concat(declBlock)
                    .reduce(function (map, p) {
                    map.set(p.name, p.type_);
                    return map;
                }, new Map);
                // check statements in the body, including matching return types to the
                // stated output type
                try {
                    fillInStmtsTypeInfo(stmt.body, varScope_1, funcScope, stmt.outputType);
                }
                catch (err) {
                    if (err instanceof errors_1.NotAVariable) {
                        if (varScope_1.has(err.varName)) {
                            throw new errors_1.NotDeclaredInScope(err.varName);
                        }
                    }
                    throw err;
                }
                checkReturnType(stmt.name, stmt.body, varScope_1, funcScope, stmt.outputType);
                var body = fillInStmtsTypeInfo(stmt.body, varScope_1, funcScope, stmt.outputType);
                return __assign(__assign({}, stmt), { body: body });
            }
            case "return": {
                var t = inferExprType(stmt.value, varScope, funcScope);
                if (retType != t) {
                    throw new errors_1.GeneralTypeError(retType, t);
                }
                return __assign(__assign({}, stmt), { value: fillInExprTypeInfo(stmt.value, varScope, funcScope) });
            }
            case "if": {
                var t = inferExprType(stmt.pred, varScope, funcScope);
                if (t != "bool") {
                    throw new errors_1.ConditionalExprTypeError(t);
                }
                var pred = fillInExprTypeInfo(stmt.pred, varScope, funcScope);
                var body1 = fillInStmtsTypeInfo(stmt.body1, varScope, funcScope, retType);
                var body2 = fillInStmtsTypeInfo(stmt.body2, varScope, funcScope, retType);
                return __assign(__assign({}, stmt), { pred: pred, body1: body1, body2: body2 });
            }
            case "while": {
                var t = inferExprType(stmt.pred, varScope, funcScope);
                if (t != "bool") {
                    throw new errors_1.ConditionalExprTypeError(t);
                }
                var pred = fillInExprTypeInfo(stmt.pred, varScope, funcScope);
                var body = fillInStmtsTypeInfo(stmt.body, varScope, funcScope, retType);
                return __assign(__assign({}, stmt), { pred: pred, body: body });
            }
            case "pass": {
                return stmt;
            }
        }
        ;
    };
    return stmts.map(addTypes);
}
exports.fillInStmtsTypeInfo = fillInStmtsTypeInfo;
function checkReturnType(name, stmts, varScope, funcScope, retType) {
    var checkLastStmtRetType = function () {
        // stmts.length == 0 should be caught be a ParseError
        var lastStmt = stmts[stmts.length - 1];
        if (lastStmt.tag == "return") {
            var t = inferExprType(lastStmt.value, varScope, funcScope);
            if (retType != t) {
                throw new errors_1.GeneralTypeError(t, retType);
            }
        }
        else { // no return since "return" is always the last statement
            if (retType != "none") {
                throw new errors_1.MissingReturn(name);
            }
        }
    };
    // no nested statements (aside from func defs, which don't count)
    if (stmts.every(function (s) { return s.tag != "if" && s.tag != "while"; })) {
        checkLastStmtRetType();
        // There exists at least one if or while statement in the array
    }
    else {
        try {
            // check nested statements
            var stmtGroups = stmts.filter(function (s) { return s.tag == "if" || s.tag == "while"; })
                .map(function (s) {
                switch (s.tag) {
                    case "if":
                        return [s.body1, s.body2];
                    case "while":
                        return [s.body];
                }
            })
                .flat();
            for (var _i = 0, stmtGroups_1 = stmtGroups; _i < stmtGroups_1.length; _i++) {
                var s = stmtGroups_1[_i];
                checkReturnType(name, s, varScope, funcScope, retType);
            }
        }
        catch (err) {
            if (err instanceof errors_1.MissingReturn) {
                checkLastStmtRetType();
            }
        }
    }
}
exports.checkReturnType = checkReturnType;
function fillInExprTypeInfo(expr, varScope, funcScope) {
    // leverage the type chekcing code in the inference algorithm
    switch (expr.tag) {
        case "call": {
            var args = expr.arguments.map(function (e) { return fillInExprTypeInfo(e, varScope, funcScope); });
            var type_ = inferExprType(expr, varScope, funcScope);
            return __assign(__assign({}, expr), { arguments: args, type_: type_ });
        }
        case "uniop": {
            var arg = fillInExprTypeInfo(expr.arg, varScope, funcScope);
            var type_ = inferExprType(expr, varScope, funcScope);
            return __assign(__assign({}, expr), { arg: arg, type_: type_ });
        }
        case "binop": {
            var arg1 = fillInExprTypeInfo(expr.arg1, varScope, funcScope);
            var arg2 = fillInExprTypeInfo(expr.arg2, varScope, funcScope);
            var type_ = inferExprType(expr, varScope, funcScope);
            return __assign(__assign({}, expr), { arg1: arg1, arg2: arg2, type_: type_ });
        }
        case "parens": {
            var e = fillInExprTypeInfo(expr.expr, varScope, funcScope);
            var type_ = inferExprType(expr, varScope, funcScope);
            return __assign(__assign({}, expr), { expr: e, type_: type_ });
        }
        default:
            return __assign(__assign({}, expr), { type_: inferExprType(expr, varScope, funcScope) });
    }
}
function inferExprType(expr, varScope, funcScope) {
    switch (expr.tag) {
        case "literal": {
            var literal = expr.value;
            return (literal.tag == "number") ? "int" : literal.tag;
        }
        case "id": return varScope.get(expr.name);
        case "call": {
            if (funcScope.has(expr.name)) {
                var ftype = funcScope.get(expr.name);
                // check parameter types
                var zipped = ftype.parameterTypes.map(function (k, i) { return [i, k, expr.arguments[i]]; });
                for (var _i = 0, zipped_1 = zipped; _i < zipped_1.length; _i++) {
                    var tuple = zipped_1[_i];
                    var paramN = tuple[0];
                    var t1 = tuple[1];
                    var t2 = inferExprType(tuple[2], varScope, funcScope);
                    if (t1 != t2 && t1 != "polymorphic") {
                        throw new errors_1.FuncCallTypError(t1, t2, paramN);
                    }
                }
                return ftype.outputType;
            }
            else {
                throw new errors_1.NotAFunctionOrClass(expr.name);
            }
        }
        case "uniop": {
            var t = inferExprType(expr.arg, varScope, funcScope);
            switch (expr.uniop) {
                case "not": {
                    if (t != "bool") {
                        throw new errors_1.UniaryOpTypeError("not", t);
                    }
                    else {
                        return "bool";
                    }
                }
                case "neg": {
                    if (t != "int") {
                        throw new errors_1.UniaryOpTypeError("neg", t);
                    }
                    else {
                        return "int";
                    }
                }
            }
        }
        case "binop": {
            var t1 = inferExprType(expr.arg1, varScope, funcScope);
            var t2 = inferExprType(expr.arg2, varScope, funcScope);
            var intOps = ["+", "-", "*", "//", "%", "==", "!=", ">=", "<=", ">", "<"];
            if (intOps.includes(expr.binop)) {
                if (t1 != "int" || t2 != "int") {
                    var op = expr.binop;
                    throw new errors_1.BinaryOpTypeError(op, t1, t2);
                }
                else {
                    if ((["+", "-", "*", "//", "%"]).includes(expr.binop)) {
                        return "int";
                    }
                    else {
                        return "bool";
                    }
                }
                // the "is" operator
            }
            else {
                if (t1 == "int" || t1 == "bool" || t2 == "int" || t2 == "bool") {
                    throw new errors_1.BinaryOpTypeError("is", t1, t2);
                }
                else {
                    return "bool";
                }
            }
        }
        case "parens":
            return inferExprType(expr.expr, varScope, funcScope);
    }
}
exports.inferExprType = inferExprType;


/***/ }),

/***/ "./webstart.ts":
/*!*********************!*\
  !*** ./webstart.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var compiler_1 = __webpack_require__(/*! ./compiler */ "./compiler.ts");
var runner_1 = __webpack_require__(/*! ./runner */ "./runner.ts");
document.addEventListener("DOMContentLoaded", function () { return __awaiter(void 0, void 0, void 0, function () {
    var runButton, userCode, importObject;
    return __generator(this, function (_a) {
        runButton = document.getElementById("run");
        userCode = document.getElementById("user-code");
        importObject = {
            imports: {
                print: function (arg) {
                    console.log("Logging from WASM: ", arg);
                    var elt = document.createElement("pre");
                    document.getElementById("output").appendChild(elt);
                    elt.innerText = arg;
                    return arg;
                },
            },
            output: ""
        };
        runButton.addEventListener("click", function () { return __awaiter(void 0, void 0, void 0, function () {
            var program, wat, code, output, result, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        program = userCode.value;
                        wat = compiler_1.compile(program);
                        code = document.getElementById("generated-code");
                        code.textContent = wat;
                        output = document.getElementById("output");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, runner_1.run(wat)];
                    case 2:
                        result = _a.sent();
                        output.textContent = String(result);
                        output.setAttribute("style", "color: black");
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        output.textContent = String(e_1);
                        output.setAttribute("style", "color: red");
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        return [2 /*return*/];
    });
}); });


/***/ }),

/***/ "wabt":
/*!***********************!*\
  !*** external "wabt" ***!
  \***********************/
/***/ ((module) => {

module.exports = wabt;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./webstart.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL25vZGVfbW9kdWxlcy9sZXplci1weXRob24vZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ub2RlX21vZHVsZXMvbGV6ZXItdHJlZS9kaXN0L3RyZWUuY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vbm9kZV9tb2R1bGVzL2xlemVyL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vYXN0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0Ly4vY29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9lcnJvcnMudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi9ydW5uZXIudHMiLCJ3ZWJwYWNrOi8vd2ViLWFzbS1qaXQvLi90eXBlY2hlY2tlci50cyIsIndlYnBhY2s6Ly93ZWItYXNtLWppdC8uL3dlYnN0YXJ0LnRzIiwid2VicGFjazovL3dlYi1hc20taml0L2V4dGVybmFsIFwid2FidFwiIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3dlYi1hc20taml0L3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxZQUFZLG1CQUFPLENBQUMsa0RBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EiLCJmaWxlIjoid2Vic3RhcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsZXplciA9IHJlcXVpcmUoJ2xlemVyJyk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgXG4gIHByaW50S2V5d29yZCA9IDEsXG4gIG5ld2xpbmUgPSAxNjQsXG4gIG5ld2xpbmVCcmFja2V0ZWQgPSAxNjUsXG4gIG5ld2xpbmVFbXB0eSA9IDE2NixcbiAgZW9mID0gMTY3LFxuICBjb250aW51ZUJvZHkgPSAxNjgsXG4gIGVuZEJvZHkgPSAxNjksXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gMjEsXG4gIFR1cGxlRXhwcmVzc2lvbiA9IDQ4LFxuICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDQ5LFxuICBBcnJheUV4cHJlc3Npb24gPSA1MyxcbiAgQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDU2LFxuICBEaWN0aW9uYXJ5RXhwcmVzc2lvbiA9IDU3LFxuICBEaWN0aW9uYXJ5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gPSA2MCxcbiAgU2V0RXhwcmVzc2lvbiA9IDYxLFxuICBTZXRDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IDYyLFxuICBjb21wb3VuZFN0YXRlbWVudCA9IDIzMTtcblxuY29uc3QgbmV3bGluZSQxID0gMTAsIGNhcnJpYWdlUmV0dXJuID0gMTMsIHNwYWNlID0gMzIsIHRhYiA9IDksIGhhc2ggPSAzNSwgcGFyZW5PcGVuID0gNDAsIGRvdCA9IDQ2O1xuXG5jb25zdCBicmFja2V0ZWQgPSBbXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uLCBUdXBsZUV4cHJlc3Npb24sIENvbXByZWhlbnNpb25FeHByZXNzaW9uLCBBcnJheUV4cHJlc3Npb24sIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sXG4gIERpY3Rpb25hcnlFeHByZXNzaW9uLCBEaWN0aW9uYXJ5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24sIFNldEV4cHJlc3Npb24sIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uXG5dLCBwYXJlbnRTdGF0ZW1lbnQgPSBbY29tcG91bmRTdGF0ZW1lbnRdO1xuXG5jb25zdCBjYWNoZXMgPSBuZXcgV2Vha01hcDtcblxuLy8gUGVyLWlucHV0LXN0cmVhbSBpbmRlbnRhdGlvbiBjYWNoZS4gYHByZXZgIG1hcHMgaW5kZW50YXRpb24gZGVwdGhzXG4vLyB0byB0aGUgbGFzdCBwb3NpdGlvbiBhdCB3aGljaCBhIHN0YXRlbWVudCBpbmRlbnRlZCB0byB0aGF0IGRlcHRoXG4vLyB3YXMgc2Vlbi4gVGhlcmUncyBhbiBleHRyYSBzZXQgb2Ygc2xvdHMgZm9yIHRoZSBfY3VycmVudF9cbi8vIGluZGVudGF0aW9uLCBzaW5jZSB0aGF0IG5lZWRzIHRvIGJlIGF2YWlsYWJsZSBhbG9uZ3NpZGUgYSBwcmV2aW91c1xuLy8gaW5kZW50YXRpb24gcG9zaXRpb24gYXQgdGhlIHNhbWUgbGV2ZWwuXG5jbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGFzdCA9IHRoaXMubGFzdEluZGVudCA9IC0xO1xuICAgIHRoaXMucHJldiA9IFtdO1xuICB9XG5cbiAgZ2V0KHBvcykge1xuICAgIGlmICh0aGlzLmxhc3QgPT0gcG9zKSByZXR1cm4gdGhpcy5sYXN0SW5kZW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnByZXYubGVuZ3RoOyBpKyspIGlmICh0aGlzLnByZXZbaV0gPT0gcG9zKSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgc2V0KHBvcywgaW5kZW50KSB7XG4gICAgaWYgKHBvcyA9PSB0aGlzLmxhc3QpIHJldHVyblxuICAgIGlmICh0aGlzLmxhc3QgPiAtMSkgdGhpcy5zZXRQcmV2KHRoaXMubGFzdCwgdGhpcy5sYXN0SW5kZW50KTtcbiAgICB0aGlzLmxhc3QgPSBwb3M7XG4gICAgdGhpcy5sYXN0SW5kZW50ID0gaW5kZW50O1xuICB9XG5cbiAgc2V0UHJldihwb3MsIGluZGVudCkge1xuICAgIHdoaWxlICh0aGlzLnByZXYubGVuZ3RoIDwgaW5kZW50KSB0aGlzLnByZXYucHVzaCgtMSk7XG4gICAgdGhpcy5wcmV2W2luZGVudF0gPSBwb3M7XG4gIH1cblxuICBzdGF0aWMgZm9yKGlucHV0KSB7XG4gICAgbGV0IGZvdW5kID0gY2FjaGVzLmdldChpbnB1dCk7XG4gICAgaWYgKCFmb3VuZCkgY2FjaGVzLnNldChpbnB1dCwgZm91bmQgPSBuZXcgQ2FjaGUpO1xuICAgIHJldHVybiBmb3VuZFxuICB9XG59XG5cbmNvbnN0IG1heEluZGVudCA9IDUwO1xuXG5mdW5jdGlvbiBnZXRJbmRlbnQoaW5wdXQsIHBvcykge1xuICBsZXQgY2FjaGUgPSBDYWNoZS5mb3IoaW5wdXQpLCBmb3VuZCA9IGNhY2hlLmdldChwb3MpO1xuICBpZiAoZm91bmQgPiAtMSkgcmV0dXJuIGZvdW5kXG5cbiAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIHZlcnkgb2Z0ZW4gKG9yIGV2ZW4gYXQgYWxsKSBpbiBub3JtYWxcbiAgLy8gcGFyc2luZywgc2luY2UgdGhlIGluZGVudGF0aW9ucyBhcmUgc3RvcmVkIGJ5IHRoZSBuZXdsaW5lXG4gIC8vIHRva2VuaXplciBhaGVhZCBvZiB0aW1lLiBCdXQgaXQncyBraW5kIG9mIHRyaWNreSB0byBwcm92ZSB3aGV0aGVyXG4gIC8vIHRoYXQgYWx3YXlzIGhhcHBlbnMgaW4gaW5jcmVtZW50YWwgcGFyc2luZyBzY2VuYXJpb3MsIHNvIGhlcmUncyBhXG4gIC8vIGZhbGxiYWNrIGFueXdheS5cbiAgbGV0IGJlZm9yZSA9IGlucHV0LnJlYWQoTWF0aC5tYXgoMCwgcG9zIC0gbWF4SW5kZW50KSwgcG9zKTtcbiAgbGV0IGNvdW50ID0gMCwgc3RhcnQgPSBiZWZvcmUubGVuZ3RoO1xuICBmb3IgKDsgc3RhcnQgPiAwOyBzdGFydC0tKSB7XG4gICAgbGV0IG5leHQgPSBiZWZvcmUuY2hhckNvZGVBdChzdGFydCAtIDEpO1xuICAgIGlmIChuZXh0ID09IG5ld2xpbmUkMSB8fCBuZXh0ID09IGNhcnJpYWdlUmV0dXJuKSBicmVha1xuICB9XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaCA9IGJlZm9yZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaCA9PSBzcGFjZSkgY291bnQrKztcbiAgICBlbHNlIGlmIChjaCA9PSB0YWIpIGNvdW50ICs9IDggLSAoY291bnQgJSA4KTtcbiAgICBlbHNlIGJyZWFrXG4gIH1cbiAgY2FjaGUuc2V0UHJldihwb3MsIGNvdW50KTtcbiAgcmV0dXJuIGNvdW50XG59XG5cbmNvbnN0IG5ld2xpbmVzID0gbmV3IGxlemVyLkV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4sIHN0YWNrKSA9PiB7XG4gIGxldCBuZXh0ID0gaW5wdXQuZ2V0KHRva2VuLnN0YXJ0KTtcbiAgaWYgKG5leHQgPCAwKSB7XG4gICAgdG9rZW4uYWNjZXB0KGVvZiwgdG9rZW4uc3RhcnQpO1xuICAgIHJldHVyblxuICB9XG4gIGlmIChuZXh0ICE9IG5ld2xpbmUkMSAmJiBuZXh0ICE9IGNhcnJpYWdlUmV0dXJuKSByZXR1cm5cbiAgaWYgKHN0YWNrLnN0YXJ0T2YoYnJhY2tldGVkKSAhPSBudWxsKSB7XG4gICAgdG9rZW4uYWNjZXB0KG5ld2xpbmVCcmFja2V0ZWQsIHRva2VuLnN0YXJ0ICsgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHNjYW4gPSB0b2tlbi5zdGFydCArIDEsIGluZGVudCA9IDA7XG4gIGZvciAoOyBzY2FuIDwgaW5wdXQubGVuZ3RoOyBzY2FuKyspIHtcbiAgICBsZXQgY2ggPSBpbnB1dC5nZXQoc2Nhbik7XG4gICAgaWYgKGNoID09IHNwYWNlKSBpbmRlbnQrKztcbiAgICBlbHNlIGlmIChjaCA9PSB0YWIpIGluZGVudCArPSA4IC0gKGluZGVudCAlIDgpO1xuICAgIGVsc2UgaWYgKGNoID09IG5ld2xpbmUkMSB8fCBpbmRlbnQgPT0gY2FycmlhZ2VSZXR1cm4gfHwgY2ggPT0gaGFzaCkge1xuICAgICAgdG9rZW4uYWNjZXB0KG5ld2xpbmVFbXB0eSwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICB0b2tlbi5hY2NlcHQobmV3bGluZSwgdG9rZW4uc3RhcnQgKyAxKTtcbiAgQ2FjaGUuZm9yKGlucHV0KS5zZXQoc2NhbiwgaW5kZW50KTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlLCBmYWxsYmFjazogdHJ1ZX0pO1xuXG5jb25zdCBib2R5Q29udGludWUgPSBuZXcgbGV6ZXIuRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCB0b2tlbiwgc3RhY2spID0+IHtcbiAgbGV0IHBhcmVudCA9IHN0YWNrLnN0YXJ0T2YocGFyZW50U3RhdGVtZW50KTtcbiAgbGV0IHBhcmVudEluZGVudCA9IHBhcmVudCA9PSBudWxsID8gMCA6IGdldEluZGVudChpbnB1dCwgcGFyZW50KTtcbiAgbGV0IGluZGVudEhlcmUgPSBnZXRJbmRlbnQoaW5wdXQsIHRva2VuLnN0YXJ0KTtcbiAgdG9rZW4uYWNjZXB0KGluZGVudEhlcmUgPD0gcGFyZW50SW5kZW50ID8gZW5kQm9keSA6IGNvbnRpbnVlQm9keSwgdG9rZW4uc3RhcnQpO1xufSwge2NvbnRleHR1YWw6IHRydWUsIGZhbGxiYWNrOiB0cnVlfSk7XG5cbmNvbnN0IGxlZ2FjeVByaW50ID0gbmV3IGxlemVyLkV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgdG9rZW4pID0+IHtcbiAgbGV0IHBvcyA9IHRva2VuLnN0YXJ0O1xuICBmb3IgKGxldCBwcmludCA9IFwicHJpbnRcIiwgaSA9IDA7IGkgPCBwcmludC5sZW5ndGg7IGkrKywgcG9zKyspXG4gICAgaWYgKGlucHV0LmdldChwb3MpICE9IHByaW50LmNoYXJDb2RlQXQoaSkpIHJldHVyblxuICBsZXQgZW5kID0gcG9zO1xuICBpZiAoL1xcdy8udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0LmdldChwb3MpKSkpIHJldHVyblxuICBmb3IgKDs7IHBvcysrKSB7XG4gICAgbGV0IG5leHQgPSBpbnB1dC5nZXQocG9zKTtcbiAgICBpZiAobmV4dCA9PSBzcGFjZSB8fCBuZXh0ID09IHRhYikgY29udGludWVcbiAgICBpZiAobmV4dCAhPSBwYXJlbk9wZW4gJiYgbmV4dCAhPSBkb3QgJiYgbmV4dCAhPSBuZXdsaW5lJDEgJiYgbmV4dCAhPSBjYXJyaWFnZVJldHVybiAmJiBuZXh0ICE9IGhhc2gpXG4gICAgICB0b2tlbi5hY2NlcHQocHJpbnRLZXl3b3JkLCBlbmQpO1xuICAgIHJldHVyblxuICB9XG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsYXdhaXQ6NDAsIG9yOjQ4LCBhbmQ6NTAsIGluOjU0LCBub3Q6NTYsIGlzOjU4LCBpZjo2NCwgZWxzZTo2NiwgbGFtYmRhOjcwLCBzZWxmOjc0LCB5aWVsZDo5MCwgZnJvbTo5MiwgYXN5bmM6MTAwLCBmb3I6MTAyLCBOb25lOjE1NCwgVHJ1ZToxNTYsIEZhbHNlOjE1NiwgZGVsOjE3MCwgcGFzczoxNzQsIGJyZWFrOjE3OCwgY29udGludWU6MTgyLCByZXR1cm46MTg2LCByYWlzZToxOTQsIGltcG9ydDoxOTgsIGFzOjIwMCwgZ2xvYmFsOjIwNCwgbm9ubG9jYWw6MjA2LCBhc3NlcnQ6MjEwLCBlbGlmOjIyMCwgd2hpbGU6MjI0LCB0cnk6MjMwLCBleGNlcHQ6MjMyLCBmaW5hbGx5OjIzNCwgd2l0aDoyMzgsIGRlZjoyNDIsIGNsYXNzOjI1Mn07XG5jb25zdCBwYXJzZXIgPSBsZXplci5QYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxMyxcbiAgc3RhdGVzOiBcIiE7W09gUSFMVE9PTyVmUSFMVU8nI0djT09RIUxRJyNDbScjQ21PT1EhTFEnI0NuJyNDbk8nVVEhTFNPJyNDbE8oelEhTFVPJyNHYk9PUSFMUScjR2MnI0djT09RIUxRJyNEUycjRFNPT1EhTFEnI0diJyNHYk8paFEhTFNPJyNDcU8peFEhTFNPJyNEY08qWVEhTFNPJyNEZ09PUSFMUScjRHQnI0R0TyptT1dPJyNEdE8qdU9gTycjRHRPKn1PcE8nI0R1TytZTyFiTycjRHVPK2VPI3RPJyNEdU8rcE8mak8nI0R1Ty1yUSFMVU8nI0dTT09RIUxRJyNHUycjR1NPJ1VRIUxTTycjR1JPL1VRIUxVTycjR1JPT1EhTFEnI0VeJyNFXk8vbVEhTFNPJyNFX09PUSFMUScjR1EnI0dRTy93USFMU08nI0dQT09RJkZWJyNHUCcjR1BPMFNRIUxTTycjRlFPT1EhTFEnI0Z0JyNGdE8wWFEhTFNPJyNGUE9PUSZGVicjSF0nI0hdT09RJkZWJyNHTycjR09PT1EhTFInI0ZTJyNGU1FgUSFMVE9PTydVUSFMU08nI0NvTzBnUSFMU08nI0N6TzBuUSFMU08nI0RPTzFQUSFMU08nI0dnTzFhUSFMVU8nI0VSTydVUSFMU08nI0VTT09RIUxRJyNFVScjRVVPT1EhTFEnI0VXJyNFV09PUSFMUScjRVknI0VZTzF1USFMU08nI0VbTzJdUSFMU08nI0VgTzBTUSFMU08nI0ViTzJwUSFMVU8nI0ViTzBTUSFMU08nI0VlTy9tUSFMU08nI0VoTy9tUSFMU08nI0VsTy9tUSFMU08nI0VvTzJ7USFMU08nI0VxTzNTUSFMU08nI0V2TzNfUSFMU08nI0VyTy9tUSFMU08nI0V2TzBTUSFMU08nI0V4TzBTUSFMU08nI0V9T09RIUxRJyNDYycjQ2NPT1EhTFEnI0NkJyNDZE9PUSFMUScjQ2UnI0NlT09RIUxRJyNDZicjQ2ZPT1EhTFEnI0NnJyNDZ09PUSFMUScjQ2gnI0NoT09RIUxRJyNDaicjQ2pPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPJ1VRIUxTTyw1OHxPM2RRIUxTTycjRG5PT1EhTFEsNTpYLDU6WE8zd1EhTFNPLDU6W080VVEjKVdPLDU6W080WlEhTFVPLDU5V08wZ1EhTFNPLDU5X08wZ1EhTFNPLDU5X08wZ1EhTFNPLDU5X082eVEhTFNPLDU5X083T1EhTFNPLDU5X083VlEhTFNPLDU5Z083XlEhTFNPJyNHYk84ZFEhTFNPJyNHYU9PUSFMUScjR2EnI0dhT09RIUxRJyNEWScjRFlPOHtRIUxTTyw1OV1PJ1VRIUxTTyw1OV1POVpRIUxTTyw1OV1POWBRIUxTTyw1OlFPJ1VRIUxTTyw1OlFPT1EhTFEsNTl9LDU5fU85blEhTFNPLDU5fU85c1EhTFNPLDU6V08nVVEhTFNPLDU6V08nVVEhTFNPLDU6VU9PUSFMUSw1OlIsNTpSTzpVUSFMU08sNTpSTzpaUSFMU08sNTpWT09PTycjRl0nI0ZdTzpgT1dPLDU6YE9PUSFMUSw1OmAsNTpgT09PTycjRl4nI0ZeTzpoT2BPLDU6YE86cFEhTFNPJyNEdk9PT08nI0ZfJyNGX087UU9wTyw1OmFPT1EhTFEsNTphLDU6YU9PT08nI0ZiJyNGYk87XU8hYk8sNTphT09PTycjRmMnI0ZjTztoTyN0Tyw1OmFPT09PJyNGZCcjRmRPO3NPJmpPLDU6YU9PUSFMUScjRmUnI0ZlTzxPUSFMVU8sNTplTz5wUSFMVU8sNTxtTz9aUSM0Xk8nI0ZmTz99USFMVU8sNTxtT09RIUxRLDU6eSw1OnlPQGZRIUxUTycjRm1PQXVRIUxTTyw1O1VPT1EmRlYsNTxrLDU8a09CUVEhTFVPJyNIWU9CaVEhTFNPLDU7bE9PUSFMUS1FOXItRTlyT09RJkZWLDU7ayw1O2tPM1lRIUxTTycjRXhPT1EhTFItRTlRLUU5UU9CcVEhTFVPLDU5Wk9EeFEhTFVPLDU5Zk9FY1EhTFNPJyNHZE9FblEhTFNPJyNHZE8wU1EhTFNPJyNHZE9FeVEhTFNPJyNEUU9GUlEhTFNPLDU5ak9GV1EhTFNPJyNHaE8nVVEhTFNPJyNHaE8vbVEhTFNPLDU9Uk9PUSFMUSw1PVIsNT1STy9tUSFMU08nI0R9T09RIUxRJyNFTycjRU9PRnVRIUxTTycjRmdPR1ZRIUxTTyw1OHpPR2VRIUxTTyw1OHpPKWtRIUxTTyw1OmtPR2pRIUxVTycjR2pPT1EhTFEsNTpuLDU6bk9PUSFMUSw1OnYsNTp2T0d9USFMU08sNTp6T0hgUSFMU08sNTp8T09RIUxRJyNGaicjRmpPSG5RIUxVTyw1OnxPSHxRIUxTTyw1OnxPSVJRIUxTTycjSFtPT1EhTFEsNTtQLDU7UE9JYVEhTFNPJyNIWE9PUSFMUSw1O1MsNTtTTzNfUSFMU08sNTtXTzNfUSFMU08sNTtaT0lyUSFMVU8nI0heTydVUSFMU08nI0heT0l8USFMU08sNTtdTzJ7USFMU08sNTtdTy9tUSFMU08sNTtiTzBTUSFMU08sNTtkT0pSUSFMVE8nI0VtT0tbUSZGWE8sNTteT05zUSFMU08nI0hfTzNfUSFMU08sNTtiTyEgT1EhTFNPLDU7ZE8hIFRRIUxTTyw1O2lPISN4USFMVU8xRy5oTyEkUFEhTFVPMUcuaE8hJnBRIUxVTzFHLmhPISZ6USFMVU8xRy5oTyEpZVEhTFVPMUcuaE8hKXhRIUxVTzFHLmhPISpdUSFMVU8xRy5oTyEse1EhTFNPJyNHcE8hLVpRIUxVTycjR1NPL21RIUxTTycjR3BPIS1lUSFMU08nI0dvT09RIUxRLDU6WSw1OllPIS1tUSFMU08sNTpZTyEtclEhTFNPJyNHcU8hLX1RIUxTTycjR3FPIS5iUSFMU08xRy92T09RIUxRJyNEcicjRHJPT1EhTFExRy92MUcvdk9PUSFMUTFHLnkxRy55TyEvYlEhTFVPMUcueU8hL2lRIUxVTzFHLnlPMGdRIUxTTzFHLnlPITBVUSFMU08xRy9ST09RIUxRJyNEWCcjRFhPL21RIUxTTyw1OXJPT1EhTFExRy53MUcud08hMF1RIUxTTzFHL2RPITBtUSFMU08xRy9kTyEwdVEhTFNPMUcvZU8nVVEhTFNPJyNHaU8hMHpRIUxTTycjR2lPITFQUSFMVU8xRy53TyExYVEhTFNPLDU5Zk8hMmdRIUxTTycjRlhPITJ6USFMU08sNT1YTyEzU1EhTFNPMUcvbE8hM1hRIUxVTzFHL2xPT1EhTFExRy9pMUcvaU8hM2lRIUxTTycjRlVPITRjUSFMU08sNT1TTy9tUSFMU08xRy9wTyE1UVEhTFNPMUcvck8hNVZRIUxVTzFHL3JPITVnUSFMVU8xRy9wT09RIUxRMUcvbTFHL21PT1EhTFExRy9xMUcvcU9PT08tRTlaLUU5Wk9PUSFMUTFHL3oxRy96T09PTy1FOVstRTlbTyE1d1EhTFNPJyNHfE8vbVEhTFNPJyNHfE8hNlZRIUxTTyw1OmJPT09PLUU5XS1FOV1PT1EhTFExRy97MUcve09PT08tRTlgLUU5YE9PT08tRTlhLUU5YU9PT08tRTliLUU5Yk9PUSFMUS1FOWMtRTljTyE2YlEhTFVPMUcyWE8nVVEhTFNPLDU8UU9PUSFMUSw1PFEsNTxRT09RIUxRLUU5ZC1FOWRPT1EhTFEsNTxYLDU8WE9PUSFMUS1FOWstRTlrT09RJkZWMUcwcDFHMHBPMFNRIUxTTycjRmlPITZ5USFMVU8sNT10T09RIUxRMUcxVzFHMVdPITdiUSFMU08xRzFXT09RIUxRJyNEVCcjRFRPL21RIUxTTyw1PU9PT1EhTFEsNT1PLDU9T08hN2dRIUxTTycjRlRPITd1USFMU08sNTlsTyE3fVEhTFNPMUcvVU8hOFhRIUxVTyw1PVNPT1EhTFExRzJtMUcybU9PUSFMUSw1OmksNTppTyE4eFEhTFNPJyNHUk9PUSFMUSw1PFIsNTxST09RIUxRLUU5ZS1FOWVPITlaUSFMU08xRy5mT09RIUxRMUcwVjFHMFZPITlpUSFMU08nI0ZXTyE5fFEhTFNPLDU9VU8vbVEhTFNPMUcwZk8vbVEhTFNPMUcwZk8wU1EhTFNPMUcwaE9PUSFMUS1FOWgtRTloTyE6X1EhTFNPMUcwaE8hOmpRIUxTTzFHMGhPITpvUSFMU08nI0ZsTyE7UVEhTFNPLDU9dk8hO2BRIUxTTycjRmhPITt5USFMU08sNT1zTyE8W1EmRlhPMUcwck8hP3BRJkZYTzFHMHVPIUNSUSFMU08nI0ZwTyFDYFEhTFNPLDU9eE8hQ2hRIUxVTyw1PXhPL21RIUxTTzFHMHdPIUNyUSFMU08xRzB3TzNfUSFMU08xRzB8TyEgT1EhTFNPMUcxT09PUSZGViw1O1gsNTtYTyFDd1EhTFRPLDU7WE8hRWpRJkZYTzFHMHhPIUlSUSFMU08nI0ZxTzNfUSFMU08xRzB4TzNfUSFMU08xRzB4TyFJYFEhTFNPJyNGck8hSXBRIUxTTyw1PXlPMFNRIUxTTyw1PXlPT1EmRlYxRzB8MUcwfE8hSlpRIUxTTycjRXpPIUpiUSMpV08xRzFPT09RJkZWMUcxVDFHMVRPM19RIUxTTzFHMVRPT1EhTFEsNT1bLDU9W09PUSFMUScjRG8nI0RvTy9tUSFMU08sNT1bTyFKalEhTFNPJyNGWk8hS1FRIUxTTyw1PVpPT1EhTFExRy90MUcvdE8hS1lRIUxTTycjRltPIUttUSFMU08sNT1dTyFLdVEhTFNPLDU9XU8hTFlRIUxTTyw1PV1PIUxqUSFMU08sNT1dT09RIUxRNyslYjcrJWJPT1EhTFE3KyRlNyskZU8hN31RIUxTTzcrJG1PIU5dUSFMU08xRy55TyFOZFEhTFNPMUcueU9PUSFMUTFHL14xRy9eT09RIUxRLDU7cSw1O3FPJ1VRIUxTTyw1O3FPT1EhTFE3KyVPNyslT08hTmtRIUxTTzcrJU9PT1EhTFEtRTlULUU5VE9PUSFMUTcrJVA3KyVQTyFOe1EhTFNPLDU9VE8nVVEhTFNPLDU9VE9PUSFMUTcrJGM3KyRjTyMgUVEhTFNPNyslT08jIFlRIUxTTzcrJVBPT1EhTFEsNTtzLDU7c08nVVEhTFNPLDU7c09PUSFMUS1FOVYtRTlWT09RIUxRNyslVzcrJVdPIyBfUSFMU08xRzJzTyMgZ1EhTFNPNyslV09PUSFMUSw1O3AsNTtwTydVUSFMU08sNTtwT09RIUxRLUU5Uy1FOVNPIyBsUSFMU083KyVbT09RIUxRNyslXjcrJV5PIyB6USFMU08xRzJuTyMhaVEhTFNPNyslXk8jIW5RIUxTTycjRllPIyNSUSFMU08xRzJ0TyMjWlEhTFNPNyslW08jI2BRIUxTTycjRmBPIyN5USFMU08sNT1oTyMjeVEhTFNPLDU9aE8jJFhPTWhPJyNEeE8jJGRPUU8nI0d9T09PTzFHL3wxRy98TyMkaVEhTFNPMUcvfE8jJHFRIUxVTzFHMWxPT1EhTFEsNTxULDU8VE9PUSFMUS1FOWctRTlnT09RIUxRNysmcjcrJnJPT1EhTFExRzJqMUcyak9PUSFMUSw1O28sNTtvT09RIUxRLUU5Ui1FOVJPT1EhTFE3KyRwNyskcE8jJVtRIUxTTycjRmZPIyV4USFMU08sNTxtTyMmWlEhTFVPLDU7ck9PUSFMUS1FOVUtRTlVT09RIUxRNysmUTcrJlFPIyZuUSFMU083KyZRT09RIUxRNysmUzcrJlNPIyZ8USFMU08nI0haTzBTUSFMU083KyZTTyMnYlEhTFNPNysmU09PUSFMUSw1PFcsNTxXT09RIUxRLUU5ai1FOWpPT1EhTFEsNTxTLDU8U09PUSFMUS1FOWYtRTlmTyMnbVEmRlhPNysmXk8hSVJRIUxTTycjRm9PM19RIUxTTzcrJl5PM19RIUxTTzcrJmFPIytSUSFMVU8sNTxbTydVUSFMU08sNTxbT09RIUxRLUU5bi1FOW5PIytdUSFMU08xRzNkTzNfUSFMU083KyZjTy9tUSFMU083KyZjT09RJkZWNysmaDcrJmhPIUpiUSMpV083KyZqTyMrZVEmRldPMUcwc09PUSZGVi1FOW8tRTlvTzNfUSFMU083KyZkTzNfUSFMU083KyZkT09RJkZWLDU8XSw1PF1PIytwUSFMU08sNTxdT09RJkZWNysmZDcrJmRPIyt7USZGWE83KyZkTyMvXlEhTFNPLDU8Xk9PUSFMUS1FOXAtRTlwTyMvaVEhTFNPMUczZU8jL3FRIUxTTycjSGFPIzBQUSFMU08nI0hhTzBTUSFMU08nI0hhT09RIUxRJyNIYScjSGFPIzBbUSFMU08nI0hgT09RIUxRLDU7Ziw1O2ZPIzBkUSFMU08sNTtmTy9tUSFMU08nI0V8T09RJkZWNysmajcrJmpPM19RIUxTTzcrJmpPT1EmRlY3KyZvNysmb09PUSFMUTFHMnYxRzJ2T09RIUxRLDU7dSw1O3VPT1EhTFEtRTlYLUU5WE8jMGlRIUxTTyw1O3ZPIzB0USFMU08sNTt2T09RIUxRLUU5WS1FOVlPIzFYUSFMU08xRzJ3TyMxYVEhTFNPMUcyd08jMXFRIUxTTzFHMndPIzFYUSFMU08xRzJ3T09RIUxRPDxIWDw8SFhPIzF8USFMVU8xRzFdT09RIUxRPDxIajw8SGpQIzJXUSFMU08nI0ZWTzdWUSFMU08xRzJvTyMyZVEhTFNPMUcyb08jMmpRIUxTTzw8SGpPT1EhTFE8PEhrPDxIa08jMnpRIUxVTzFHMV9PT1EhTFE8PEhyPDxIck8jM1VRIUxVTzFHMVtPIzN1USFMU083KyhgTyMzfVEhTFNPPDxIdk9PUSFMUTw8SHg8PEh4TyM0U1EhTFNPLDU7dE8nVVEhTFNPLDU7dE9PUSFMUS1FOVctRTlXT09RIUxRPDxIdjw8SHZPT1EhTFEsNTt6LDU7ek8vbVEhTFNPLDU7ek9PUSFMUS1FOV4tRTleTyM0WFEhTFNPMUczU09PT08nI0ZhJyNGYU8jNGdPTWhPLDU6ZE9PT08sNT1pLDU9aU9PT083KyVoNyslaE8jNHJRIUxTTzFHMlhPL21RIUxTTzw8SWxPIzVUUSFMU08nI0ZrTyM1aVEhTFNPLDU9dU8wU1EhTFNPLDU9dU8jNXpRIUxTTzw8SW5PT1EhTFE8PEluPDxJbk8wU1EhTFNPPDxJbk9PUSZGVi1FOW0tRTltTzNfUSFMU088PEl4T09RJkZWLDU8Wiw1PFpPM19RIUxTTyw1PFpPT1EmRlY8PEl4PDxJeE9PUSZGVjw8SXs8PEl7TyM2UFEhTFVPMUcxdk8jNlpRJkZYTzw8SX1PM19RIUxTTzw8SX1PT1EmRlY8PEpVPDxKVU8zX1EhTFNPPDxKVU8hQ3dRIUxUTycjRm5PIzlsUSZGV083KyZfT09RJkZWNysmXzcrJl9PT1EmRlY8PEpPPDxKT08jOXdRJkZYTzw8Sk9PT1EmRlYxRzF3MUcxd08wU1EhTFNPMUcxd08zX1EhTFNPPDxKT08wU1EhTFNPMUcxeE8jPVlRIUxTTzcrKVBPT1EhTFEnI0V7JyNFe08vbVEhTFNPLDU9e08jPWJRIUxTTyw1PXtPT1EhTFEsNT17LDU9e08jPW1RIUxTTycjRnNPIz13USFMU08sNT16T09RIUxRMUcxUTFHMVFPT1EhTFEsNTtoLDU7aE8jPlBRIUxTTzFHMWJPIz5kUSFMU08xRzFiTyM+dFEhTFNPMUcxYk8jP1BRIUxTTzcrKGNPIz9QUSFMU083KyhjTyM/WFEhTFNPNysoY08jP2lRIUxTTzcrKFpPN1ZRIUxTTzcrKFpPT1EhTFFBTj5VQU4+VU9PUSFMUUFOPmJBTj5iTy9tUSFMU08xRzFgTyNAU1EhTFVPMUcxYE9PUSFMUTFHMWYxRzFmT09PTy1FOV8tRTlfT09RIUxRQU4/V0FOP1dPI0BeUSFMU08sNTxWT09RIUxRLUU5aS1FOWlPI0ByUSFMU08xRzNhT09RIUxRQU4/WUFOP1lPI0FUUSFMU09BTj9ZT09RJkZWQU4/ZEFOP2RPT1EmRlYxRzF1MUcxdU8zX1EhTFNPQU4/aU8jQVlRJkZYT0FOP2lPT1EmRlZBTj9wQU4/cE9PUSZGVSw1PFksNTxZT09RJkZVLUU5bC1FOWxPT1EmRlY8PEl5PDxJeU8zX1EhTFNPQU4/ak8zX1EhTFNPNysnY09PUSZGVkFOP2pBTj9qT09RIUxRNysnZDcrJ2RPT1EhTFExRzNnMUczZ08vbVEhTFNPMUczZ09PUSFMUSw1PF8sNTxfT09RIUxRLUU5cS1FOXFPI0RrUSFMU083KyZ8TyNEe1EhTFNPNysmfE9PUSFMUTcrJnw3KyZ8TyNFV1EhTFNPPDxLfU8jRVdRIUxTTzw8S31PI0VgUSFMU08nI0drT09RIUxRPDxLdTw8S3VPI0VqUSFMU088PEt1T09RIUxRNysmejcrJnpPMFNRIUxTTzFHMXFPI0ZUUSFMU083Kyh7T09RIUxRRzI0dEcyNHRPT1EmRlZHMjVURzI1VE8zX1EhTFNPRzI1VE9PUSZGVkcyNVVHMjVVT09RJkZWPDxKfTw8Sn1PT1EhTFE3KylSNyspUk9PUSFMUTw8Smg8PEpoTyNGZlEhTFNPPDxKaE8jRnZRIUxTT0FOQWlPI0dPUSFMU08nI0dsT09RIUxRJyNHbCcjR2xPMG5RIUxTTycjRGJPI0dpUSFMU08sNT1WT09RIUxRQU5BYUFOQWFPT1EhTFE3KyddNysnXU9PUSZGVkxEKm9MRCpvT09RIUxRQU5AU0FOQFNPI0hRUSFMU08sNTl8T09RIUxRMUcycTFHMnFPI0VgUSFMU08xRy9oT09RIUxRNyslUzcrJVNPN1ZRIUxTTycjQ3pPN1ZRIUxTTyw1OV9PN1ZRIUxTTyw1OV9PN1ZRIUxTTyw1OV9PI0hWUSFMVU8sNTxtTzdWUSFMU08xRy55Ty9tUSFMU08xRy9VTy9tUSFMU083KyRtTydVUSFMU08nI0dSTyNIalEhTFNPLDU5X08jSG9RIUxTTyw1OV9PI0h2USFMU08sNTlqTyNIe1EhTFNPMUcvUk8wblEhTFNPJyNET083VlEhTFNPLDU5Z1wiLFxuICBzdGF0ZURhdGE6IFwiI0lefk8kcU9TJGxPUyRrT1NRT1N+T1BoT1RlT2RzT2ZYT2x0T3AhU09zdU91ZE99dk8hTyFQTyFTIVZPIVQhVU8hV1lPIVtaTyFnZE8hbmRPIW9kTyFwZE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNkIVRPI2chV08jayFYTyNtIVlPI3IhWk8jdWxPJGpxTyR8UU8kfVFPJVJSTyVTVk8lZ1tPJWhdTyVrXk8lbl9PJXRgTyV3YU8leWJPfk9UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR3IVtPJHghXU8keSFeTyR6IV9PJHshX08kfCFgTyR9IWBPJU8hYU8lUCFhTyVRIWFPfk9oJVZYaSVWWGolVlhrJVZYbCVWWG0lVlhwJVZYeCVWWHklVlghdCVWWCNfJVZYJGolVlgkbSVWWCVYJVZYIVAlVlghUyVWWCFUJVZYJVklVlghWCVWWCFdJVZYIU8lVlgjVyVWWHElVlghayVWWH5QJGJPZHNPZlhPdWRPIVdZTyFbWk8hZ2RPIW5kTyFvZE8hcGRPJHxRTyR9UU8lUlJPJVNWTyVnW08laF1PJWteTyVuX08ldGBPJXdhTyV5Yk9+T3glVVh5JVVYI18lVVgkaiVVWCRtJVVYJVglVVh+T2ghcE9pIXFPaiFvT2shb09sIXJPbSFzT3AhdE8hdCVVWH5QKGZPVCF6T2wscU9zLU9PfXZPflAnVU9UIX1PbCxxT3MtT08hWCNPT35QJ1VPVCNST18jU09sLHFPcy1PTyFdI1RPflAnVU8laSNXTyVqI1lPfk8lbCNaTyVtI1lPfk8hWyNdTyVvI15PJXMjYE9+TyFbI11PJXUjYU8ldiNgT35PIVsjXU8laiNgTyV4I2NPfk8hWyNdTyVtI2BPJXojZU9+T1QkdlhdJHZYXyR2WGYkdlhoJHZYaSR2WGokdlhrJHZYbCR2WG0kdlhwJHZYeCR2WCFXJHZYIWUkdlgkdyR2WCR4JHZYJHkkdlgkeiR2WCR7JHZYJHwkdlgkfSR2WCVPJHZYJVAkdlglUSR2WCFQJHZYIVMkdlghVCR2WH5PJWdbTyVoXU8la15PJW5fTyV0YE8ld2FPJXliT3kkdlghdCR2WCNfJHZYJGokdlgkbSR2WCVYJHZYJVkkdlghWCR2WCFdJHZYIU8kdlgjVyR2WHEkdlghayR2WH5QK3tPeCNqT3kkdVghdCR1WCNfJHVYJGokdVgkbSR1WCVYJHVYfk9sLHFPcy1PT35QJ1VPI18jbU8kaiNvTyRtI29Pfk8lU1ZPfk8hUyN0TyNtIVlPI3IhWk8jdWxPfk9sdE9+UCdVT1QjeU9fI3pPdSN4TyVTVk95dFB+T1QkT09sLHFPcy1PTyFPJFBPflAnVU95JFJPIXQkV08lWCRTTyNfIXVYJGohdVgkbSF1WH5PVCRPT2wscU9zLU9PI18jT1gkaiNPWCRtI09YflAnVU9sLHFPcy1PTyNfI1NYJGojU1gkbSNTWH5QJ1VPIWUkXk8hbiReTyVTVk9+T1QkaE9+UCdVTyFUJGpPI2ska08jbSRsT35PeSRtT35PVCR8T18kfE9sLHFPcy1PTyFQJU9PflAnVU9sLHFPcy1PT3klUk9+UCdVTyVmJVRPfk9fIWJPZiFqTyFXIWxPIWUhbU9UYGFdYGFoYGFpYGFqYGFrYGFsYGFtYGFwYGF4YGF5YGEhdGBhI19gYSRqYGEkbWBhJHdgYSR4YGEkeWBhJHpgYSR7YGEkfGBhJH1gYSVPYGElUGBhJVFgYSVYYGEhUGBhIVNgYSFUYGElWWBhIVhgYSFdYGEhT2BhI1dgYXFgYSFrYGF+T2slWU9+T2wlWU9+UCdVT2wscU9+UCdVT2gsc09pLHRPaixyT2ssck9sLHpPbSx7T3AtUE8hUCVVWCFTJVVYIVQlVVglWSVVWCFYJVVYIV0lVVghTyVVWCNXJVVYIWslVVh+UChmTyVZJVtPeCVUWCFQJVRYIVMlVFghVCVUWCFYJVRYeSVUWH5PeCVfTyFQJV5PIVMlY08hVCViT35PIVAlXk9+T3glZk8hUyVjTyFUJWJPIVglYVh+TyFYJWpPfk94JWtPeSVtTyFTJWNPIVQlYk8hXSVbWH5PIV0lcU9+TyFdJXJPfk8laSNXTyVqJXRPfk8lbCNaTyVtJXRPfk9UJXdPbCxxT3MtT099dk9+UCdVTyFbI11PJW8jXk8lcyV6T35PIVsjXU8ldSNhTyV2JXpPfk8hWyNdTyVqJXpPJXgjY09+TyFbI11PJW0lek8leiNlT35PVCFtYV0hbWFfIW1hZiFtYWghbWFpIW1haiFtYWshbWFsIW1hbSFtYXAhbWF4IW1heSFtYSFXIW1hIWUhbWEhdCFtYSNfIW1hJGohbWEkbSFtYSR3IW1hJHghbWEkeSFtYSR6IW1hJHshbWEkfCFtYSR9IW1hJU8hbWElUCFtYSVRIW1hJVghbWEhUCFtYSFTIW1hIVQhbWElWSFtYSFYIW1hIV0hbWEhTyFtYSNXIW1hcSFtYSFrIW1hflAjeU94I2pPeSR1YSF0JHVhI18kdWEkaiR1YSRtJHVhJVgkdWF+UCRiT1QmUU9sdE9zdU94JFlYeSRZWCF0JFlYI18kWVgkaiRZWCRtJFlYJVgkWVh+UCdVT3gjak95JHVhIXQkdWEjXyR1YSRqJHVhJG0kdWElWCR1YX5PUGhPVGVPbHRPc3VPfXZPIU8hUE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNfJGFYJGokYVgkbSRhWH5QJ1VPI18jbU8kaiZWTyRtJlZPfk8hZSZXT2YlfFgkaiV8WCNXJXxYI18lfFgkbSV8WCNWJXxYfk9mIWpPJGomWU9+T2hjYWljYWpjYWtjYWxjYW1jYXBjYXhjYXljYSF0Y2EjX2NhJGpjYSRtY2ElWGNhIVBjYSFTY2EhVGNhJVljYSFYY2EhXWNhIU9jYSNXY2FxY2Eha2NhflAkYk9wbmF4bmF5bmEjX25hJGpuYSRtbmElWG5hfk9oIXBPaSFxT2ohb09rIW9PbCFyT20hc08hdG5hflBEYU8lWCZbT3glV1h5JVdYfk8lU1ZPeCVXWHklV1h+T3gmX095dFh+T3kmYU9+T3gla08jXyVbWCRqJVtYJG0lW1ghUCVbWHklW1ghXSVbWCFrJVtYJVglW1h+T1QseU9sLHFPcy1PT312T35QJ1VPJVgkU08jX1NhJGpTYSRtU2F+TyVYJFNPfk94JmpPI18lXlgkaiVeWCRtJV5YayVeWH5QJGJPeCZtTyFPJmxPI18jU2EkaiNTYSRtI1Nhfk8jVyZuTyNfI1VhJGojVWEkbSNVYX5PIWUkXk8hbiReTyNWJnBPJVNWT35PI1YmcE9+T3gmck8jXyZPWCRqJk9YJG0mT1h+T3gmdE8jXyV7WCRqJXtYJG0le1h5JXtYfk94JnhPayZRWH5QJGJPayZ7T35PUGhPVGVPbHRPc3VPfXZPIU8hUE8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyRqJ1FPflAnVU9xJ1VPI2gnU08jaSdUT1AjZmFUI2ZhZCNmYWYjZmFsI2ZhcCNmYXMjZmF1I2ZhfSNmYSFPI2ZhIVMjZmEhVCNmYSFXI2ZhIVsjZmEhZyNmYSFuI2ZhIW8jZmEhcCNmYSF3I2ZhIXkjZmEheyNmYSF9I2ZhI1AjZmEjVCNmYSNWI2ZhI1kjZmEjWiNmYSNdI2ZhI2QjZmEjZyNmYSNrI2ZhI20jZmEjciNmYSN1I2ZhJGkjZmEkaiNmYSR8I2ZhJH0jZmElUiNmYSVTI2ZhJWcjZmElaCNmYSVrI2ZhJW4jZmEldCNmYSV3I2ZhJXkjZmEkbSNmYSRuI2ZhJG8jZmF+T3gnVk8jVydYT3kmUlh+T2YnWk9+T2Yhak95JG1Pfk9UIWFPXSFhT18hYk9mIWpPIVchbE8hZSFtTyR5IV5PJHohX08keyFfTyR8IWBPJH0hYE8lTyFhTyVQIWFPJVEhYU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+TyR4IV1PflAhIF1PJHhVaX5QISBdT1QhYU9dIWFPXyFiT2Yhak8hVyFsTyFlIW1PJHwhYE8kfSFgTyVPIWFPJVAhYU8lUSFhT2hVaWlVaWpVaWtVaWxVaW1VaXBVaXhVaXlVaSF0VWkjX1VpJGpVaSRtVWkkd1VpJHhVaSR5VWklWFVpIVBVaSFTVWkhVFVpJVlVaSFYVWkhXVVpIU9VaSNXVWlxVWkha1Vpfk8keiFfTyR7IV9PflAhJFdPJHpVaSR7VWl+UCEkV09fIWJPZiFqTyFXIWxPIWUhbU9oVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJHpVaSR7VWkkfFVpJH1VaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+T1QhYU9dIWFPJU8hYU8lUCFhTyVRIWFPflAhJ1VPVFVpXVVpJU9VaSVQVWklUVVpflAhJ1VPZiFqTyFXIWxPIWUhbU9UVWldVWlfVWloVWlpVWlqVWlrVWlsVWltVWlwVWl4VWl5VWkhdFVpI19VaSRqVWkkbVVpJHdVaSR4VWkkeVVpJHpVaSR7VWkkfFVpJH1VaSVPVWklUFVpJVFVaSVYVWkhUFVpIVNVaSFUVWklWVVpIVhVaSFdVWkhT1VpI1dVaXFVaSFrVWl+TyFTJWNPIVQlYk94JWRYIVAlZFh+TyVYJ2BPJVknYE9+UCt7T3gnYk8hUCVjWH5PIVAnZE9+T3gnZU95J2dPIVglZVh+T2wscU9zLU9PeCdlT3knaE8hWCVlWH5QJ1VPIVgnak9+T2ohb09rIW9PbCFyT20hc09oZ2lwZ2l4Z2l5Z2khdGdpI19naSRqZ2kkbWdpJVhnaX5PaSFxT35QIS5nT2lnaX5QIS5nT2gsc09pLHRPaixyT2ssck9sLHpPbSx7T35PcSdsT35QIS9wT1QncU9sLHFPcy1PTyFQJ3JPflAnVU94J3NPIVAnck9+TyFQJ3VPfk8hVCd3T35PeCdzTyFQJ3hPIVMlY08hVCViT35QJGJPaCxzT2ksdE9qLHJPayxyT2wsek9tLHtPIVBuYSFTbmEhVG5hJVluYSFYbmEhXW5hIU9uYSNXbmFxbmEha25hflBEYU9UJ3xPbCxxT3MtT094I3tYIVgje1h+UCdVT3glZk8hWCVhYX5PIVgoT09+T3glZk8hUyVjTyFUJWJPIVglYWF+UCRiT1QoU09sLHFPcy1PT3gjeFghXSN4WCNfI3hYJGojeFgkbSN4WCFQI3hYeSN4WCFrI3hYJVgjeFh+UCdVT3gla08hXSVbYSNfJVthJGolW2EkbSVbYSFQJVtheSVbYSFrJVthJVglW2F+TyFdKFZPfk94JWtPIVMlY08hVCViTyFdJVthflAkYk94KFlPIVMlY08hVCViTyFdJWJhflAkYk94KF1PeSVwWCFdJXBYIWslcFh+T3koYE8hXShiTyFrKGNPfk94I2pPeSR1aSF0JHVpI18kdWkkaiR1aSRtJHVpJVgkdWl+TyFlJldPZiV8YSRqJXxhI1clfGEjXyV8YSRtJXxhI1YlfGF+TyRqKGdPfk9UI3lPXyN6T3UjeE8lU1ZPfk94Jl9PeXRhfk9sdE9zdU9+UCdVT3gla08jXyVbYSRqJVthJG0lW2EhUCVbYXklW2EhXSVbYSFrJVthJVglW2F+UCRiT3gobE8jXyR1WCRqJHVYJG0kdVglWCR1WH5PJVgkU08jX1NpJGpTaSRtU2l+T3gjelgjXyN6WCRqI3pYJG0jelhrI3pYflAnVU94JmpPI18lXmEkaiVeYSRtJV5hayVeYX5PVChyT2YodE8lU1ZPfk8jVih1T35PJVNWT3gkYFgjXyRgWCRqJGBYJG0kYFh+T3gmck8jXyZPYSRqJk9hJG0mT2F+T2wscU9zLU9PeCRbWCNfJFtYJGokW1gkbSRbWHkkW1h+UCdVT3gmdE8jXyV7YSRqJXthJG0le2F5JXthfk9xKHxPI2Ioe09QI2BpVCNgaWQjYGlmI2BpbCNgaXAjYGlzI2BpdSNgaX0jYGkhTyNgaSFTI2BpIVQjYGkhVyNgaSFbI2BpIWcjYGkhbiNgaSFvI2BpIXAjYGkhdyNgaSF5I2BpIXsjYGkhfSNgaSNQI2BpI1QjYGkjViNgaSNZI2BpI1ojYGkjXSNgaSNkI2BpI2cjYGkjayNgaSNtI2BpI3IjYGkjdSNgaSRpI2BpJGojYGkkfCNgaSR9I2BpJVIjYGklUyNgaSVnI2BpJWgjYGklayNgaSVuI2BpJXQjYGkldyNgaSV5I2BpJG0jYGkkbiNgaSRvI2Bpfk9xKH1PUCNjaVQjY2lkI2NpZiNjaWwjY2lwI2NpcyNjaXUjY2l9I2NpIU8jY2khUyNjaSFUI2NpIVcjY2khWyNjaSFnI2NpIW4jY2khbyNjaSFwI2NpIXcjY2kheSNjaSF7I2NpIX0jY2kjUCNjaSNUI2NpI1YjY2kjWSNjaSNaI2NpI10jY2kjZCNjaSNnI2NpI2sjY2kjbSNjaSNyI2NpI3UjY2kkaSNjaSRqI2NpJHwjY2kkfSNjaSVSI2NpJVMjY2klZyNjaSVoI2NpJWsjY2klbiNjaSV0I2NpJXcjY2kleSNjaSRtI2NpJG4jY2kkbyNjaX5PVClQT2skZFh4JGRYflAnVU94JnhPayZRYX5PeCZ4T2smUWF+UCRiT2spVE9+T1BoT1RlT2x0T3AhU09zdU99dk8hTyFQTyFTIVZPIVQhVU8hd3hPIXl5TyF7ek8hfXtPI1B8TyNUfU8jViFPTyNZIVFPI1ohUU8jXSFSTyNkIVRPI2chV08jayFYTyNtIVlPI3IhWk8jdWxPflAnVU9xKVpPI2gnU08jaSlZT1AjZmlUI2ZpZCNmaWYjZmlsI2ZpcCNmaXMjZml1I2ZpfSNmaSFPI2ZpIVMjZmkhVCNmaSFXI2ZpIVsjZmkhZyNmaSFuI2ZpIW8jZmkhcCNmaSF3I2ZpIXkjZmkheyNmaSF9I2ZpI1AjZmkjVCNmaSNWI2ZpI1kjZmkjWiNmaSNdI2ZpI2QjZmkjZyNmaSNrI2ZpI20jZmkjciNmaSN1I2ZpJGkjZmkkaiNmaSR8I2ZpJH0jZmklUiNmaSVTI2ZpJWcjZmklaCNmaSVrI2ZpJW4jZmkldCNmaSV3I2ZpJXkjZmkkbSNmaSRuI2ZpJG8jZml+T2wscU9zLU9PeSRtT35QJ1VPbCxxT3MtT094JGZYeSRmWH5QJ1VPeCdWT3kmUmF+T1QpZE9fKWVPdSljTyVPKWZPJVNWT35PIVApaE9+UCFJeE95JG1PJlUpak9+T1QkfE9fJHxPbCxxT3MtT094I31YIVAjfVh+UCdVT3gnYk8hUCVjYX5PbCxxT3MtT095KXJPeCRPWCFYJE9YflAnVU94J2VPIVglZWF+T2wscU9zLU9PeCdlT3kpdU8hWCVlYX5QJ1VPbCxxT3MtT094J2VPIVglZWF+UCdVT3gnZU95KXVPIVglZWF+T2osck9rLHJPbCx6T20se09oZ2lwZ2l4Z2khUGdpIVNnaSFUZ2klWWdpIVhnaXlnaSFdZ2kjX2dpJGpnaSRtZ2khT2dpI1dnaXFnaSFrZ2klWGdpfk9pLHRPflAhTHVPaWdpflAhTHVPVCdxT2wscU9zLU9PIVApek9+UCdVT2spfE9+T3gqT08hUCl6T35PIVAqUE9+T3glZk8hWCVhaX5PIVgqUk9+T3goWU8hUyVjTyFUJWJPIV0lYml+T3gla08hXSVbaSNfJVtpJGolW2kkbSVbaSFQJVtpeSVbaSFrJVtpJVglW2l+TyFdKlZPfk9fKlhPbCxxT3MtT094I3xYIV0jfFh+UCdVT3goWU8hXSViaX5PIV0qWk9+T1QqXU9sLHFPcy1PT3gkU1h5JFNYIV0kU1ghayRTWH5QJ1VPeChdT3klcGEhXSVwYSFrJXBhfk8hWyNdTyVyKmBPIV0hbFh+TyFdKmJPfk95KGBPIV0qY09+T3gkWWl5JFlpIXQkWWkjXyRZaSRqJFlpJG0kWWklWCRZaX5QJGJPVCZRT2wscU9zLU9PeCRZWCNfJFlYJGokWVgkbSRZWCVYJFlYflAnVU94KGxPI18kdWEkaiR1YSRtJHVhJVgkdWF+T3gjemEjXyN6YSRqI3phJG0jemFrI3phflAkYk94KmVPI18jU3EkaiNTcSRtI1Nxfk94KmZPI1cqaE8jXyV9WCRqJX1YJG0lfVghUCV9WH5PVCpqT2Yqa08lU1ZPfk9xKm1PI2Ioe09QI2BxVCNgcWQjYHFmI2BxbCNgcXAjYHFzI2BxdSNgcX0jYHEhTyNgcSFTI2BxIVQjYHEhVyNgcSFbI2BxIWcjYHEhbiNgcSFvI2BxIXAjYHEhdyNgcSF5I2BxIXsjYHEhfSNgcSNQI2BxI1QjYHEjViNgcSNZI2BxI1ojYHEjXSNgcSNkI2BxI2cjYHEjayNgcSNtI2BxI3IjYHEjdSNgcSRpI2BxJGojYHEkfCNgcSR9I2BxJVIjYHElUyNgcSVnI2BxJWgjYHElayNgcSVuI2BxJXQjYHEldyNgcSV5I2BxJG0jYHEkbiNgcSRvI2Bxfk9rJGRheCRkYX5QJGJPeCZ4T2smUWl+TyRtKnlPJG4qd08kbyp5T35PeCp9T3kkbU8jVyp9T35PI2krT09QI2ZxVCNmcWQjZnFmI2ZxbCNmcXAjZnFzI2ZxdSNmcX0jZnEhTyNmcSFTI2ZxIVQjZnEhVyNmcSFbI2ZxIWcjZnEhbiNmcSFvI2ZxIXAjZnEhdyNmcSF5I2ZxIXsjZnEhfSNmcSNQI2ZxI1QjZnEjViNmcSNZI2ZxI1ojZnEjXSNmcSNkI2ZxI2cjZnEjayNmcSNtI2ZxI3IjZnEjdSNmcSRpI2ZxJGojZnEkfCNmcSR9I2ZxJVIjZnElUyNmcSVnI2ZxJWgjZnElayNmcSVuI2ZxJXQjZnEldyNmcSV5I2ZxJG0jZnEkbiNmcSRvI2Zxfk8jVytQT3gkZmF5JGZhfk94J1ZPeSZSaX5PeSRSTyVYK1JPeCZUWCFQJlRYfk8lU1ZPeCZUWCFQJlRYfk94K1ZPIVAmU1h+TyFQK1hPfk95K1pPeCRPYSFYJE9hfk9sLHFPcy1PT3krW094JE9hIVgkT2F+UCdVT3gnZU8hWCVlaX5PbCxxT3MtT094J2VPIVglZWl+UCdVT3gnZU95K2BPIVglZWl+T3gjeWkhUCN5aX5QJGJPVCdxT2wscU9zLU9PflAnVU9rK2JPfk9UJ3FPbCxxT3MtT08hUCtjT35QJ1VPeCN7aSFYI3tpflAkYk94I3hpIV0jeGkjXyN4aSRqI3hpJG0jeGkhUCN4aXkjeGkhayN4aSVYI3hpflAkYk94KFlPIV0lYnF+TyFdK2RPfk95K2VPfk94KF1PeSVwaSFdJXBpIWslcGl+TyFbI11PJXIqYE8hXSFsYX5PeChsTyNfJHVpJGokdWkkbSR1aSVYJHVpfk8lU1ZPeCRfWCNfJF9YJGokX1gkbSRfWCFQJF9Yfk94KmZPI18lfWEkaiV9YSRtJX1hIVAlfWF+TyFQK21Pfk9rJGRpeCRkaX5QJGJPcStxT1AjZXlUI2V5ZCNleWYjZXlsI2V5cCNleXMjZXl1I2V5fSNleSFPI2V5IVMjZXkhVCNleSFXI2V5IVsjZXkhZyNleSFuI2V5IW8jZXkhcCNleSF3I2V5IXkjZXkheyNleSF9I2V5I1AjZXkjVCNleSNWI2V5I1kjZXkjWiNleSNdI2V5I2QjZXkjZyNleSNrI2V5I20jZXkjciNleSN1I2V5JGkjZXkkaiNleSR8I2V5JH0jZXklUiNleSVTI2V5JWcjZXklaCNleSVrI2V5JW4jZXkldCNleSV3I2V5JXkjZXkkbSNleSRuI2V5JG8jZXl+TyRtK3ZPJG4qd08kbyt2T35PI2krd09QI2Z5VCNmeWQjZnlmI2Z5bCNmeXAjZnlzI2Z5dSNmeX0jZnkhTyNmeSFTI2Z5IVQjZnkhVyNmeSFbI2Z5IWcjZnkhbiNmeSFvI2Z5IXAjZnkhdyNmeSF5I2Z5IXsjZnkhfSNmeSNQI2Z5I1QjZnkjViNmeSNZI2Z5I1ojZnkjXSNmeSNkI2Z5I2cjZnkjayNmeSNtI2Z5I3IjZnkjdSNmeSRpI2Z5JGojZnkkfCNmeSR9I2Z5JVIjZnklUyNmeSVnI2Z5JWgjZnklayNmeSVuI2Z5JXQjZnkldyNmeSV5I2Z5JG0jZnkkbiNmeSRvI2Z5fk94J1ZPeSZScX5PJVgrUk94JlRhIVAmVGF+T3gkZ1ghUCRnWH5QIUl4T3grVk8hUCZTYX5PbCxxT3MtT095LFBPeCRPaSFYJE9pflAnVU9sLHFPcy1PT3gkT2khWCRPaX5QJ1VPeSxQT3gkT2khWCRPaX5PeCdlTyFYJWVxfk9sLHFPcy1PT3gnZU8hWCVlcX5QJ1VPcCxVTyFTJWNPIVQlYk8hUCVdcSFYJV1xIV0lXXF4JV1xflAhL3BPeCN8aSFdI3xpflAkYk8jVyxZT3gkX2EjXyRfYSRqJF9hJG0kX2EhUCRfYX5PeCpmTyNfJX1pJGolfWkkbSV9aSFQJX1pfk8hUCxbT35PcSxeT1AjZSFSVCNlIVJkI2UhUmYjZSFSbCNlIVJwI2UhUnMjZSFSdSNlIVJ9I2UhUiFPI2UhUiFTI2UhUiFUI2UhUiFXI2UhUiFbI2UhUiFnI2UhUiFuI2UhUiFvI2UhUiFwI2UhUiF3I2UhUiF5I2UhUiF7I2UhUiF9I2UhUiNQI2UhUiNUI2UhUiNWI2UhUiNZI2UhUiNaI2UhUiNdI2UhUiNkI2UhUiNnI2UhUiNrI2UhUiNtI2UhUiNyI2UhUiN1I2UhUiRpI2UhUiRqI2UhUiR8I2UhUiR9I2UhUiVSI2UhUiVTI2UhUiVnI2UhUiVoI2UhUiVrI2UhUiVuI2UhUiV0I2UhUiV3I2UhUiV5I2UhUiRtI2UhUiRuI2UhUiRvI2UhUn5PbCxxT3MtT094JE9xIVgkT3F+UCdVT3ksY094JE9xIVgkT3F+T3gnZU8hWCVleX5PbCxxT3MsZ09+UCdVT3AsVU8hUyVjTyFUJWJPIVAlXXkhWCVdeSFdJV15eCVdeX5QIS9wT3gqZk8jXyV9cSRqJX1xJG0lfXEhUCV9cX5PbCxxT3MtT094JE95IVgkT3l+UCdVT3gnZU8hWCVlIVJ+T3AlYFghUCVgWCFTJWBYIVQlYFghWCVgWCFdJWBYeCVgWH5QIS9wT3AsVU8hUyVjTyFUJWJPIVAlX2EhWCVfYSFdJV9heCVfYX5PeSxvT35PeChsTyNfJHVhJGokdWEkbSR1YSVYJHVhflAkYk9rLHZPfk9sLHZPflAnVU95LHdPfk9xLHhPflAhL3BPJWglayV3JXklZyVuJXQlUyVnflwiLFxuICBnb3RvOiBcIiEmaCZVUFBQUCZWUCZfKHwpZCl7KmUrTytqUCxWUCZfLHQsdCZfUCZfUC9jUFBQUFBQL2MxYlBQMWJQMn1QM1c3YFBQN2M3bzdyUFBQJl8mX1BQOE8mX1BQJl8mX1BQJl8mXyZfJl84Uzh4Jl9QOHtQOU85TztxUDxWJl9QUFA8WjxhJlZQJlYmVlAmVlAmVlAmVlAmVlAmViZWJlZQJlZQUCZWUFAmVlA8Z1A8bjx0UDxuUDxuPG5QUFA8blA+bVA+dj58P1M+bVA8bj9ZUD9hP2c/bT95QFRAWkBlQG9AdUFjQWlBb0F1QlBCVkJdQmNCaUJvQ1JDXUNjQ2lDb0N5RFBEVkRdRGNEbURzRH1FVFBQUFBQUFBQUEVeRWhFcUV7RldQUFBQUFBQUFBQUFBJfUpnTlUhIXFQUCEheSEjWCEjYiEkVyEjfSEkYSEkZyEkaiEkbSEkcCEkdlBQUFBQUFBQUFAhJHkhJHxQUFBQUFBQUFAhJVMhJWAhJWwhJXghJXshJlIhJlghJl8hJmJdaU9yI20kbSdRKncmWGRPU1hZWmVocnN0dnh8fSFSIVMhVCFVIVghYyFkIWUhZiFnIWghaSFqIWwhbyFwIXEhcyF0IXohfSNSI1MjXSNqI20kTyRQJFIkVCRXJGgkaiRrJG0kfCVSJVklXSVfJWIlZiVrJW0ldyZRJl0mYSZqJmwmbSZ0JngmeydRJ1MnVidhJ2InZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUHkhY1AjaSN2JFgkZyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdXshZFAjaSN2JFgkZyRzJWQlaSVvJXAmYiZ6KGQobilPKXkqUSpTKnIrZix1fSFlUCNpI3YkWCRnJHMkdCVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSFQIWZQI2kjdiRYJGckcyR0JHUlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhUiFnUCNpI3YkWCRnJHMkdCR1JHYlZCVpJW8lcCZiJnooZChuKU8peSpRKlMqcitmLHUhVCFoUCNpI3YkWCRnJHMkdCR1JHYkdyVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSFYIWlQIW4jaSN2JFgkZyRzJHQkdSR2JHckeCVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdSZYU09TWFlaZWhyc3R2eHx9IVIhUyFUIVUhWCFjIWQhZSFmIWchaCFpIWohbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnYidlJ2cnaCdsJ3Encyd3J3woUyhZKF0obCh7KVApVClqKXIpdSl7KXwqTypYKl0qZSp3K1MrWitbK2ArYitlK3wsUCxVLGMsbyxxLHIscyx0LHYsdyx4LHksey1QJHlVT1hZWmhydHZ8fSFSIVMhVCFYIWohbCFvIXAhcSFzIXQjXSNqI20kUCRSJFQkVyRrJG0kfCVSJVklXSVfJWYlayVtJXcmXSZhJmwmbSZ0JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncyhZKF0obCh7KVQpailyKXUpeyl8Kk8qXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgsey1QJFRXT1hZWmhydnx9IVIhUyFUIVghaiFsI10jaiNtJFAkUiRUJFckayRtJHwlUiVdJV8lZiVrJW0ldyZdJmEmbCZtJnQmeydRJ1MnVidhJ2InZSdnJ2gnbCdzKFkoXShsKHspVClqKXIpdSl7Kk8qXSplKncrUytaK1srYCtlK3wsUCxjLHcseFEjfHVRLG0sZ1IsfC1PJlNkT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhbCFvIXAhcSFzIXQheiF9I1IjUyNdI2ojbSRPJFAkUiRUJFckaCRqJGskbSR8JVIlWSVdJV8lYiVmJWslbSV3JlEmXSZhJmombCZtJnQmeCZ7J1EnUydWJ2EnZSdnJ2gnbCdxJ3Mndyd8KFMoWShdKGwoeylQKVQpailyKXUpeyl8Kk8qWCpdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx5LHstUFcjcGwhTyFQJF9XI3h1Jl8sZy1PUSRhIVFRJHEhWVEkciFaUyR7IWonYlMmXiN5I3pRJ08kbFEoZSZXUShyJm5XKHMmcCh0KHUqa1EodiZyUSliJ1hTKWMnWitWUytVKWQpZVEraipmUStsKmhRK3gqfVEreitQUixqLFlSJl0jeGUhd1hZIVMhVCVfJWYncyh7KXsqT1IlXSF2USF7WFEleCNdUSZmJFRSJmkkV1QsZixVLG8hWSFrUCFuI2kjdiRYJGckcyR0JHUkdiR3JHgkeSVkJWklbyVwJmImeihkKG4pTyl5KlEqUypyK2YsdVEmWiNxUideJHJSJ2Eke1IlVSFtJldjT1NYWVplaHJzdHZ4fH0hUiFTIVQhVSFYIWMhZCFlIWYhZyFoIWkhaiFsIW8hcCFxIXMhdCF6IX0jUiNTI10jaiNtJE8kUCRSJFQkVyRoJGokayRtJHwlUiVZJV0lXyViJWYlayVtJXcmUSZdJmEmaiZsJm0mdCZ4JnsnUSdTJ1YnYSdiJ2UnZydoJ2wncSdzJ3cnfChTKFkoXShsKHspUClUKWopcil1KXspfCpPKlgqXSplKncrUytaK1srYCtiK2UrfCxQLFUsYyxvLHEscixzLHQsdix3LHgseSx7LVBUI2djI2hTI15fI19TI2FgI2JTI2NhI2RTI2ViI2ZUKmAoYCphVChhJXgoY1EkVndSK1QpY1gkVHckVSRWJmhaa09yJG0nUSp3WG9PcidRKndRJG4hV1EmdiRlUSZ3JGZRJ1kkcFEnXSRyUSlVJn1RKVsnU1EpXidUUSlfJ1VRKWsnW1EpbSdeUSpuKHtRKnAofFEqcSh9USpzKVNTKnUpVilsUSp6KVlRKnspWlEqfCldUStvKm1RK3Aqb1Ercip0UStzKnZRK3krT1EsXStxUSxfK3dRLGAreFIsayxeV29PcidRKndSI3NuUSdbJHFSKVYnT1ErUyljUit8K1RRKWwnW1IqdilWWm1PbnInUSp3UXJPUiN1clEmYCN7UihqJmBTJWwjUSN9UyhUJWwoV1QoVyVvJmJRJWAheVMndCVgJ3lSJ3klZFEmayRYUihvJmtRJWchfFMnfSVnKFBSKFAlaVEoWiVwUSpUKFVUKlkoWipUUSdjJH1SKXAnY1MnZiVRJVJZKXMnZil0K14sUyxkVSl0J2cnaCdpVSteKXUpdil3UyxTK18rYFIsZCxUUSNYXVIlcyNYUSNbXlIldSNbUSNfX1IleSNfUSheJXZTKl4oXipfUipfKF9RKmEoYFIraCphUSNiYFIleyNiUSNkYVIlfCNkUSNmYlIlfSNmUSNoY1ImTyNoUSNrZlEmUCNpVyZTI2smUChtKmRRKG0mZVIqZCx1USRVd1MmZyRVJmhSJmgkVlEmdSRjUih5JnVRJlgjcFIoZiZYUSRfIVBSJm8kX1EqZyhzUytrKmcsWlIsWitsUSZzJGFSKHcmc1EjbmpSJlUjblEqeClXUit1KnhRKHomdlIqbCh6USZ5JGdTKVEmeSlSUilSJnpRJ1IkblIpWCdSUSdXJG9TKWEnVytRUitRKWJRK1cpZ1IsTytXV25PcidRKndSI3JuU3FPclEpVydRUit0KndXcE9yJ1Eqd1InUCRtWWpPciRtJ1Eqd1ImVCNtW3dPciNtJG0nUSp3UiZmJFQkeFBPWFlaaHJ0dnx9IVIhUyFUIVghaiFsIW8hcCFxIXMhdCNdI2ojbSRQJFIkVCRXJGskbSR8JVIlWSVdJV8lZiVrJW0ldyZdJmEmbCZtJnQmeydRJ1MnVidhJ2InZSdnJ2gnbCdzKFkoXShsKHspVClqKXIpdSl7KXwqTypdKmUqdytTK1orWytgK2IrZSt8LFAsVSxjLG8scSxyLHMsdCx2LHcseCx7LVBRIW5TUSNpZVEjdnNVJFh4JWInd1MkZyFVJGpRJHMhY1EkdCFkUSR1IWVRJHYhZlEkdyFnUSR4IWhRJHkhaVElZCF6USVpIX1RJW8jUlElcCNTUSZiJE9RJnokaFEoZCZRUShuJmpRKU8meFEpeSdxUSpRJ3xRKlMoU1EqcilQUStmKlhSLHUseVEheVhRIXxZUSRlIVNRJGYhVFcncCVfJ3MpeypPUSd7JWZSKm8oe1tmT3IjbSRtJ1Eqd2QhdlhZIVMhVCVfJWYncyh7KXsqT1EjUVpRI2xoUyN9dnxRJFt9VyRjIVIkVyZ7KVRTJG8hWCRrUyR6IWonYlElUSFsUSV2I11TJlIjaihsUSZjJFBRJmQkUlEmZSRUUSdfJHxRJ2klUlEnbyVdUShSJWtRKFUlbVEoXyV3UShoJl1TKGsmYSx3UShwJmxRKHEmbVEoeCZ0USldJ1NRKWAnVlEpbidhUSlxJ2VRKXYnZ1EpdydoUyl4J2wseFEqVyhZUSpbKF1RK1kpalErXSlyUStfKXVRK2cqXVEraSplUSt7K1NRLFErWlEsUitbUSxUK2BRLFgrZVEsYSt8USxiLFBSLGwsY2JUT3IjaiNtJG0mYSdRJ2wqdyNwIXVYWVpodnx9IVIhUyFUIVghaiFsI10kUCRSJFQkVyRrJHwlUiVdJV8lZiVrJW0ldyZdJmwmbSZ0JnsnUydWJ2EnYidlJ2cnaCdzKFkoXShsKHspVClqKXIpdSl7Kk8qXSplK1MrWitbK2ArZSt8LFAsYyx3LHhRI3d0VyVWIW8hcyxyLHtRJVchcFElWCFxUSVaIXRRJWUscVMnayVZLHZRJ20sc1Enbix0USthKXxRLFcrYlMsZSxVLG9SLH0tUFUje3UsZy1PUihpJl9bZ09yI20kbSdRKndYIXhYI10kVCRXUSNWWlEkUXZSJFp8USVhIXlRJWghfFElbiNRUSdfJHpRJ3olZFEoUSVpUShYJW9RKFslcFEqVShVUSxWK2FRLGksV1IsbixoUSRZeFEndiViUil9J3dRLGgsVVIscCxvUiNQWVIjVVpSJVAhalEkfSFqUilvJ2JSJVMhbFIleCNdUShiJXhSKmMoY1EkZCFSUSZpJFdRKVMme1IqdClUUSNxbFEkXSFPUSRgIVBSJnEkX1EociZwUSppKHRRKmoodVIrbiprUiRiIVFYcE9yJ1Eqd1EkaSFVUiZ8JGpRJHAhWFImfSRrUilpJ1pRKWcnWlIrfStWXCIsXG4gIG5vZGVOYW1lczogXCLimqAgcHJpbnQgQ29tbWVudCBTY3JpcHQgQXNzaWduU3RhdGVtZW50ICogQmluYXJ5RXhwcmVzc2lvbiBCaXRPcCBCaXRPcCBCaXRPcCBCaXRPcCBBcml0aE9wIEFyaXRoT3AgQCBBcml0aE9wICoqIFVuYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEJpdE9wIEF3YWl0RXhwcmVzc2lvbiBhd2FpdCBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiAoIEJpbmFyeUV4cHJlc3Npb24gb3IgYW5kIENvbXBhcmVPcCBpbiBub3QgaXMgVW5hcnlFeHByZXNzaW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBpZiBlbHNlIExhbWJkYUV4cHJlc3Npb24gbGFtYmRhIFBhcmFtTGlzdCBzZWxmIFZhcmlhYmxlTmFtZSBBc3NpZ25PcCAsIDogTmFtZWRFeHByZXNzaW9uIEFzc2lnbk9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBmcm9tICkgVHVwbGVFeHByZXNzaW9uIENvbXByZWhlbnNpb25FeHByZXNzaW9uIGFzeW5jIGZvciBMYW1iZGFFeHByZXNzaW9uIEFycmF5RXhwcmVzc2lvbiBbIF0gQXJyYXlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBEaWN0aW9uYXJ5RXhwcmVzc2lvbiB7IH0gRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uIFNldEV4cHJlc3Npb24gU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb24gQ2FsbEV4cHJlc3Npb24gQXJnTGlzdCBBc3NpZ25PcCBNZW1iZXJFeHByZXNzaW9uIC4gUHJvcGVydHlOYW1lIE51bWJlciBTdHJpbmcgRm9ybWF0U3RyaW5nIEZvcm1hdFJlcGxhY2VtZW50IEZvcm1hdENvbnZlcnNpb24gRm9ybWF0U3BlYyBDb250aW51ZWRTdHJpbmcgRWxsaXBzaXMgTm9uZSBCb29sZWFuIFR5cGVEZWYgQXNzaWduT3AgVXBkYXRlU3RhdGVtZW50IFVwZGF0ZU9wIEV4cHJlc3Npb25TdGF0ZW1lbnQgRGVsZXRlU3RhdGVtZW50IGRlbCBQYXNzU3RhdGVtZW50IHBhc3MgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgUmV0dXJuU3RhdGVtZW50IHJldHVybiBZaWVsZFN0YXRlbWVudCBQcmludFN0YXRlbWVudCBSYWlzZVN0YXRlbWVudCByYWlzZSBJbXBvcnRTdGF0ZW1lbnQgaW1wb3J0IGFzIFNjb3BlU3RhdGVtZW50IGdsb2JhbCBub25sb2NhbCBBc3NlcnRTdGF0ZW1lbnQgYXNzZXJ0IFN0YXRlbWVudEdyb3VwIDsgSWZTdGF0ZW1lbnQgQm9keSBlbGlmIFdoaWxlU3RhdGVtZW50IHdoaWxlIEZvclN0YXRlbWVudCBUcnlTdGF0ZW1lbnQgdHJ5IGV4Y2VwdCBmaW5hbGx5IFdpdGhTdGF0ZW1lbnQgd2l0aCBGdW5jdGlvbkRlZmluaXRpb24gZGVmIFBhcmFtTGlzdCBBc3NpZ25PcCBUeXBlRGVmIENsYXNzRGVmaW5pdGlvbiBjbGFzcyBEZWNvcmF0ZWRTdGF0ZW1lbnQgRGVjb3JhdG9yIEF0XCIsXG4gIG1heFRlcm06IDIzNixcbiAgbm9kZVByb3BzOiBbXG4gICAgW2xlemVyLk5vZGVQcm9wLmdyb3VwLCAtMTQsNCw4MSw4Myw4NCw4Niw4OCw5MCw5Miw5NCw5NSw5Niw5OCwxMDEsMTA0LFwiU3RhdGVtZW50IFN0YXRlbWVudFwiLC0yMyw2LDE2LDE5LDIxLDM3LDM4LDQ4LDQ5LDUzLDU2LDU3LDYwLDYxLDYyLDYzLDY2LDY5LDcwLDcxLDc1LDc2LDc3LDc4LFwiRXhwcmVzc2lvblwiLC05LDEwNiwxMDgsMTExLDExMywxMTQsMTE4LDEyMCwxMjUsMTI3LFwiU3RhdGVtZW50XCJdXG4gIF0sXG4gIHNraXBwZWROb2RlczogWzAsMl0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzMsXG4gIHRva2VuRGF0YTogXCIhRX1NZ1IhXk9YJH1YWSV3WVskfVtdJXddcCR9cHEld3FyKGNycypVc3QyT3R1JH11djRRdnc1VXd4NXh4eUFXeXpBdHp7QmJ7fENyfH1EZn0hT0VTIU8hUEZaIVAhUUthIVEhUkxxIVIhWyEoUCFbIV0hKWkhXSFeISptIV4hXyErWiFfIWAhLGshYCFhIS1fIWEhYiR9IWIhYyEubCFjIWQhL2IhZCFlITFmIWUhaCEvYiFoIWkhOE8haSF0IS9iIXQhdSE9YiF1IXchL2IhdyF4IT9gIXghfSEvYiF9I08hQHQjTyNQIUFiI1AjUSFCYyNRI1IhQ1AjUiNTIS9iI1MjVCR9I1QjVSEvYiNVI1YhMWYjViNZIS9iI1kjWiE4TyNaI2YhL2IjZiNnIT1iI2cjaSEvYiNpI2ohP2AjaiNvIS9iI28jcCFDcyNwI3EhRFsjcSNyIUVPI3IjcyFFYSNzJGckfSRnfiEvYjxyJWBSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laTdbJW5SJXI3W08jbyVpI3AjcSVpI3J+JWlNZyZbWiVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyRxMXNPWCVpWFkmfVlbJWlbXSZ9XXAlaXBxJn1xI08laSNPI1AndyNQI28laSNwI3ElaSNyfiVpSFAnVVolcjdbJHExc09YJWlYWSZ9WVslaVtdJn1dcCVpcHEmfXEjTyVpI08jUCd3I1AjbyVpI3AjcSVpI3J+JWlIUCd8ViVyN1tPWSVpWVomfVpdJWldXiZ9XiNvJWkjcCNxJWkjcn4laTx1KHRZJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgKWQhYCNUJWkjVCNVKXQjVSNmJWkjZiNnKXQjZyNoKXQjaCNvJWkjcCNxJWkjcn4laTdfKWtSalIlcjdbTyNvJWkjcCNxJWkjcn4laTdfKXtSIWtSJXI3W08jbyVpI3AjcSVpI3J+JWlHeyplXSV2cCVvYCVyN1sleCFiJWlTJWcsWE9ZK15ZWi57Wl0rXl1eLntecitecnMvXXMjTyteI08jUDB8I1AjbyteI28jcDFiI3AjcSteI3EjcjFiI3J+K15CbStnXSVyN1slbFclZyxYT1ksYFlaJWlaXSxgXV4laV5yLGBycy1gcyNPLGAjTyNQLXAjUCNvLGAjbyNwLlUjcCNxLGAjcSNyLlUjcn4sYEJlLGddJXI3WyVnLFhPWSxgWVolaVpdLGBdXiVpXnIsYHJzLWBzI08sYCNPI1AtcCNQI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgQmUtZ1IlcjdbJWcsWE8jbyVpI3AjcSVpI3J+JWlCZS11VCVyN1tPI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgLFguWlYlZyxYT1kuVVpdLlVeci5VcnMucHMjTy5VI08jUC51I1B+LlUsWC51TyVnLFgsWC54UE9+LlU3ZC9TUiVyN1slbFdPI28laSNwI3ElaSNyfiVpRWMvZFglcjdbJWcsWE9yLntyczBQcyNPLnsjTyNQMGMjUCNvLnsjbyNwMHcjcCNxLnsjcSNyMHcjcn4ue0VjMFlSJW0jfCVyN1slayxYTyNvJWkjcCNxJWkjcn4laTdkMGhUJXI3W08jby57I28jcDB3I3AjcS57I3EjcjB3I3J+LntXMHxPJWxXQm0xUlQlcjdbTyNvK14jbyNwMWIjcCNxK14jcSNyMWIjcn4rXixhMWlWJWxXJWcsWE9ZLlVaXS5VXnIuVXJzLnBzI08uVSNPI1AudSNQfi5VTWcyY1hRMXMlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPWTNPWVolaVpdM09dXiVpXiNvM08jbyNwM3IjcCNxM08jcSNyM3Ijcn4zT0hQM1ZYUTFzJXI3W09ZM09ZWiVpWl0zT11eJWleI28zTyNvI3AzciNwI3EzTyNxI3IzciNyfjNPMXMzd1JRMXNPWTNyWl0zcl5+M3JHejRlVCVQUSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlCZDR7UiF0LFclcjdbTyNvJWkjcCNxJWkjcn4laUd6NWlUJHlRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7NlhfJXNgJXVwJXI3WyV6I3QlbFclZyxYT1k3V1laOmRaXTdXXV46ZF5yN1dyczp4c3c3V3d4O3x4I083VyNPI1A+biNQI283VyNvI3A/dCNwI3E3VyNxI3I/UyNyfjdXRnE3ZV0lcjdbJXghYiV6I3QlaVMlZyxYT1k4XllaJWlaXTheXV4laV53OF53eC1geCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlOGVdJXI3WyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4LWB4I084XiNPI1A5XiNQI284XiNvI3A5ciNwI3E4XiNxI3I5ciNyfjheQmU5Y1QlcjdbTyNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XixYOXdWJWcsWE9ZOXJaXTlyXnc5cnd4LnB4I085ciNPI1A6XiNQfjlyLFg6YVBPfjlyO2g6b1IlcjdbJXghYiV6I3QlaVNPI28laSNwI3ElaSNyfiVpQ3s7VF0lcjdbJXghYiVpUyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4LWB4I084XiNPI1A5XiNQI284XiNvI3A5ciNwI3E4XiNxI3I5ciNyfjheRnE8VlolcjdbJXojdCVnLFhPcjpkcnM8eHN3OmR3eD1beCNPOmQjTyNQPXAjUCNvOmQjbyNwPl8jcCNxOmQjcSNyPlUjcn46ZDhyPVJSJXI3WyV4IWIlaVNPI28laSNwI3ElaSNyfiVpRnE9Z1IlaiFmJXI3WyV6I3QlaCxYTyNvJWkjcCNxJWkjcn4laTtoPXVUJXI3W08jbzpkI28jcD5VI3AjcTpkI3Ejcj5VI3J+OmQlWz5fTyV4IWIleiN0JWlTJVs+ZFAlaVMjbyNwPmclVz5uTyV4IWIleiN0RnE+c1QlcjdbTyNvN1cjbyNwP1MjcCNxN1cjcSNyP1Mjcn43VzBlP19WJXghYiV6I3QlaVMlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1B+OXIwZT97WCVpUyVnLFhPWTlyWl05cl53OXJ3eC5weCNPOXIjTyNQOl4jUCNvOXIjbyNwQGgjcH45cjBhQHFWJXghYiV6I3QlZyxYT1k5clpdOXJedzlyd3gucHgjTzlyI08jUDpeI1B+OXJHe0FrUmYsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWk8dUJYUiFQUiVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlHe0J1VlQsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV096JWl6e0NbeyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUJlQ2NUX1IlcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7RFZUJHwsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHe0R5UngsWCVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlNZ0VnVSR9LFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgIWFFeSFhI28laSNwI3ElaSNyfiVpPHZGUVImVSZqJXI3W08jbyVpI3AjcSVpI3J+JWlHe0ZuViFlUSVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hTyVpIU8hUEdUIVAhUSVpIVEhW0d5IVsjbyVpI3AjcSVpI3J+JWlCZUdZVCVyN1tPIU8laSFPIVBHaSFQI28laSNwI3ElaSNyfiVpQmVHcFIhbixYJXI3W08jbyVpI3AjcSVpI3J+JWlCY0hRXyFnLFYlcjdbTyFRJWkhUSFbR3khWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTR3kjUyNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNvJWkjcCNxJWkjcn4laUJjSVVYJXI3W097JWl7fElxfH0laX0hT0lxIU8hUSVpIVEhW0pWIVsjbyVpI3AjcSVpI3J+JWlCY0l2VCVyN1tPIVElaSFRIVtKViFbI28laSNwI3ElaSNyfiVpQmNKXlohZyxWJXI3W08hUSVpIVEhW0pWIVshbCVpIWwhbUtQIW0jUiVpI1IjU0pWI1MjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCY0tXUiFnLFYlcjdbTyNvJWkjcCNxJWkjcn4laUd7S3RWJU9SJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFQJWkhUCFRTFohUSFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUJkTGJUJVFRJXI3W08hXyVpIV8hYDR0IWAjbyVpI3AjcSVpI3J+JWlHeU1VbSFnLFYlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIU8laSFPIVAhIFAhUCFRJWkhUSFbISFrIVshZCVpIWQhZSEjdyFlIWclaSFnIWhJUCFoIWwlaSFsIW1LUCFtIXElaSFxIXIhJVYhciF6JWkheiF7ISZfIXsjUiVpI1IjUyEhayNTI1UlaSNVI1YhI3cjViNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNjJWkjYyNkISVWI2QjbCVpI2wjbSEmXyNtI28laSNwI3ElaSNyfiVpQmMhIFVUJXI3W08hUSVpIVEhWyEgZSFbI28laSNwI3ElaSNyfiVpQmMhIGxfIWcsViVyN1tPIVElaSFRIVshIGUhWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISBlI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCYyEhcmEhZyxWJXI3W08hTyVpIU8hUCEgUCFQIVElaSFRIVshIWshWyFnJWkhZyFoSVAhaCFsJWkhbCFtS1AhbSNSJWkjUiNTISFrI1MjWCVpI1gjWUlQI1kjXiVpI14jX0tQI18jbyVpI3AjcSVpI3J+JWlCYyEjfFclcjdbTyFRJWkhUSFSISRmIVIhUyEkZiFTI1IlaSNSI1MhJGYjUyNvJWkjcCNxJWkjcn4laUJjISRtVyFnLFYlcjdbTyFRJWkhUSFSISRmIVIhUyEkZiFTI1IlaSNSI1MhJGYjUyNvJWkjcCNxJWkjcn4laUJjISVbViVyN1tPIVElaSFRIVkhJXEhWSNSJWkjUiNTISVxI1MjbyVpI3AjcSVpI3J+JWlCYyEleFYhZyxWJXI3W08hUSVpIVEhWSElcSFZI1IlaSNSI1MhJXEjUyNvJWkjcCNxJWkjcn4laUJjISZkWiVyN1tPIVElaSFRIVshJ1YhWyFjJWkhYyFpISdWIWkjUiVpI1IjUyEnViNTI1QlaSNUI1ohJ1YjWiNvJWkjcCNxJWkjcn4laUJjISdeWiFnLFYlcjdbTyFRJWkhUSFbISdWIVshYyVpIWMhaSEnViFpI1IlaSNSI1MhJ1YjUyNUJWkjVCNaISdWI1ojbyVpI3AjcSVpI3J+JWlHeSEoZGEhZyxWJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFPJWkhTyFQISBQIVAhUSVpIVEhWyEhayFbIWclaSFnIWhJUCFoIWwlaSFsIW1LUCFtI1IlaSNSI1MhIWsjUyNYJWkjWCNZSVAjWSNeJWkjXiNfS1AjXyNvJWkjcCNxJWkjcn4laU1nISl8VHkxcyVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08hXyVpIV8hYCEqXSFgI28laSNwI3ElaSNyfiVpN18hKmRSJVlSJXI3W08jbyVpI3AjcSVpI3J+JWlHeyErUVIjXyxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laUd7IStuVmpSJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFeJWkhXiFfISxUIV8hYClkIWAhYSlkIWEjbyVpI3AjcSVpI3J+JWlCZCEsW1QkelElcjdbTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd7IS1PVCVYLFglb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWApZCFgI28laSNwI3ElaSNyfiVpR3shLXJValIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWApZCFgIWEhLlUhYSNvJWkjcCNxJWkjcn4laUJkIS5dVCR7USVyN1tPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpR3shL1JUXVEjdVAlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpTWchL3daJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPIVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpIUCEwc1olcjdbJWYmaiVTLFhPIVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyExe2Mlb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIXQhMGohdCF1ITZ2IXUhfSEwaiF9I1IlaSNSI1MhMGojUyNUJWkjVCNmITBqI2YjZyE2diNnI28hMGojcCNxJWkjciRnJWkkZ34hMGpCZSEzX10lcjdbJWcsWE9ZLGBZWiVpWl0sYF1eJWlecixgcnMhNFdzI08sYCNPI1AtcCNQI28sYCNvI3AuVSNwI3EsYCNxI3IuVSNyfixgQmUhNF9UJXI3WyVnLFhPciVpcnMhNG5zI28laSNwI3ElaSNyfiVpQmUhNHVSJXI3WyVrLFhPI28laSNwI3ElaSNyfiVpQmUhNVZdJXI3WyVnLFhPWTheWVolaVpdOF5dXiVpXnc4Xnd4ITZPeCNPOF4jTyNQOV4jUCNvOF4jbyNwOXIjcCNxOF4jcSNyOXIjcn44XkJlITZWVCVyN1slZyxYT3claXd4ITZmeCNvJWkjcCNxJWkjcn4laUJlITZtUiVyN1slaCxYTyNvJWkjcCNxJWkjcn4laUhQITdQXyVyN1slZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIX0hMGohfSNSJWkjUiNTITBqI1MjVCVpI1QjbyEwaiNwI3ElaSNyJGclaSRnfiEwak1nIThlYyVvYCV1cCVyN1sleCFiJXojdCVpUyVsVyVmJmolUyxYT3IlaXJzITlwc3claXd4ITp8eCFRJWkhUSFbITBqIVshYyVpIWMhdCEwaiF0IXUhPFkhdSF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI2YhMGojZiNnITxZI2cjbyEwaiNwI3ElaSNyJGclaSRnfiEwakJlITl3VCVyN1sldCxYT3IlaXJzITpXcyNvJWkjcCNxJWkjcn4laUJlITpdVCVyN1tPciVpcnMhOmxzI28laSNwI3ElaSNyfiVpQmUhOnNSJXI3WyV5LFhPI28laSNwI3ElaSNyfiVpQmUhO1RUJXI3WyVuLFhPdyVpd3ghO2R4I28laSNwI3ElaSNyfiVpQmUhO2lUJXI3W093JWl3eCE7eHgjbyVpI3AjcSVpI3J+JWlCZSE8UFIlcjdbJXcsWE8jbyVpI3AjcSVpI3J+JWlIUCE8Y18lcjdbJWYmaiVTLFhPciVpcnMhOXBzdyVpd3ghOnx4IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpNZyE9d2clb2AldXAlcjdbJXghYiV6I3QlaVMlbFclZiZqJVMsWE9yJWlycyEzV3N3JWl3eCE1T3ghUSVpIVEhWyEwaiFbIWMlaSFjIWghMGohaCFpITxZIWkhdCEwaiF0IXUhNnYhdSF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI1UhMGojVSNWITZ2I1YjWSEwaiNZI1ohPFkjWiNvITBqI3AjcSVpI3IkZyVpJGd+ITBqTWchP3VfJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXJWYmaiVTLFhPciVpcnMhM1dzdyVpd3ghNU94IVElaSFRIVshMGohWyFjJWkhYyF9ITBqIX0jUiVpI1IjUyEwaiNTI1QlaSNUI28hMGojcCNxJWkjciRnJWkkZ34hMGpHeyFBWFIhVyxYJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyNvJWkjcCNxJWkjcn4laU1nIUFnWCVyN1tPWSR9WVold1pdJH1dXiV3XiNvJH0jbyNwIUJTI3AjcSR9I3EjciFCUyNyfiR9JmYhQmNPJW9gJXVwJXghYiV6I3QlaVMlbFc8dSFCdlIhWFIlb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPI28laSNwI3ElaSNyfiVpR3ohQ2RUJHhRJW9gJXVwJXI3WyV4IWIleiN0JWlTJWxXTyFfJWkhXyFgNHQhYCNvJWkjcCNxJWkjcn4laUd5IUN8UCFbR20laVMlbFcjbyNwIURQJlkhRFtPJW9gJXVwJXghYiV6I3RHeiFEb1Qkd1Elb2AldXAlcjdbJXghYiV6I3QlaVMlbFdPIV8laSFfIWA0dCFgI28laSNwI3ElaSNyfiVpPHUhRWFPIV03XyVvYCV1cCV4IWIleiN0JWlTJWxXR3khRXRSJVIsViVvYCV1cCVyN1sleCFiJXojdCVpUyVsV08jbyVpI3AjcSVpI3J+JWlcIixcbiAgdG9rZW5pemVyczogW2xlZ2FjeVByaW50LCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgbmV3bGluZXMsIGJvZHlDb250aW51ZV0sXG4gIHRvcFJ1bGVzOiB7XCJTY3JpcHRcIjpbMCwzXX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDE4OCwgZ2V0OiB2YWx1ZSA9PiBzcGVjX2lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogNjA3NlxufSk7XG5cbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjdHJlZS5Ob2RlVHlwZSkgY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoXG4vLy8gaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFcbiAgICAvLy8gYGRlc2VyaWFsaXplYCBmdW5jdGlvbi5cbiAgICBjb25zdHJ1Y3Rvcih7IGRlc2VyaWFsaXplIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgc3RyaW5nLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb24gaXNcbiAgICAvLy8gdGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICAgIHN0YXRpYyBzdHJpbmcoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ciB9KTsgfVxuICAgIC8vLyBDcmVhdGUgYSBudW1iZXItdmFsdWVkIG5vZGUgcHJvcCB3aG9zZSBkZXNlcmlhbGl6ZSBmdW5jdGlvbiBpc1xuICAgIC8vLyBqdXN0IGBOdW1iZXJgLlxuICAgIHN0YXRpYyBudW1iZXIoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogTnVtYmVyIH0pOyB9XG4gICAgLy8vIENyZWF0ZXMgYSBib29sZWFuLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb25cbiAgICAvLy8gcmV0dXJucyB0cnVlIGZvciBhbnkgaW5wdXQuXG4gICAgc3RhdGljIGZsYWcoKSB7IHJldHVybiBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogKCkgPT4gdHJ1ZSB9KTsgfVxuICAgIC8vLyBTdG9yZSBhIHZhbHVlIGZvciB0aGlzIHByb3AgaW4gdGhlIGdpdmVuIG9iamVjdC4gVGhpcyBjYW4gYmVcbiAgICAvLy8gdXNlZnVsIHdoZW4gYnVpbGRpbmcgdXAgYSBwcm9wIG9iamVjdCB0byBwYXNzIHRvIHRoZVxuICAgIC8vLyBbYE5vZGVUeXBlYF0oI3RyZWUuTm9kZVR5cGUpIGNvbnN0cnVjdG9yLiBSZXR1cm5zIGl0cyBmaXJzdFxuICAgIC8vLyBhcmd1bWVudC5cbiAgICBzZXQocHJvcE9iaiwgdmFsdWUpIHtcbiAgICAgICAgcHJvcE9ialt0aGlzLmlkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gcHJvcE9iajtcbiAgICB9XG4gICAgLy8vIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVNldC5leHRlbmRgXSgjdHJlZS5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BQYXJzZXIud2l0aFByb3BzYF0oI2xlemVyLlBhcnNlci53aXRoUHJvcHMpIHRvIGNvbXB1dGUgcHJvcFxuICAgIC8vLyB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgLy8vIG9iamVjdF0oI3RyZWUuTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBQcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuLy8vIGRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG4vLy8gc3BhY2Utc2VwYXJhdGVkIHN0cmluZyB3aGVuIGRlY2xhcmluZyB0aGlzIHByb3AgaW4gYSBncmFtbWFyKVxuLy8vIGZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbk5vZGVQcm9wLmNsb3NlZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFRoZSBpbnZlcnNlIG9mIFtgb3BlbmVkQnlgXSgjdHJlZS5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8vIEVhY2ggbm9kZSBpbiBhIHN5bnRheCB0cmVlIGhhcyBhIG5vZGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgLy8vIGdyYW1tYXIgd2FzIHdyaXR0ZW4gcHJvcGVybHksIGRpZmZlcmVudCBub2RlIHR5cGVzIHdpdGggdGhlXG4gICAgLy8vIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIC8vLyByb2xlLlxuICAgIG5hbWUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwcm9wcywgXG4gICAgLy8vIFRoZSBpZCBvZiB0aGlzIG5vZGUgaW4gaXRzIHNldC4gQ29ycmVzcG9uZHMgdG8gdGhlIHRlcm0gaWRzXG4gICAgLy8vIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICBpZCwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIFRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBFcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBBbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpXG4gICAgICAgICAgICAgICAgICAgIHNyY1swXS5zZXQocHJvcHMsIHNyY1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvLy8gUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgLy8vIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgIHByb3AocHJvcCkgeyByZXR1cm4gdGhpcy5wcm9wc1twcm9wLmlkXTsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBUb3AgKi8pID4gMDsgfVxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIHByb2R1Y2VkIGJ5IGEgc2tpcCBydWxlLlxuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLy8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICBnZXQgaXNFcnJvcigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBFcnJvciAqLykgPiAwOyB9XG4gICAgLy8vIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIC8vLyBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICBnZXQgaXNBbm9ueW1vdXMoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDggLyogQW5vbnltb3VzICovKSA+IDA7IH1cbiAgICAvLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgLy8vIFtncm91cHNdKCN0cmVlLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICAvLy8gc3BlY2lmeWluZyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydHkgbmFtZXMgYXJlIG5vZGUgb3JcbiAgICAvLy8gW2dyb3VwXSgjdHJlZS5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI3RyZWUuTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICAvLy8gbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgLy8vIG11bHRpcGxlIG5vZGUgbmFtZXMgdG8gYSBzaW5nbGUgdmFsdWUuXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vLyBBbiBlbXB0eSBkdW1teSBub2RlIHR5cGUgdG8gdXNlIHdoZW4gbm8gYWN0dWFsIHR5cGUgaXMgYXZhaWxhYmxlLlxuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIEFub255bW91cyAqLyk7XG4vLy8gQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuLy8vIGNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuLy8vIGZ1bGwgcG9pbnRlciB0byB0aGUgdHlwZSBvYmplY3QsIGluIGEgbnVtYmVyIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsZXplci5QYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG4vLy8gYnVmZmVyc10oI3RyZWUuVHJlZUJ1ZmZlcikgY2FuIG9ubHkgc3RvcmUgY29sbGVjdGlvbnMgb2Ygbm9kZXNcbi8vLyBmcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNilcbi8vLyBub2RlIHR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5XG4vLy8gc2xvdHMuXG5jbGFzcyBOb2RlU2V0IHtcbiAgICAvLy8gQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgLy8vIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBzZXQgd2l0aCBzb21lIG5vZGUgcHJvcGVydGllcyBhZGRlZC4gVGhlXG4gICAgLy8vIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY3JlYXRlZCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI3RyZWUuTm9kZVByb3AuYWRkKS5cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkWzBdLnNldChuZXdQcm9wcywgYWRkWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgYFRyZWVDdXJzb3JgIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlcyBhIHZpZXcgb25cbi8vLyBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvIG1vdmUgYXJvdW5kXG4vLy8gdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlIHtcbiAgICAvLy8gQ29uc3RydWN0IGEgbmV3IHRyZWUuIFlvdSB1c3VhbGx5IHdhbnQgdG8gZ28gdGhyb3VnaFxuICAgIC8vLyBbYFRyZWUuYnVpbGRgXSgjdHJlZS5UcmVlXmJ1aWxkKSBpbnN0ZWFkLlxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIFxuICAgIC8vLyBUaGUgdHJlZSdzIGNoaWxkIG5vZGVzLiBDaGlsZHJlbiBzbWFsbCBlbm91Z2ggdG8gZml0IGluIGFcbiAgICAvLy8gYFRyZWVCdWZmZXIgd2lsbCBiZSByZXByZXNlbnRlZCBhcyBzdWNoLCBvdGhlciBjaGlsZHJlbiBjYW4gYmVcbiAgICAvLy8gZnVydGhlciBgVHJlZWAgaW5zdGFuY2VzIHdpdGggdGhlaXIgb3duIGludGVybmFsIHN0cnVjdHVyZS5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ubWFwKGMgPT4gYy50b1N0cmluZygpKS5qb2luKCk7XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCN0cmVlLlRyZWVDdXJzb3IpIHJvb3RlZCBhdCB0aGlzIHRyZWUuIFdoZW5cbiAgICAvLy8gYHBvc2AgaXMgZ2l2ZW4sIHRoZSBjdXJzb3IgaXMgW21vdmVkXSgjdHJlZS5UcmVlQ3Vyc29yLm1vdmVUbylcbiAgICAvLy8gdG8gdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLlxuICAgIGN1cnNvcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IChwb3MgIT0gbnVsbCAmJiBDYWNoZWROb2RlLmdldCh0aGlzKSkgfHwgdGhpcy50b3BOb2RlO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3Ioc2NvcGUpO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI3RyZWUuVHJlZUN1cnNvcikgdGhhdCwgdW5saWtlIHJlZ3VsYXJcbiAgICAvLy8gY3Vyc29ycywgZG9lc24ndCBza2lwIFthbm9ueW1vdXNdKCN0cmVlLk5vZGVUeXBlLmlzQW5vbnltb3VzKVxuICAgIC8vLyBub2Rlcy5cbiAgICBmdWxsQ3Vyc29yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcy50b3BOb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI3RyZWUuU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAvLy8gSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICAvLy8gZnJvbSBib3RoIHNpZGVzLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IocG9zLCBzaWRlKS5ub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vLyB3aWxsIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGZvciAobGV0IGMgPSB0aGlzLmN1cnNvcigpOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8pICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghYy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGMudHlwZSwgYy5mcm9tLCBjLnRvKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSBjLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZS5cbiAgICBiYWxhbmNlKG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IEJhbGFuY2VCcmFuY2hGYWN0b3IgPyB0aGlzXG4gICAgICAgICAgICA6IGJhbGFuY2VSYW5nZSh0aGlzLnR5cGUsIE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgbWF4QnVmZmVyTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG4vLy8gVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxuLy8vIG5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG4vLy8gYmVmb3JlIGNoaWxkcmVuLCB3aXRoIHRoZSBlbmRJbmRleCBvZiB0aGUgcGFyZW50IGluZGljYXRpbmcgd2hpY2hcbi8vLyBjaGlsZHJlbiBiZWxvbmcgdG8gaXQpXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIgQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZ3JvdXAgb2Ygbm9kZXMgaW4gdGhlIGJ1ZmZlci5cbiAgICBsZW5ndGgsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzZXQsIHR5cGUgPSBOb2RlVHlwZS5ub25lKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjaGlsZFN0cmluZyhpbmRleCkge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmJ1ZmZlcltpbmRleF0sIGVuZEluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnNldC50eXBlc1tpZF0sIHJlc3VsdCA9IHR5cGUubmFtZTtcbiAgICAgICAgaWYgKC9cXFcvLnRlc3QocmVzdWx0KSAmJiAhdHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgaWYgKGVuZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgXCIoXCIgKyBjaGlsZHJlbi5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIGFmdGVyKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChhZnRlciAhPSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBidWZmZXJbaSArIDFdLCBlbmQgPSBidWZmZXJbaSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPj0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGZyb20sIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLm5vZGUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubm9kZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBhZnRlciwgZnVsbCA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQubm9kZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyICE9IC0xMDAwMDAwMDAgLyogTm9uZSAqLyAmJiAoZGlyIDwgMCA/IHN0YXJ0ID49IGFmdGVyIDogc3RhcnQgKyBuZXh0Lmxlbmd0aCA8PSBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZ1bGwgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGwgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lciA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bGwgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MpOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcyk7IH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIC0xKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAtMSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIGFmdGVyKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBhZnRlciA9PSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gPyAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gOiBhZnRlciAtIHRoaXMuY29udGV4dC5zdGFydCk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MpOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MpOyB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIC0xKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKSk7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IubW92ZVRvKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGZ1bGwgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZ1bGwgPSBmdWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlcihkaXIsIGFmdGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIGFmdGVyLCB0aGlzLmZ1bGwpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSB0aGlzLmJ1ZmZlci5zdGFydCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXIoMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyKC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXIoMSwgcG9zKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgZW5kcyBhdCBvciBiZWZvcmUgYHBvc2AuXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyKC0xLCBwb3MpOyB9XG4gICAgLy8vIE1vdmUgdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHRoaXMuZnVsbCA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmZ1bGwgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgLTEwMDAwMDAwMCAvKiBOb25lICovLCB0aGlzLmZ1bGwpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihhZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLywgdGhpcy5mdWxsKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5ub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bGwgfHwgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpcikge1xuICAgICAgICBpZiAodGhpcy5lbnRlcihkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgICAvLy8gW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyXyhOTFIpKVxuICAgIC8vLyB0cmF2ZXJzYWwsIGdvaW5nIGZyb20gYSBub2RlIHRvIGl0cyBmaXJzdCBjaGlsZCBvciwgaWYgdGhlXG4gICAgLy8vIGN1cnJlbnQgbm9kZSBpcyBlbXB0eSwgaXRzIG5leHQgc2libGluZyBvciB0aGUgbmV4dCBzaWJsaW5nIG9mXG4gICAgLy8vIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dCgpIHsgcmV0dXJuIHRoaXMubW92ZSgxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYSBsYXN0LXRvLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJhbC4gQVxuICAgIC8vLyBub2RlIGlzIGZvbGxvd2VkIGJ5IGlzdCBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgLy8vIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIC8vLyBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICBwcmV2KCkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIC8vLyBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgLy8vIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/ICF0aGlzLmNoaWxkQmVmb3JlKHBvcykgOiAhdGhpcy5jaGlsZEFmdGVyKHBvcykpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI3RyZWUuU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjdHJlZS5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICAvLy8gYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIC8vLyBidWZmZXJdKCN0cmVlLlRyZWVCdWZmZXIpLlxuICAgIGdldCB0cmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5ub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBoYXNDaGlsZChjaCkpO1xufVxuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbmNvbnN0IEJhbGFuY2VCcmFuY2hGYWN0b3IgPSA4O1xuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCB0b3BJRCA9IDAsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBmdW5jdGlvbiB0YWtlTm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICB3aGlsZSAoaWQgPT0gaW5SZXBlYXQpIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAoeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoc2l6ZSA8IDApIHsgLy8gUmV1c2VkIG5vZGVcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gocmV1c2VkW2lkXSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4LCBpblJlcGVhdCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0LCBpblJlcGVhdCA8IDAgPyBOb2RlVHlwZS5ub25lIDogdHlwZXNbaW5SZXBlYXRdKTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbG9jYWxDaGlsZHJlbi5sZW5ndGggPiBCYWxhbmNlQnJhbmNoRmFjdG9yKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgdHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBtYXhCdWZmZXJMZW5ndGgsIGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IFRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemUsIHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4LCBpblJlcGVhdCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoaWQgPT0gaW5SZXBlYXQpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgsIGluUmVwZWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgPCBtaW5SZXBlYXRUeXBlKSB7IC8vIERvbid0IGNvcHkgcmVwZWF0IG5vZGVzIGludG8gYnVmZmVyc1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW3RvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKG91dGVyVHlwZSwgaW5uZXJUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgc3RhcnQsIG1heEJ1ZmZlckxlbmd0aCwgbGVuZ3RoKSB7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBpZiAobGVuZ3RoIDw9IG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uc1tpXSAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IG1heENoaWxkID0gTWF0aC5tYXgobWF4QnVmZmVyTGVuZ3RoLCBNYXRoLmNlaWwobGVuZ3RoICogMS41IC8gQmFsYW5jZUJyYW5jaEZhY3RvcikpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEVuZCA9IHBvc2l0aW9uc1tpXSArIGNoaWxkcmVuW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVuZCAtIGdyb3VwU3RhcnQgPiBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dO1xuICAgICAgICAgICAgICAgIGlmIChvbmx5IGluc3RhbmNlb2YgVHJlZSAmJiBvbmx5LnR5cGUgPT0gaW5uZXJUeXBlICYmIG9ubHkubGVuZ3RoID4gbWF4Q2hpbGQgPDwgMSkgeyAvLyBUb28gYmlnLCBjb2xsYXBzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9ubHkuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChvbmx5LmNoaWxkcmVuW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gob25seS5wb3NpdGlvbnNbal0gKyBncm91cFN0YXJ0IC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2gob25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBiYWxhbmNlUmFuZ2UoaW5uZXJUeXBlLCBpbm5lclR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbWF4QnVmZmVyTGVuZ3RoLCBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lclR5cGUgIT0gTm9kZVR5cGUubm9uZSAmJiAhY29udGFpbnNUeXBlKGlubmVyLmNoaWxkcmVuLCBpbm5lclR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGlubmVyLmNoaWxkcmVuLCBpbm5lci5wb3NpdGlvbnMsIGlubmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGlubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyZWUob3V0ZXJUeXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zVHlwZShub2RlcywgdHlwZSkge1xuICAgIGZvciAobGV0IGVsdCBvZiBub2RlcylcbiAgICAgICAgaWYgKGVsdC50eXBlID09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNsZXplci5QYXJzZU9wdGlvbnMuZnJhZ21lbnRzKSB0byB0cmFjayBwYXJ0cyBvZiBvbGRcbi8vLyB0cmVlcyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpc1xuLy8vIHVzZWQgdG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWRcbi8vLyBpbiBuZXcgcGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI3RyZWUuVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgbWV0aG9kIHRvIHVwZGF0ZVxuLy8vIGZyYWdtZW50cyBmb3IgZG9jdW1lbnQgY2hhbmdlcy5cbmNsYXNzIFRyZWVGcmFnbWVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cbiAgICAvLy8gVGhpcyByZWZlcnMgdG8gYW4gb2Zmc2V0IGluIHRoZSBfdXBkYXRlZF8gZG9jdW1lbnQgKGFzIG9wcG9zZWRcbiAgICAvLy8gdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgIGZyb20sIFxuICAgIC8vLyBUaGUgZW5kIG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UuXG4gICAgdG8sIFxuICAgIC8vLyBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXG4gICAgdHJlZSwgXG4gICAgLy8vIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIC8vLyB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxuICAgIC8vLyBkb2N1bWVudCB0byB0cmVlIHBvc2l0aW9ucywgc3VidHJhY3QgaXQgdG8gZ28gZnJvbSB0cmVlIHRvXG4gICAgLy8vIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICBvZmZzZXQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIFN0YXJ0ICovKSA+IDA7IH1cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSSsrXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRyZWVGcmFnbWVudChmRnJvbSwgZlRvLCBjdXQudHJlZSwgY3V0Lm9mZnNldCArIG9mZiwgKGNJID4gMCA/IDEgLyogU3RhcnQgKi8gOiAwKSB8IChuZXh0QyA/IDIgLyogRW5kICovIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcbiAgICAvLy8gYW4gZXhpc3Rpbmcgc2V0IG9mIGZyYWdtZW50cyBieSByZXBsYWNpbmcgdGhlIG9uZXMgdGhhdCBvdmVybGFwXG4gICAgLy8vIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICAvLy8gdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSB0b2tlbiBhdCBpdHNcbiAgICAvLy8gZW5kIGlzIG5vdCBpbmNsdWRlZCBpbiBbYHNhZmVUb2BdKCN0cmVlLlRyZWVGcmFnbWVudC5zYWZlVG8pLlxuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtuZXcgVHJlZUZyYWdtZW50KDAsIHRyZWUubGVuZ3RoLCB0cmVlLCAwLCBwYXJ0aWFsID8gMiAvKiBFbmQgKi8gOiAwKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyBDcmVhdGVzIGFuIGBJbnB1dGAgdGhhdCBpcyBiYWNrZWQgYnkgYSBzaW5nbGUsIGZsYXQgc3RyaW5nLlxuZnVuY3Rpb24gc3RyaW5nSW5wdXQoaW5wdXQpIHsgcmV0dXJuIG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7IH1cbmNsYXNzIFN0cmluZ0lucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPCAwIHx8IHBvcyA+PSB0aGlzLmxlbmd0aCA/IC0xIDogdGhpcy5zdHJpbmcuY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICBsaW5lQWZ0ZXIocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKFwiXFxuXCIsIHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwb3MsIGVuZCA8IDAgPyB0aGlzLmxlbmd0aCA6IE1hdGgubWluKGVuZCwgdGhpcy5sZW5ndGgpKTtcbiAgICB9XG4gICAgcmVhZChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSk7IH1cbiAgICBjbGlwKGF0KSB7IHJldHVybiBuZXcgU3RyaW5nSW5wdXQodGhpcy5zdHJpbmcsIGF0KTsgfVxufVxuXG5leHBvcnRzLkRlZmF1bHRCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuZXhwb3J0cy5Ob2RlUHJvcCA9IE5vZGVQcm9wO1xuZXhwb3J0cy5Ob2RlU2V0ID0gTm9kZVNldDtcbmV4cG9ydHMuTm9kZVR5cGUgPSBOb2RlVHlwZTtcbmV4cG9ydHMuVHJlZSA9IFRyZWU7XG5leHBvcnRzLlRyZWVCdWZmZXIgPSBUcmVlQnVmZmVyO1xuZXhwb3J0cy5UcmVlQ3Vyc29yID0gVHJlZUN1cnNvcjtcbmV4cG9ydHMuVHJlZUZyYWdtZW50ID0gVHJlZUZyYWdtZW50O1xuZXhwb3J0cy5zdHJpbmdJbnB1dCA9IHN0cmluZ0lucHV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJlZS5janMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsZXplclRyZWUgPSByZXF1aXJlKCdsZXplci10cmVlJyk7XG5cbi8vLyBBIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbi8vLyBwYXJzaW5nIHByb2dyZXNzLiBUaGV5IGFsc28gcHJvdmlkZSBzb21lIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcbi8vLyB0aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuLy8vIGFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbmNsYXNzIFN0YWNrIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEEgZ3JvdXAgb2YgdmFsdWVzIHRoYXQgdGhlIHN0YWNrIHdpbGwgc2hhcmUgd2l0aCBhbGxcbiAgICAvLy8gc3BsaXQgaW5zdGFuY2VzXG4gICAgLy8vQGludGVybmFsXG4gICAgY3gsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgcG9zLCB2YWx1ZSBzdGFjayBwb3MgKDE1IGJpdHMgYXJyYXkgaW5kZXgsIDE1IGJpdHNcbiAgICAvLy8gYnVmZmVyIGluZGV4KSB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGUgdG9wIHN0YXRlXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YWNrLCBcbiAgICAvLy8gVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZVBvcywgXG4gICAgLy8vIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgcG9zLCBcbiAgICAvLy8gVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgLy8vIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICAvLy8gQGludGVybmFsXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIGJhc2Ugb2Zmc2V0IG9mIHRoZSBidWZmZXIuIFdoZW4gc3RhY2tzIGFyZSBzcGxpdCwgdGhlIHNwbGl0XG4gICAgLy8gaW5zdGFuY2Ugc2hhcmVkIHRoZSBidWZmZXIgaGlzdG9yeSB3aXRoIGl0cyBwYXJlbnQgdXAgdG9cbiAgICAvLyBgYnVmZmVyQmFzZWAsIHdoaWNoIGlzIHRoZSBhYnNvbHV0ZSBvZmZzZXQgKGluY2x1ZGluZyB0aGVcbiAgICAvLyBvZmZzZXQgb2YgcHJldmlvdXMgc3BsaXRzKSBpbnRvIHRoZSBidWZmZXIgYXQgd2hpY2ggdGhpcyBzdGFja1xuICAgIC8vIHN0YXJ0cyB3cml0aW5nLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXJCYXNlLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLmN4ID0gY3g7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICAgIH1cbiAgICAvLyBTdGFydCBhbiBlbXB0eSBzdGFja1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0aWMgc3RhcnQoY3gsIHN0YXRlLCBwb3MgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2soY3gsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdHlwZSA9IGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLmN4O1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNl4oCUdGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlIGluZGV4IGludG8gYHRoaXMuc3RhY2tgLCBjb250ZW50IGFmdGVyIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgZHJvcHBlZC4gTm90ZSB0aGF0IHdpdGggYFN0YXlGbGFnYCByZWR1Y3Rpb25zIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY29uc3VtZSB0d28gZXh0cmEgZnJhbWVzICh0aGUgZHVtbXkgcGFyZW50IG5vZGUgZm9yIHRoZSBza2lwcGVkXG4gICAgICAgIC8vIGV4cHJlc3Npb24gYW5kIHRoZSBzdGF0ZSB0aGF0IHdlJ2xsIGJlIHN0YXlpbmcgaW4sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBiZSBtb3ZlZCB0byBgdGhpcy5zdGF0ZWApLlxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKChkZXB0aCAtIDEpICogMykgLSAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovID8gNiA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAyXTtcbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSB0aGlzLnN0YWNrW2Jhc2UgLSAxXSwgY291bnQgPSB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGggLSBidWZmZXJCYXNlO1xuICAgICAgICAvLyBTdG9yZSBub3JtYWwgdGVybXMgb3IgYFIgLT4gUiBSYCByZXBlYXQgcmVkdWN0aW9uc1xuICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtIHx8IChhY3Rpb24gJiAxMzEwNzIgLyogUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU2tpcHBlZCAqLykgPyB0aGlzLnBvcyA6IHRoaXMucmVkdWNlUG9zO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgc3RhcnQsIHBvcywgY291bnQgKyA0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGFja1tiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiYXNlU3RhdGVJRCA9IHRoaXMuc3RhY2tbYmFzZSAtIDNdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHBhcnNlci5nZXRHb3RvKGJhc2VTdGF0ZUlELCB0eXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBiYXNlKVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gICAgLy8gU2hpZnQgYSB2YWx1ZSBpbnRvIHRoZSBidWZmZXJcbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogRXJyICovKSB7IC8vIFRyeSB0byBvbWl0L21lcmdlIGFkamFjZW50IGVycm9yIG5vZGVzXG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcywgdG9wID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvcCA9PSAwICYmIGN1ci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjdXIuYnVmZmVyQmFzZSAtIGN1ci5wYXJlbnQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCA+IDAgJiYgY3VyLmJ1ZmZlclt0b3AgLSA0XSA9PSAwIC8qIEVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVkdWNlIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMuYnVmZmVyW2luZGV4IC0gNF0gIT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaGlmdChhY3Rpb24sIG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDEzMTA3MiAvKiBHb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykgPT0gMCkgeyAvLyBSZWd1bGFyIHNoaWZ0XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcywgbmV4dFN0YXRlID0gYWN0aW9uLCB7IHBhcnNlciB9ID0gdGhpcy5jeDtcbiAgICAgICAgICAgIGlmIChuZXh0RW5kID4gdGhpcy5wb3MgfHwgbmV4dCA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV4dEVuZDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5zdGF0ZUZsYWcobmV4dFN0YXRlLCAxIC8qIFNraXBwZWQgKi8pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0U3RhdGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobmV4dCwgc3RhcnQsIG5leHRFbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIGlmIChuZXh0IDw9IHRoaXMuY3gucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCB0aGlzLnBvcywgbmV4dEVuZCwgNCk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgbm9kZSBpbnRvIHRoZSBidWZmZXIuIFRoaXMgbWF5IGJlIGEgcmV1c2VkIG5vZGUgb3JcbiAgICAvLyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYSBuZXN0ZWQgcGFyc2VyLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuY3gucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5jeC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmN4LnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPCAwIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IG9mZiA9IHBhcmVudC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciAoYWZ0ZXIgdGhpcy5wb3MpIG1heSBiZSBtdXRhdGVkXG4gICAgICAgIC8vIHRvIHJlb3JkZXIgcmVkdWN0aW9ucyBhbmQgc2tpcHBlZCB0b2tlbnMsIGFuZCBzaGFyZWQgYnVmZmVyc1xuICAgICAgICAvLyBzaG91bGQgYmUgaW1tdXRhYmxlLCB0aGlzIGNvcGllcyBhbnkgb3V0c3RhbmRpbmcgc2tpcHBlZCB0b2tlbnNcbiAgICAgICAgLy8gdG8gdGhlIG5ldyBidWZmZXIsIGFuZCBwdXRzIHRoZSBiYXNlIHBvaW50ZXIgYmVmb3JlIHRoZW0uXG4gICAgICAgIHdoaWxlIChvZmYgPiAwICYmIHBhcmVudC5idWZmZXJbb2ZmIC0gMl0gPiBwYXJlbnQucmVkdWNlUG9zKVxuICAgICAgICAgICAgb2ZmIC09IDQ7XG4gICAgICAgIGxldCBidWZmZXIgPSBwYXJlbnQuYnVmZmVyLnNsaWNlKG9mZiksIGJhc2UgPSBwYXJlbnQuYnVmZmVyQmFzZSArIG9mZjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludHMgdG8gYW4gYWN0dWFsIHBhcmVudCB3aXRoIGNvbnRlbnQsIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXJlbnQuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgYmFzZSA9PSBwYXJlbnQuYnVmZmVyQmFzZSlcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2sodGhpcy5jeCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlEZWxldGUobmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBsZXQgaXNOb2RlID0gbmV4dCA8PSB0aGlzLmN4LnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMjAwIC8qIFRva2VuICovO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhlIGdpdmVuIHRlcm0gd291bGQgYmUgYWJsZSB0byBiZSBzaGlmdGVkIChvcHRpb25hbGx5XG4gICAgLy8vIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIC8vLyBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIC8vLyBnaXZlbiB0b2tlbiB3aGVuIGl0IGFwcGxpZXMuXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuY3gucGFyc2VyLnN0YXRlU2xvdChzaW0udG9wLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMuY3gucGFyc2VyLmhhc0FjdGlvbihzaW0udG9wLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEZpbmQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBydWxlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHBhcnNlZC5cbiAgICBnZXQgcnVsZVN0YXJ0KCkge1xuICAgICAgICBmb3IgKGxldCBzdGF0ZSA9IHRoaXMuc3RhdGUsIGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmN4LnBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgICAgIGlmICghKGZvcmNlICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBiYXNlIC09IDMgKiAoZm9yY2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLyk7XG4gICAgICAgICAgICBpZiAoKGZvcmNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKSA8IHRoaXMuY3gucGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbYmFzZSArIDFdO1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBGaW5kIHRoZSBzdGFydCBwb3NpdGlvbiBvZiBhbiBpbnN0YW5jZSBvZiBhbnkgb2YgdGhlIGdpdmVuIHRlcm1cbiAgICAvLy8gdHlwZXMsIG9yIHJldHVybiBgbnVsbGAgd2hlbiBub25lIG9mIHRoZW0gYXJlIGZvdW5kLlxuICAgIC8vL1xuICAgIC8vLyAqKk5vdGU6KiogdGhpcyBpcyBvbmx5IHJlbGlhYmxlIHdoZW4gdGhlcmUgaXMgYXQgbGVhc3Qgc29tZVxuICAgIC8vLyBzdGF0ZSB0aGF0IHVuYW1iaWd1b3VzbHkgbWF0Y2hlcyB0aGUgZ2l2ZW4gcnVsZSBvbiB0aGUgc3RhY2suXG4gICAgLy8vIEkuZS4gaWYgeW91IGhhdmUgYSBncmFtbWFyIGxpa2UgdGhpcywgd2hlcmUgdGhlIGRpZmZlcmVuY2VcbiAgICAvLy8gYmV0d2VlbiBgYWAgYW5kIGBiYCBpcyBvbmx5IGFwcGFyZW50IGF0IHRoZSB0aGlyZCB0b2tlbjpcbiAgICAvLy9cbiAgICAvLy8gICAgIGEgeyBiIHwgYyB9XG4gICAgLy8vICAgICBiIHsgXCJ4XCIgXCJ5XCIgXCJ4XCIgfVxuICAgIC8vLyAgICAgYyB7IFwieFwiIFwieVwiIFwielwiIH1cbiAgICAvLy9cbiAgICAvLy8gVGhlbiBhIHBhcnNlIHN0YXRlIGFmdGVyIGBcInhcImAgd2lsbCBub3QgcmVsaWFibHkgdGVsbCB5b3UgdGhhdFxuICAgIC8vLyBgYmAgaXMgb24gdGhlIHN0YWNrLiBZb3UgX2Nhbl8gcGFzcyBgW2IsIGNdYCB0byByZWxpYWJseSBjaGVja1xuICAgIC8vLyBmb3IgZWl0aGVyIG9mIHRob3NlIHR3byBydWxlcyAoYXNzdW1pbmcgdGhhdCBgYWAgaXNuJ3QgcGFydCBvZlxuICAgIC8vLyBzb21lIHJ1bGUgdGhhdCBpbmNsdWRlcyBvdGhlciB0aGluZ3Mgc3RhcnRpbmcgd2l0aCBgXCJ4XCJgKS5cbiAgICAvLy9cbiAgICAvLy8gV2hlbiBgYmVmb3JlYCBpcyBnaXZlbiwgdGhpcyBrZWVwcyBzY2FubmluZyB1cCB0aGUgc3RhY2sgdW50aWxcbiAgICAvLy8gaXQgZmluZHMgYSBtYXRjaCB0aGF0IHN0YXJ0cyBiZWZvcmUgdGhhdCBwb3NpdGlvbi5cbiAgICBzdGFydE9mKHR5cGVzLCBiZWZvcmUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZSwgZnJhbWUgPSB0aGlzLnN0YWNrLmxlbmd0aCwgeyBwYXJzZXIgfSA9IHRoaXMuY3g7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIDUgLyogRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IGZvcmNlID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSBmb3JjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmRleE9mKHRlcm0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IGZyYW1lIC0gKDMgKiAoZm9yY2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLykpLCBwb3MgPSB0aGlzLnN0YWNrW2Jhc2UgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlID09IG51bGwgfHwgYmVmb3JlID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYW1lID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lIC09IDM7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YWNrW2ZyYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYW1lIC09IDMgKiAoZGVwdGggLSAxKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbZnJhbWUgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIE1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5jeC5wYXJzZXIubmV4dFN0YXRlcyh0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID4gNCAvKiBNYXhOZXh0ICovIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBEYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKSB7XG4gICAgICAgICAgICBsZXQgYmVzdCA9IG5leHRTdGF0ZXMuZmlsdGVyKHMgPT4gcyAhPSB0aGlzLnN0YXRlICYmIHRoaXMuY3gucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi8gJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0LmluZGV4T2YobmV4dFN0YXRlc1tpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0pO1xuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi87IGkrKykge1xuICAgICAgICAgICAgaWYgKG5leHRTdGF0ZXNbaV0gPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBUb2tlbiAqLztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGb3JjZSBhIHJlZHVjZSwgaWYgcG9zc2libGUuIFJldHVybiBmYWxzZSBpZiB0aGF0IGNhbid0XG4gICAgLy8gYmUgZG9uZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCByZWR1Y2UgPSB0aGlzLmN4LnBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5jeC5wYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBFcnIgKi8sIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmN4LnBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmIHRoaXMuZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICAvLy8gdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIC8vLyBzb21laG93KS4gQGludGVybmFsXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMuY3g7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIEVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLy8vIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICAvLy8gd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgLy8vIHN0YXRlKS4gQGludGVybmFsXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMuY3gucGFyc2VyOyB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICAvLy8gdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgZGlhbGVjdEVuYWJsZWQoZGlhbGVjdElEKSB7IHJldHVybiB0aGlzLmN4LnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbn1cbnZhciBSZWNvdmVyO1xuKGZ1bmN0aW9uIChSZWNvdmVyKSB7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiVG9rZW5cIl0gPSAyMDBdID0gXCJUb2tlblwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIlJlZHVjZVwiXSA9IDEwMF0gPSBcIlJlZHVjZVwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heE5leHRcIl0gPSA0XSA9IFwiTWF4TmV4dFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIk1heEluc2VydFN0YWNrRGVwdGhcIl0gPSAzMDBdID0gXCJNYXhJbnNlcnRTdGFja0RlcHRoXCI7XG4gICAgUmVjb3ZlcltSZWNvdmVyW1wiRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aFwiXSA9IDEyMF0gPSBcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIjtcbn0pKFJlY292ZXIgfHwgKFJlY292ZXIgPSB7fSkpO1xuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaykge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMudG9wID0gc3RhY2suc3RhdGU7XG4gICAgICAgIHRoaXMucmVzdCA9IHN0YWNrLnN0YWNrO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMucmVzdC5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0ID09IHRoaXMuc3RhY2suc3RhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0ID0gdGhpcy5yZXN0LnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3QucHVzaCh0aGlzLnRvcCwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFjay5jeC5wYXJzZXIuZ2V0R290byh0aGlzLnJlc3RbdGhpcy5vZmZzZXQgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMudG9wID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCwgc3RhY2suYnVmZmVyLmxlbmd0aCk7XG4gICAgfVxuICAgIG1heWJlTmV4dCgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2suYnVmZmVyQmFzZSAtIG5leHQuYnVmZmVyQmFzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBuZXh0O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXh0LmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmluZGV4IC09IDQ7XG4gICAgICAgIHRoaXMucG9zIC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBmb3JrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgICB9XG59XG5cbi8vLyBUb2tlbml6ZXJzIHdyaXRlIHRoZSB0b2tlbnMgdGhleSByZWFkIGludG8gaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHRva2VuLiBUaGlzIGlzIHNldCBieSB0aGUgcGFyc2VyLCBhbmQgc2hvdWxkIG5vdFxuICAgICAgICAvLy8gYmUgbXV0YXRlZCBieSB0aGUgdG9rZW5pemVyLlxuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIC8vLyBUaGlzIHN0YXJ0cyBhdCAtMSwgYW5kIHNob3VsZCBiZSB1cGRhdGVkIHRvIGEgdGVybSBpZCB3aGVuIGFcbiAgICAgICAgLy8vIG1hdGNoaW5nIHRva2VuIGlzIGZvdW5kLlxuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIC8vLyBXaGVuIHNldHRpbmcgYC52YWx1ZWAsIHlvdSBzaG91bGQgYWxzbyBzZXQgYC5lbmRgIHRvIHRoZSBlbmRcbiAgICAgICAgLy8vIHBvc2l0aW9uIG9mIHRoZSB0b2tlbi4gKFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gdXNlIHRoZSBgYWNjZXB0YFxuICAgICAgICAvLy8gbWV0aG9kLilcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEFjY2VwdCBhIHRva2VuLCBzZXR0aW5nIGB2YWx1ZWAgYW5kIGBlbmRgIHRvIHRoZSBnaXZlbiB2YWx1ZXMuXG4gICAgYWNjZXB0KHZhbHVlLCBlbmQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG59XG4vLy8gQGludGVybmFsXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCB0b2tlbiwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHRva2VuLCBzdGFjaywgdGhpcy5pZCk7IH1cbn1cblRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLy8vIEV4cG9ydHMgdGhhdCBhcmUgdXNlZCBmb3IgYEBleHRlcm5hbCB0b2tlbnNgIGluIHRoZSBncmFtbWFyIHNob3VsZFxuLy8vIGV4cG9ydCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8vLyBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICAvLy8gZ2l2ZW4gYW4gaW5wdXQgc3RyZWFtIGFuZCBhIHRva2VuIG9iamVjdCxcbiAgICAvLy8gW2ZpbGxzXSgjbGV6ZXIuVG9rZW4uYWNjZXB0KSB0aGUgdG9rZW4gb2JqZWN0IGlmIGl0IHJlY29nbml6ZXMgYVxuICAgIC8vLyB0b2tlbi4gYHRva2VuLnN0YXJ0YCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9zaXRpb24gdG9cbiAgICAvLy8gc2NhbiBmcm9tLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5jb250ZXh0dWFsID0gISFvcHRpb25zLmNvbnRleHR1YWw7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAhIW9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gISFvcHRpb25zLmV4dGVuZDtcbiAgICB9XG59XG4vLyBUb2tlbml6ZXIgZGF0YSBpcyBzdG9yZWQgYSBiaWcgdWludDE2IGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoXG4vLyBzdGF0ZTpcbi8vXG4vLyAgLSBBIGdyb3VwIGJpdG1hc2ssIGluZGljYXRpbmcgd2hhdCB0b2tlbiBncm91cHMgYXJlIHJlYWNoYWJsZSBmcm9tXG4vLyAgICB0aGlzIHN0YXRlLCBzbyB0aGF0IHBhdGhzIHRoYXQgY2FuIG9ubHkgbGVhZCB0byB0b2tlbnMgbm90IGluXG4vLyAgICBhbnkgb2YgdGhlIGN1cnJlbnQgZ3JvdXBzIGNhbiBiZSBjdXQgb2ZmIGVhcmx5LlxuLy9cbi8vICAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIHRoZSBzdGF0ZSdzIHNlcXVlbmNlIG9mIGFjY2VwdGluZ1xuLy8gICAgdG9rZW5zXG4vL1xuLy8gIC0gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyBmb3IgdGhlIHN0YXRlXG4vL1xuLy8gIC0gVGhlIGFjY2VwdGluZyB0b2tlbnMsIGFzICh0b2tlbiBpZCwgZ3JvdXAgbWFzaykgcGFpcnNcbi8vXG4vLyAgLSBUaGUgb3V0Z29pbmcgZWRnZXMsIGFzIChzdGFydCBjaGFyYWN0ZXIsIGVuZCBjaGFyYWN0ZXIsIHN0YXRlXG4vLyAgICBpbmRleCkgdHJpcGxlcywgd2l0aCBlbmQgY2hhcmFjdGVyIGJlaW5nIGV4Y2x1c2l2ZVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaW50ZXJwcmV0cyB0aGF0IGRhdGEsIHJ1bm5pbmcgdGhyb3VnaCBhIHN0cmVhbSBhc1xuLy8gbG9uZyBhcyBuZXcgc3RhdGVzIHdpdGggdGhlIGEgbWF0Y2hpbmcgZ3JvdXAgbWFzayBjYW4gYmUgcmVhY2hlZCxcbi8vIGFuZCB1cGRhdGluZyBgdG9rZW5gIHdoZW4gaXQgbWF0Y2hlcyBhIHRva2VuLlxuZnVuY3Rpb24gcmVhZFRva2VuKGRhdGEsIGlucHV0LCB0b2tlbiwgc3RhY2ssIGdyb3VwKSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgZGlhbGVjdCA9IHN0YWNrLmN4LnBhcnNlci5kaWFsZWN0O1xuICAgIHNjYW46IGZvciAobGV0IHBvcyA9IHRva2VuLnN0YXJ0OzspIHtcbiAgICAgICAgaWYgKChncm91cE1hc2sgJiBkYXRhW3N0YXRlXSkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgYWNjRW5kID0gZGF0YVtzdGF0ZSArIDFdO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGxlYWQgdG8gYSB0b2tlbiBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICAvLyBBY2NlcHQgdG9rZW5zIGluIHRoaXMgc3RhdGUsIHBvc3NpYmx5IG92ZXJ3cml0aW5nXG4gICAgICAgIC8vIGxvd2VyLXByZWNlZGVuY2UgLyBzaG9ydGVyIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUgKyAzOyBpIDwgYWNjRW5kOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoKGRhdGFbaSArIDFdICYgZ3JvdXBNYXNrKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3QuYWxsb3dzKHRlcm0pICYmXG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi52YWx1ZSA9PSAtMSB8fCB0b2tlbi52YWx1ZSA9PSB0ZXJtIHx8IHN0YWNrLmN4LnBhcnNlci5vdmVycmlkZXModGVybSwgdG9rZW4udmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5hY2NlcHQodGVybSwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmdldChwb3MrKyk7XG4gICAgICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgc3RhdGUncyBlZGdlc1xuICAgICAgICBmb3IgKGxldCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogQmlnVmFsQ29kZSAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gNjU1MzUgLyogQmlnVmFsICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPj0gOTIgLyogR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBHYXAxICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IG5leHQgLSAzMiAvKiBTdGFydCAqLztcbiAgICAgICAgICAgIGlmIChkaWdpdCA+PSA0NiAvKiBCYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0O1xuICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSAqPSA0NiAvKiBCYXNlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheSlcbiAgICAgICAgICAgIGFycmF5W291dCsrXSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBGSVhNRSBmaW5kIHNvbWUgd2F5IHRvIHJlZHVjZSByZWNvdmVyeSB3b3JrIGRvbmUgd2hlbiB0aGUgaW5wdXRcbi8vIGRvZXNuJ3QgbWF0Y2ggdGhlIGdyYW1tYXIgYXQgYWxsLlxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IocG9zKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghKHNpZGUgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHBvcykgOiBjdXJzb3IuY2hpbGRBZnRlcihwb3MpKSlcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPCAwID8gY3Vyc29yLnRvIDw9IHBvcyA6IGN1cnNvci5mcm9tID49IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IGN1cnNvci50byAtIDEgOiBjdXJzb3IuZnJvbSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydCA9PSBwb3MgJiYgc3RhcnQgKyBuZXh0Lmxlbmd0aCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCA9PSBwb3MgJiYgc3RhcnQgPj0gdGhpcy5zYWZlRnJvbSA/IG5leHQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBsZXplclRyZWUuVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbmV4dC5sZW5ndGggPj0gcG9zKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYWNoZWRUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgIH1cbiAgICBjbGVhcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgfVxufVxuY29uc3QgZHVtbXlUb2tlbiA9IG5ldyBUb2tlbjtcbmNsYXNzIFRva2VuQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IGR1bW15VG9rZW47XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IHBhcnNlci50b2tlbml6ZXJzLm1hcChfID0+IG5ldyBDYWNoZWRUb2tlbik7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoc3RhY2ssIGlucHV0KSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5jeCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBUb2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKCgxIDw8IGkpICYgbWFzaykgPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0b2tlbml6ZXIgPSB0b2tlbml6ZXJzW2ldLCB0b2tlbiA9IHRoaXMudG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKG1haW4gJiYgIXRva2VuaXplci5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuY29udGV4dHVhbCB8fCB0b2tlbi5zdGFydCAhPSBzdGFjay5wb3MgfHwgdG9rZW4ubWFzayAhPSBtYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaywgaW5wdXQpO1xuICAgICAgICAgICAgICAgIHRva2VuLm1hc2sgPSBtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgICAgICBtYWluID0gZHVtbXlUb2tlbjtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBzdGFjay5wb3M7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID09IGlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWluLmFjY2VwdChzdGFjay5jeC5wYXJzZXIuZW9mVGVybSwgc3RhY2sucG9zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYWluLmFjY2VwdCgwIC8qIEVyciAqLywgc3RhY2sucG9zICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaywgaW5wdXQpIHtcbiAgICAgICAgdG9rZW4uY2xlYXIoc3RhY2sucG9zKTtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKGlucHV0LCB0b2tlbiwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5jeDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VyLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc3BlY2lhbGl6ZWRbaV0gPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlci5zcGVjaWFsaXplcnNbaV0oaW5wdXQucmVhZCh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID49IDAgJiYgc3RhY2suY3gucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhY2sucG9zID09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4uYWNjZXB0KHN0YWNrLmN4LnBhcnNlci5lb2ZUZXJtLCBzdGFjay5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4uYWNjZXB0KDAgLyogRXJyICovLCBzdGFjay5wb3MgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2suY3gsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSB0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG52YXIgUmVjO1xuKGZ1bmN0aW9uIChSZWMpIHtcbiAgICBSZWNbUmVjW1wiRGlzdGFuY2VcIl0gPSA1XSA9IFwiRGlzdGFuY2VcIjtcbiAgICBSZWNbUmVjW1wiTWF4UmVtYWluaW5nUGVyU3RlcFwiXSA9IDNdID0gXCJNYXhSZW1haW5pbmdQZXJTdGVwXCI7XG4gICAgUmVjW1JlY1tcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCJdID0gMjAwXSA9IFwiTWluQnVmZmVyTGVuZ3RoUHJ1bmVcIjtcbiAgICBSZWNbUmVjW1wiRm9yY2VSZWR1Y2VMaW1pdFwiXSA9IDEwXSA9IFwiRm9yY2VSZWR1Y2VMaW1pdFwiO1xufSkoUmVjIHx8IChSZWMgPSB7fSkpO1xuLy8vIEEgcGFyc2UgY29udGV4dCBjYW4gYmUgdXNlZCBmb3Igc3RlcC1ieS1zdGVwIHBhcnNpbmcuIEFmdGVyXG4vLy8gY3JlYXRpbmcgaXQsIHlvdSByZXBlYXRlZGx5IGNhbGwgYC5hZHZhbmNlKClgIHVudGlsIGl0IHJldHVybnMgYVxuLy8vIHRyZWUgdG8gaW5kaWNhdGUgaXQgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyc2UuXG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgc3RhcnRQb3MsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5zdGFydFBvcyA9IHN0YXJ0UG9zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAvLyBUaGUgcG9zaXRpb24gdG8gd2hpY2ggdGhlIHBhcnNlIGhhcyBhZHZhbmNlZC5cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0O1xuICAgICAgICB0aGlzLm5lc3RlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubmVzdEVuZCA9IDA7XG4gICAgICAgIHRoaXMubmVzdFdyYXAgPSBudWxsO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlcik7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIHRoaXMuc3RhcnRQb3MpXTtcbiAgICAgICAgbGV0IGZyYWdtZW50cyA9IGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5mcmFnbWVudHM7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzICYmIGZyYWdtZW50cy5sZW5ndGggPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzKSA6IG51bGw7XG4gICAgfVxuICAgIC8vIE1vdmUgdGhlIHBhcnNlciBmb3J3YXJkLiBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgcGFyc2Ugc3RhY2tzIGF0XG4gICAgLy8gYHRoaXMucG9zYCBhbmQgdHJ5IHRvIGFkdmFuY2UgdGhlbSB0byBhIGZ1cnRoZXIgcG9zaXRpb24uIElmIG5vXG4gICAgLy8gc3RhY2sgZm9yIHN1Y2ggYSBwb3NpdGlvbiBpcyBmb3VuZCwgaXQnbGwgc3RhcnQgZXJyb3ItcmVjb3ZlcnkuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBwYXJzZSBpcyBmaW5pc2hlZCwgdGhpcyB3aWxsIHJldHVybiBhIHN5bnRheCB0cmVlLiBXaGVuXG4gICAgLy8gbm90LCBpdCByZXR1cm5zIGBudWxsYC5cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5uZXN0ZWQpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm5lc3RlZC5hZHZhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubmVzdGVkLnBvcztcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaE5lc3RlZCh0aGlzLnN0YWNrc1swXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhY2tzID0gdGhpcy5zdGFja3MsIHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIGxldCBtYXliZU5lc3Q7XG4gICAgICAgIC8vIEtlZXAgYWR2YW5jaW5nIGFueSBzdGFja3MgYXQgYHBvc2AgdW50aWwgdGhleSBlaXRoZXIgbW92ZVxuICAgICAgICAvLyBmb3J3YXJkIG9yIGNhbid0IGJlIGFkdmFuY2VkLiBHYXRoZXIgc3RhY2tzIHRoYXQgY2FuJ3QgYmVcbiAgICAgICAgLy8gYWR2YW5jZWQgZnVydGhlciBpbiBgc3RvcHBlZGAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIG5lc3Q7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5lc3QgPSB0aGlzLmNoZWNrTmVzdChzdGFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXliZU5lc3QgfHwgbWF5YmVOZXN0LnN0YWNrLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSBuZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLm1haW5Ub2tlbjtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZU5lc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXN0ZWQobWF5YmVOZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArIHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBEaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBNYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gMjAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovICYmIG90aGVyLmJ1ZmZlci5sZW5ndGggPiAyMDAgLyogTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLnBvcylcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gc3RhY2ssIG9yIG51bGwgaWYgdGhlXG4gICAgLy8gc3RhY2sgY2FuJ3QgYWR2YW5jZSBub3JtYWxseS4gV2hlbiBgc3BsaXRgIGFuZCBgc3RhY2tzYCBhcmVcbiAgICAvLyBnaXZlbiwgc3RhY2tzIHNwbGl0IG9mZiBieSBhbWJpZ3VvdXMgb3BlcmF0aW9ucyB3aWxsIGJlIHB1c2hlZCB0b1xuICAgIC8vIGBzcGxpdGAsIG9yIGFkZGVkIHRvIGBzdGFja3NgIGlmIHRoZXkgbW92ZSBgcG9zYCBmb3J3YXJkLlxuICAgIGFkdmFuY2VTdGFjayhzdGFjaywgc3RhY2tzLCBzcGxpdCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGFjay5wb3MsIHsgaW5wdXQsIHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjYWNoZWQgPSB0aGlzLmZyYWdtZW50cy5ub2RlQXQoc3RhcnQpOyBjYWNoZWQ7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tjYWNoZWQudHlwZS5pZF0gPT0gY2FjaGVkLnR5cGUgPyBwYXJzZXIuZ2V0R290byhzdGFjay5zdGF0ZSwgY2FjaGVkLnR5cGUuaWQpIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID4gLTEgJiYgY2FjaGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51c2VOb2RlKGNhY2hlZCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJldXNlIG9mICR7cGFyc2VyLmdldE5hbWUoY2FjaGVkLnR5cGUuaWQpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGNhY2hlZCBpbnN0YW5jZW9mIGxlemVyVHJlZS5UcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBsZXplclRyZWUuVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25zID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhzdGFjaywgaW5wdXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5lc3QgPSB0aGlzLmNoZWNrTmVzdChzdGFjayk7XG4gICAgICAgICAgICBpZiAobmVzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmVzdDtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgbWF5YmVOZXN0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTmVzdCA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTmVzdCA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQubGVuZ3RoID4gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRW5kID09IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBzdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgICAgICBpZiAobWF5YmVOZXN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLnN0YWNrcylcbiAgICAgICAgICAgICAgICBpZiAocy5zY29yZSA+IG1heWJlTmVzdC5zdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZU5lc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlTmVzdClcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXN0ZWQobWF5YmVOZXN0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvcmNlRmluaXNoKCkge1xuICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLnN0YWNrc1swXS5zcGxpdCgpO1xuICAgICAgICBpZiAodGhpcy5uZXN0ZWQpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaE5lc3RlZChzdGFjaywgdGhpcy5uZXN0ZWQuZm9yY2VGaW5pc2goKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKHN0YWNrLmZvcmNlQWxsKCkpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrLCBwb3MgPSBzdGFjay5wb3MpIHtcbiAgICAgICAgcmV0dXJuIGxlemVyVHJlZS5UcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydFBvcyxcbiAgICAgICAgICAgIGxlbmd0aDogcG9zIC0gdGhpcy5zdGFydFBvcyxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIGNoZWNrTmVzdChzdGFjaykge1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFyc2VyLmZpbmROZXN0ZWQoc3RhY2suc3RhdGUpO1xuICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHNwZWMgPSBpbmZvLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgc3BlYyA9IHNwZWModGhpcy5pbnB1dCwgc3RhY2spO1xuICAgICAgICByZXR1cm4gc3BlYyA/IHsgc3RhY2ssIGluZm8sIHNwZWMgfSA6IG51bGw7XG4gICAgfVxuICAgIHN0YXJ0TmVzdGVkKG5lc3QpIHtcbiAgICAgICAgbGV0IHsgc3RhY2ssIGluZm8sIHNwZWMgfSA9IG5lc3Q7XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW3N0YWNrXTtcbiAgICAgICAgdGhpcy5uZXN0RW5kID0gdGhpcy5zY2FuRm9yTmVzdEVuZChzdGFjaywgaW5mby5lbmQsIHNwZWMuZmlsdGVyRW5kKTtcbiAgICAgICAgdGhpcy5uZXN0V3JhcCA9IHR5cGVvZiBzcGVjLndyYXBUeXBlID09IFwibnVtYmVyXCIgPyB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW3NwZWMud3JhcFR5cGVdIDogc3BlYy53cmFwVHlwZSB8fCBudWxsO1xuICAgICAgICBpZiAoc3BlYy5zdGFydFBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZCA9IHNwZWMuc3RhcnRQYXJzZSh0aGlzLmlucHV0LmNsaXAodGhpcy5uZXN0RW5kKSwgc3RhY2sucG9zLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hOZXN0ZWQoc3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW5Gb3JOZXN0RW5kKHN0YWNrLCBlbmRUb2tlbiwgZmlsdGVyKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN0YWNrLnBvczsgcG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgICBkdW1teVRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgZHVtbXlUb2tlbi52YWx1ZSA9IC0xO1xuICAgICAgICAgICAgZW5kVG9rZW4udG9rZW4odGhpcy5pbnB1dCwgZHVtbXlUb2tlbiwgc3RhY2spO1xuICAgICAgICAgICAgaWYgKGR1bW15VG9rZW4udmFsdWUgPiAtMSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIodGhpcy5pbnB1dC5yZWFkKHBvcywgZHVtbXlUb2tlbi5lbmQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmlzaE5lc3RlZChzdGFjaywgdHJlZSkge1xuICAgICAgICBpZiAodGhpcy5uZXN0V3JhcClcbiAgICAgICAgICAgIHRyZWUgPSBuZXcgbGV6ZXJUcmVlLlRyZWUodGhpcy5uZXN0V3JhcCwgdHJlZSA/IFt0cmVlXSA6IFtdLCB0cmVlID8gWzBdIDogW10sIHRoaXMubmVzdEVuZCAtIHN0YWNrLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKCF0cmVlKVxuICAgICAgICAgICAgdHJlZSA9IG5ldyBsZXplclRyZWUuVHJlZShsZXplclRyZWUuTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0aGlzLm5lc3RFbmQgLSBzdGFjay5wb3MpO1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFyc2VyLmZpbmROZXN0ZWQoc3RhY2suc3RhdGUpO1xuICAgICAgICBzdGFjay51c2VOb2RlKHRyZWUsIHRoaXMucGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGluZm8ucGxhY2Vob2xkZXIsIHRydWUpKTtcbiAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHVubmVzdClgKTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IGxlemVyVHJlZS5EZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dFN0YXRlQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5jYWNoZWREaWFsZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxMyAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezEzIC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheShzcGVjLnNwZWNpYWxpemVkID8gc3BlYy5zcGVjaWFsaXplZC5sZW5ndGggOiAwKTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMuc3BlY2lhbGl6ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS50ZXJtO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzW2ldID0gc3BlYy5zcGVjaWFsaXplZFtpXS5nZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICBsZXQgdG9wVGVybXMgPSBPYmplY3Qua2V5cyhzcGVjLnRvcFJ1bGVzKS5tYXAociA9PiBzcGVjLnRvcFJ1bGVzW3JdWzFdKTtcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IGxlemVyVHJlZS5Ob2RlU2V0KG5vZGVOYW1lcy5tYXAoKG5hbWUsIGkpID0+IGxlemVyVHJlZS5Ob2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMubmVzdGVkID0gKHNwZWMubmVzdGVkIHx8IFtdKS5tYXAoKFtuYW1lLCB2YWx1ZSwgZW5kVG9rZW4sIHBsYWNlaG9sZGVyXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWUsIGVuZDogbmV3IFRva2VuR3JvdXAoZGVjb2RlQXJyYXkoZW5kVG9rZW4pLCAwKSwgcGxhY2Vob2xkZXIgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnN0YXRlcy5sZW5ndGggLyA2IC8qIFNpemUgKi87IGkgPCBsOyBpKyspXG4gICAgICAgICAgICB0aGlzLm5leHRTdGF0ZUNhY2hlW2ldID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgLy8vIFBhcnNlIGEgZ2l2ZW4gc3RyaW5nIG9yIHN0cmVhbS5cbiAgICBwYXJzZShpbnB1dCwgc3RhcnRQb3MgPSAwLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBsZXplclRyZWUuc3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICBsZXQgY3ggPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIHN0YXJ0UG9zLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBjeC5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gU3RhcnQgYW4gaW5jcmVtZW50YWwgcGFyc2UuXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgc3RhcnRQb3MgPSAwLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBsZXplclRyZWUuc3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBzdGFydFBvcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBnb3RvIHRhYmxlIGVudHJ5IEBpbnRlcm5hbFxuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgaGFzQWN0aW9uKHN0YXRlLCB0ZXJtaW5hbCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgc2V0ID0gMDsgc2V0IDwgMjsgc2V0KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGRhdGFbaSA9IHBhaXIoZGF0YSwgaSArIDIpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVtpICsgMV0gPT0gMiAvKiBPdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBFcnIgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBTaXplICovKSArIHNsb3RdO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogRmxhZ3MgKi8pICYgZmxhZykgPiAwO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluZE5lc3RlZChzdGF0ZSkge1xuICAgICAgICBsZXQgZmxhZ3MgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBGbGFncyAqLyk7XG4gICAgICAgIHJldHVybiBmbGFncyAmIDQgLyogU3RhcnROZXN0ICovID8gdGhpcy5uZXN0ZWRbZmxhZ3MgPj4gMTAgLyogTmVzdFNoaWZ0ICovXSA6IG51bGw7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24gPT0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IHBhaXIodGhpcy5kYXRhLCBpICsgMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICAvLy8gZ290byBqdW1wcy4gQGludGVybmFsXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5uZXh0U3RhdGVDYWNoZVtzdGF0ZV07XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIE5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtpICsgMl0gJiAoNjU1MzYgLyogUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDAgJiYgcmVzdWx0LmluZGV4T2YodGhpcy5kYXRhW2kgKyAxXSkgPCAwKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bywgbWF4ID0gdGFibGVbMF07XG4gICAgICAgIGZvciAobGV0IHRlcm0gPSAwOyB0ZXJtIDwgbWF4OyB0ZXJtKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwVGFnID0gdGFibGVbcG9zKytdLCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSAmJiByZXN1bHQuaW5kZXhPZih0YXJnZXQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwVGFnICYgMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFN0YXRlQ2FjaGVbc3RhdGVdID0gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgb3ZlcnJpZGVzKHRva2VuLCBwcmV2KSB7XG4gICAgICAgIGxldCBpUHJldiA9IGZpbmRPZmZzZXQodGhpcy5kYXRhLCB0aGlzLnRva2VuUHJlY1RhYmxlLCBwcmV2KTtcbiAgICAgICAgcmV0dXJuIGlQcmV2IDwgMCB8fCBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgdG9rZW4pIDwgaVByZXY7XG4gICAgfVxuICAgIC8vLyBDb25maWd1cmUgdGhlIHBhcnNlci4gUmV0dXJucyBhIG5ldyBwYXJzZXIgaW5zdGFuY2UgdGhhdCBoYXMgdGhlXG4gICAgLy8vIGdpdmVuIHNldHRpbmdzIG1vZGlmaWVkLiBTZXR0aW5ncyBub3QgcHJvdmlkZWQgaW4gYGNvbmZpZ2AgYXJlXG4gICAgLy8vIGtlcHQgZnJvbSB0aGUgb3JpZ2luYWwgcGFyc2VyLlxuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgLy8gSGlkZW91cyByZWZsZWN0aW9uLWJhc2VkIGtsdWRnZSB0byBtYWtlIGl0IGVhc3kgdG8gY3JlYXRlIGFcbiAgICAgICAgLy8gc2xpZ2h0bHkgbW9kaWZpZWQgY29weSBvZiBhIHBhcnNlci5cbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLm5lc3RlZClcbiAgICAgICAgICAgIGNvcHkubmVzdGVkID0gdGhpcy5uZXN0ZWQubWFwKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLm5lc3RlZCwgb2JqLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IG9iai5uYW1lLCB2YWx1ZTogY29uZmlnLm5lc3RlZFtvYmoubmFtZV0sIGVuZDogb2JqLmVuZCwgcGxhY2Vob2xkZXI6IG9iai5wbGFjZWhvbGRlciB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuc3RyaWN0ICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LnN0cmljdCA9IGNvbmZpZy5zdHJpY3Q7XG4gICAgICAgIGlmIChjb25maWcuYnVmZmVyTGVuZ3RoICE9IG51bGwpXG4gICAgICAgICAgICBjb3B5LmJ1ZmZlckxlbmd0aCA9IGNvbmZpZy5idWZmZXJMZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIC8vLyB3b3JrIGZvciBhbGwgdGVybXMgd2hlbiB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgd2l0aCB0aGVcbiAgICAvLy8gYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIC8vLyBzdG9yZWQuXG4gICAgZ2V0TmFtZSh0ZXJtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1OYW1lcyA/IHRoaXMudGVybU5hbWVzW3Rlcm1dIDogU3RyaW5nKHRlcm0gPD0gdGhpcy5tYXhOb2RlICYmIHRoaXMubm9kZVNldC50eXBlc1t0ZXJtXS5uYW1lIHx8IHRlcm0pO1xuICAgIH1cbiAgICAvLy8gVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICAvLy8gdHlwZXMuIEBpbnRlcm5hbFxuICAgIGdldCBlb2ZUZXJtKCkgeyByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTsgfVxuICAgIC8vLyBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGdyYW1tYXIgaGFzIGFueSBuZXN0ZWQgZ3JhbW1hcnMuXG4gICAgZ2V0IGhhc05lc3RlZCgpIHsgcmV0dXJuIHRoaXMubmVzdGVkLmxlbmd0aCA+IDA7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZERpYWxlY3QgJiYgdGhpcy5jYWNoZWREaWFsZWN0LnNvdXJjZSA9PSBkaWFsZWN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRGlhbGVjdDtcbiAgICAgICAgbGV0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGlhbGVjdHMpLCBmbGFncyA9IHZhbHVlcy5tYXAoKCkgPT4gZmFsc2UpO1xuICAgICAgICBpZiAoZGlhbGVjdClcbiAgICAgICAgICAgIGZvciAobGV0IHBhcnQgb2YgZGlhbGVjdC5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB2YWx1ZXMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGlhbGVjdHNbdmFsdWVzW2ldXSwgaWQ7IChpZCA9IHRoaXMuZGF0YVtqKytdKSAhPSA2NTUzNSAvKiBFbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWREaWFsZWN0ID0gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLy8vICh1c2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IpIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGlmIChzdGFjay5wb3MgPT0gc3RhY2suY3guaW5wdXQubGVuZ3RoICYmXG4gICAgICAgICAgICBzdGFjay5jeC5wYXJzZXIuc3RhdGVGbGFnKHN0YWNrLnN0YXRlLCAyIC8qIEFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cblxuZXhwb3J0cy5Ob2RlUHJvcCA9IGxlemVyVHJlZS5Ob2RlUHJvcDtcbmV4cG9ydHMuTm9kZVNldCA9IGxlemVyVHJlZS5Ob2RlU2V0O1xuZXhwb3J0cy5Ob2RlVHlwZSA9IGxlemVyVHJlZS5Ob2RlVHlwZTtcbmV4cG9ydHMuVHJlZSA9IGxlemVyVHJlZS5UcmVlO1xuZXhwb3J0cy5UcmVlQ3Vyc29yID0gbGV6ZXJUcmVlLlRyZWVDdXJzb3I7XG5leHBvcnRzLkV4dGVybmFsVG9rZW5pemVyID0gRXh0ZXJuYWxUb2tlbml6ZXI7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbmV4cG9ydHMuU3RhY2sgPSBTdGFjaztcbmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb3VudERlZkRlY2xTdG10cyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNvdW50RGVmRGVjbFN0bXRzKHN0bXRzKSB7XG4gICAgdmFyIGYgPSBmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgICAgIHZhciBiID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoeC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVmaW5lXCI6IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhc3NpZ25cIjogcmV0dXJuICEoeC50eXBlXyA9PSBcIlwiKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiAoYWNjWzBdICYmIGIpID8gW3RydWUsIGFjY1sxXSArIDFdIDogW2ZhbHNlLCBhY2NbMV1dO1xuICAgIH07XG4gICAgcmV0dXJuIHN0bXRzLnJlZHVjZShmLCBbdHJ1ZSwgMF0pWzFdO1xufVxuZXhwb3J0cy5jb3VudERlZkRlY2xTdG10cyA9IGNvdW50RGVmRGVjbFN0bXRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBpbGUgPSBleHBvcnRzLm5lc3RlZFJldHMgPSB2b2lkIDA7XG52YXIgYXN0XzEgPSByZXF1aXJlKFwiLi9hc3RcIik7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG52YXIgdHlwZWNoZWNrZXJfMSA9IHJlcXVpcmUoXCIuL3R5cGVjaGVja2VyXCIpO1xuZnVuY3Rpb24gZGVjbFRtcFZhcihuLCBtKSB7XG4gICAgaWYgKG0gPiBuKSB7XG4gICAgICAgIHJldHVybiBbXCIobG9jYWwgJF9fX1RNUFwiICsgbiArIFwiIGkzMilcIl0uY29uY2F0KGRlY2xUbXBWYXIobiArIDEsIG0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXN0ZWRSZXRzKHN0bXQpIHtcbiAgICBzd2l0Y2ggKHN0bXQudGFnKSB7XG4gICAgICAgIGNhc2UgXCJpZlwiOlxuICAgICAgICAgICAgcmV0dXJuICFzdG10LmJvZHkxLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiAhbmVzdGVkUmV0cyhzKTsgfSlcbiAgICAgICAgICAgICAgICB8fCAhc3RtdC5ib2R5Mi5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gIW5lc3RlZFJldHMocyk7IH0pXG4gICAgICAgICAgICAgICAgfHwgIXN0bXQuYm9keTEuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudGFnICE9IFwicmV0dXJuXCI7IH0pXG4gICAgICAgICAgICAgICAgfHwgIXN0bXQuYm9keTIuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudGFnICE9IFwicmV0dXJuXCI7IH0pO1xuICAgICAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgICAgICAgIHJldHVybiAhc3RtdC5ib2R5LmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiAhbmVzdGVkUmV0cyhzKTsgfSlcbiAgICAgICAgICAgICAgICB8fCAhc3RtdC5ib2R5LmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRhZyAhPSBcInJldHVyblwiOyB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLm5lc3RlZFJldHMgPSBuZXN0ZWRSZXRzO1xudmFyIHdhdEJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gd2F0QnVpbGRlcigpIHtcbiAgICAgICAgdGhpcy5kZWZzID0gW107XG4gICAgICAgIHRoaXMuZGVjbCA9IFtdO1xuICAgICAgICB0aGlzLmJvZHkgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSAwO1xuICAgICAgICB0aGlzLmltcGxSZXR1cm4gPSBmYWxzZTtcbiAgICB9XG4gICAgd2F0QnVpbGRlci5wcm90b3R5cGUuYWRkSW5zdHIgPSBmdW5jdGlvbiAoaW5zdHIpIHtcbiAgICAgICAgdGhpcy5ib2R5ID0gdGhpcy5ib2R5LmNvbmNhdChpbnN0cik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgd2F0QnVpbGRlci5wcm90b3R5cGUuYWRkRGVjbCA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgIHRoaXMuZGVjbCA9IHRoaXMuZGVjbC5jb25jYXQoZGVjbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgd2F0QnVpbGRlci5wcm90b3R5cGUuc2V0U3RhY2tTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSBzaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHdhdEJ1aWxkZXIucHJvdG90eXBlLmFkZEV4cHIgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICBzd2l0Y2ggKGV4cHIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRJbnN0cihbXCIobG9jYWwuZ2V0ICRcIiArIGV4cHIubmFtZSArIFwiKVwiXSk7XG4gICAgICAgICAgICBjYXNlIFwibGl0ZXJhbFwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSBleHByLnZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobGl0ZXJhbC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gKGxpdGVyYWwudmFsdWUpID8gW1wiKGkzMi5jb25zdCAxKVwiXSA6IFtcIihpMzIuY29uc3QgMClcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRJbnN0cihzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5zdHIoW1wiKGkzMi5jb25zdCBcIiArIGxpdGVyYWwudmFsdWUgKyBcIilcIl0pO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uZSBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2FsbChleHByKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmlvcFwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByLnVuaW9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm90XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIihpMzIuY29uc3QgMSlcIiwgXCIoaTMyLnhvcilcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIihpMzIuY29uc3QgLTEpXCIsIFwiKGkzMi5tdWwpXCJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRFeHByKGV4cHIuYXJnKS5hZGRJbnN0cihpbnN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYmlub3BcIjoge1xuICAgICAgICAgICAgICAgIHZhciBiaW5vcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci5iaW5vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIitcIjogcmV0dXJuIFwiYWRkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gXCJzdWJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6IHJldHVybiBcIm11bFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi8vXCI6IHJldHVybiBcImRpdl9zXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJVwiOiByZXR1cm4gXCJyZW1fc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj09XCI6IHJldHVybiBcImVxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIT1cIjogcmV0dXJuIFwibmVxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPD1cIjogcmV0dXJuIFwibGVfc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj49XCI6IHJldHVybiBcImdlX3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiBcImx0X3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI+XCI6IHJldHVybiBcImd0X3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpc1wiOiB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV4cHIoZXhwci5hcmcxKVxuICAgICAgICAgICAgICAgICAgICAuYWRkRXhwcihleHByLmFyZzIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRJbnN0cihbXCIoaTMyLlwiICsgYmlub3AgKyBcIilcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInBhcmVuc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV4cHIoZXhwci5leHByKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2F0QnVpbGRlci5wcm90b3R5cGUuYWRkTWF4SW5saW5lID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZzEpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmFkZEV4cHIoYXJnMSkpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmFkZEluc3RyKFtcIihsb2NhbC5zZXQgJF9fX1RNUDApXCJdKSk7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmFkZEV4cHIoYXJnMSlcbiAgICAgICAgICAgIC5hZGRJbnN0cihbXCIobG9jYWwuc2V0ICRfX19UTVAwKVwiXSlcbiAgICAgICAgICAgIC5hZGRFeHByKGFyZzIpXG4gICAgICAgICAgICAuYWRkSW5zdHIoW1wiKGxvY2FsLnNldCAkX19fVE1QMSlcIixcbiAgICAgICAgICAgIFwiKGxvY2FsLmdldCAkX19fVE1QMClcIixcbiAgICAgICAgICAgIFwiKGxvY2FsLmdldCAkX19fVE1QMSlcIixcbiAgICAgICAgICAgIFwiKGxvY2FsLmdldCAkX19fVE1QMClcIixcbiAgICAgICAgICAgIFwiKGxvY2FsLmdldCAkX19fVE1QMSlcIixcbiAgICAgICAgICAgIFwiKGkzMi5ndF9zKVwiLFxuICAgICAgICAgICAgXCIoc2VsZWN0KVwiXSk7XG4gICAgICAgIHJldHVybiB0bXAuYWRkRGVjbChkZWNsVG1wVmFyKHRtcC5zdGFja1NpemUsIDIpKVxuICAgICAgICAgICAgLnNldFN0YWNrU2l6ZShNYXRoLm1heCgyLCB0bXAuc3RhY2tTaXplKSk7XG4gICAgfTtcbiAgICB3YXRCdWlsZGVyLnByb3RvdHlwZS5hZGRNaW5JbmxpbmUgPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5hZGRFeHByKGFyZzEpXG4gICAgICAgICAgICAuYWRkSW5zdHIoW1wiKGxvY2FsLnNldCAkX19fVE1QMClcIl0pXG4gICAgICAgICAgICAuYWRkRXhwcihhcmcyKVxuICAgICAgICAgICAgLmFkZEluc3RyKFtcIihsb2NhbC5zZXQgJF9fX1RNUDEpXCIsXG4gICAgICAgICAgICBcIihsb2NhbC5nZXQgJF9fX1RNUDApXCIsXG4gICAgICAgICAgICBcIihsb2NhbC5nZXQgJF9fX1RNUDEpXCIsXG4gICAgICAgICAgICBcIihsb2NhbC5nZXQgJF9fX1RNUDApXCIsXG4gICAgICAgICAgICBcIihsb2NhbC5nZXQgJF9fX1RNUDEpXCIsXG4gICAgICAgICAgICBcIihpMzIubHRfcylcIixcbiAgICAgICAgICAgIFwiKHNlbGVjdClcIl0pO1xuICAgICAgICByZXR1cm4gdG1wLmFkZERlY2woZGVjbFRtcFZhcih0bXAuc3RhY2tTaXplLCAyKSlcbiAgICAgICAgICAgIC5zZXRTdGFja1NpemUoTWF0aC5tYXgoMiwgdG1wLnN0YWNrU2l6ZSkpO1xuICAgIH07XG4gICAgd2F0QnVpbGRlci5wcm90b3R5cGUuYWRkQWJzSW5saW5lID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5hZGRFeHByKGFyZylcbiAgICAgICAgICAgIC5hZGRJbnN0cihbXCIobG9jYWwuc2V0ICRfX19UTVAwKVwiLFxuICAgICAgICAgICAgXCIobG9jYWwuZ2V0ICRfX19UTVAwKVwiLFxuICAgICAgICAgICAgXCIobG9jYWwuZ2V0ICRfX19UTVAwKVwiLFxuICAgICAgICAgICAgXCIoaTMyLmNvbnN0IC0xKVwiLFxuICAgICAgICAgICAgXCIoaTMyLm11bClcIixcbiAgICAgICAgICAgIFwiKGxvY2FsLmdldCAkX19fVE1QMClcIixcbiAgICAgICAgICAgIFwiKGkzMi5jb25zdCAwKVwiLFxuICAgICAgICAgICAgXCIoaTMyLmd0X3MpXCIsXG4gICAgICAgICAgICBcIihzZWxlY3QpXCJdKTtcbiAgICAgICAgcmV0dXJuIHRtcC5hZGREZWNsKGRlY2xUbXBWYXIodG1wLnN0YWNrU2l6ZSwgMSkpXG4gICAgICAgICAgICAuc2V0U3RhY2tTaXplKE1hdGgubWF4KDEsIHRtcC5zdGFja1NpemUpKTtcbiAgICB9O1xuICAgIHdhdEJ1aWxkZXIucHJvdG90eXBlLmFkZENhbGwgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICBpZiAoZXhwci50YWcgIT0gXCJjYWxsXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHByLnRhZyArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uIGNhbGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChleHByLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjogcmV0dXJuIHRoaXMuYWRkTWF4SW5saW5lKGV4cHIuYXJndW1lbnRzWzBdLCBleHByLmFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICBjYXNlIFwibWluXCI6IHJldHVybiB0aGlzLmFkZE1pbklubGluZShleHByLmFyZ3VtZW50c1swXSwgZXhwci5hcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgY2FzZSBcImFic1wiOiByZXR1cm4gdGhpcy5hZGRBYnNJbmxpbmUoZXhwci5hcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgY2FzZSBcInByaW50XCI6IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYXJndW1lbnRzWzBdLnR5cGVfKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRcIjogcmV0dXJuIHRoaXMuYWRkRXhwcihleHByLmFyZ3VtZW50c1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRJbnN0cihbXCIoY2FsbCAkcHJpbnRJMzIpXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIHRoaXMuYWRkRXhwcihleHByLmFyZ3VtZW50c1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRJbnN0cihbXCIoY2FsbCAkcHJpbnRCb29sKVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6IHJldHVybiB0aGlzLmFkZEluc3RyKFtcIihjYWxsICRwcmludE5vbmUpXCJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBleHByLmFyZ3VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZSkgeyByZXR1cm4gYWNjLmFkZEV4cHIoZSk7IH0sIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRJbnN0cihbXCIoY2FsbCAkXCIgKyBleHByLm5hbWUgKyBcIilcIl0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBGSVhNRTogYWRkIHN1cHBvcnQgZm9yIG5lc3RlZCBmdW5jdGlvbnNcbiAgICB3YXRCdWlsZGVyLnByb3RvdHlwZS5hZGRGdW5jID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgaWYgKHN0bXQudGFnICE9IFwiZGVmaW5lXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIGVycm9yLiBDaGVjayBjb2RlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBudW1iZXIgb2YgZGVmaW5lIHN0YXRlbWVudHNcbiAgICAgICAgdmFyIG4gPSBhc3RfMS5jb3VudERlZkRlY2xTdG10cyhzdG10LmJvZHkpO1xuICAgICAgICB2YXIgZGVmU3RtdHMgPSBzdG10LmJvZHkuc2xpY2UoMCwgbik7XG4gICAgICAgIHZhciByZXN0ID0gc3RtdC5ib2R5LnNsaWNlKG4pO1xuICAgICAgICB2YXIgaW91dCA9IGRlZlN0bXRzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRhZyA9PSBcImFzc2lnblwiOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzKSB7XG4gICAgICAgICAgICBpZiAocy50YWcgIT0gXCJhc3NpZ25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIGVycm9yLiBDaGVjayBjb2RlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2MuYWRkU3RtdChzKVxuICAgICAgICAgICAgICAgIC5hZGREZWNsKFtcIihsb2NhbCAkXCIgKyBzLm5hbWUgKyBcIiBpMzIpXCJdKTtcbiAgICAgICAgfSwgbmV3IHdhdEJ1aWxkZXIpO1xuICAgICAgICAvLyBkaXN0YW5jZXMgYmV0d2VlbiBlYXJseSByZXR1cm4gc3RhdGVtZW50c1xuICAgICAgICB2YXIgZHMgPSByZXN0Lm1hcChmdW5jdGlvbiAoaywgaSkgeyByZXR1cm4gW2ksIGtdOyB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gbmVzdGVkUmV0cyh0WzFdKTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdCkge1xuICAgICAgICAgICAgdmFyIGFyciA9IGFjY1swXS5jb25jYXQoW3RbMF0gLSBhY2NbMV1dKTtcbiAgICAgICAgICAgIHJldHVybiBbYXJyLCB0WzBdXTtcbiAgICAgICAgfSwgW1tdLCAwXSlbMF07XG4gICAgICAgIHZhciBlYXJseVJldCA9IGZ1bmN0aW9uIChjb2RlLCBkaXN0cykge1xuICAgICAgICAgICAgdmFyIG4gPSBkaXN0cy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGN1cnJTbGljZSA9IGNvZGUuc2xpY2UoMCwgbiArIDEpO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IGNvZGUuc2xpY2UobiArIDEpO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmRlci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyU2xpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBcImlmXCIsXG4gICAgICAgICAgICAgICAgICAgIHByZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogXCJiaW5vcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmlub3A6IFwiPT1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZzE6IHsgdGFnOiBcImlkXCIsIG5hbWU6IFwiX19fRUFSTFlfUkVUXCIsIHR5cGVfOiBcImJvb2xcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnMjogeyB0YWc6IFwibGl0ZXJhbFwiLCB2YWx1ZTogeyB0YWc6IFwiYm9vbFwiLCB2YWx1ZTogZmFsc2UgfSwgdHlwZV86IFwiYm9vbFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlXzogXCJib29sXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTE6IChkaXN0cy5sZW5ndGggPiAwKSA/IGVhcmx5UmV0KHJlbWFpbmRlciwgZGlzdHMpIDogcmVtYWluZGVyLFxuICAgICAgICAgICAgICAgICAgICBib2R5MjogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyU2xpY2UuY29uY2F0KFtzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYXNSZXQgPSBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuICFyLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiAhbmVzdGVkUmV0cyhzKTsgfSkgfHwgcltyLmxlbmd0aCAtIDFdLnRhZyA9PSBcInJldHVyblwiO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaW91dDIgPSBpb3V0LmFkZERlY2woaGFzUmV0KHJlc3QpID8gW1wiKGxvY2FsICRfX19SRVRfVkFMIGkzMilcIixcbiAgICAgICAgICAgIFwiKGxvY2FsICRfX19FQVJMWV9SRVQgaTMyKVwiLFxuICAgICAgICAgICAgXCIoaTMyLmNvbnN0IDApXCIsXG4gICAgICAgICAgICBcIihsb2NhbC5zZXQgJF9fX0VBUkxZX1JFVClcIl0gOiBbXSlcbiAgICAgICAgICAgIC5hZGRTdG10cygoZHMubGVuZ3RoID4gMCkgPyBlYXJseVJldChyZXN0LCBkcykgOiByZXN0KVxuICAgICAgICAgICAgLmFkZEluc3RyKGhhc1JldChyZXN0KSA/IFtcIihsb2NhbC5nZXQgJF9fX1JFVF9WQUwpXCJdIDogW10pO1xuICAgICAgICBpb3V0Mi5ib2R5W2lvdXQyLmJvZHkubGVuZ3RoIC0gMV0gKz0gXCIpXCI7XG4gICAgICAgIC8vIGlmIGFueSBzdGF0ZW1lbnQgY29udGFpbnMgcmV0dXJuIHN0YXRlbWVudHNcbiAgICAgICAgdmFyIGlucHV0T3V0cHV0ID0gc3RtdC5wYXJhbWV0ZXJzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBcIihwYXJhbSAkXCIgKyBwLm5hbWUgKyBcIiBpMzIpXCI7IH0pXG4gICAgICAgICAgICAuY29uY2F0KGhhc1JldChyZXN0KSA/IFtcIiAocmVzdWx0IGkzMilcIl0gOiBbXSlcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICAgICAgdGhpcy5kZWZzID0gKFtcIihmdW5jICRcIiArIHN0bXQubmFtZSArIFwiIFwiICsgaW5wdXRPdXRwdXRdKS5jb25jYXQoaW91dDIuZGVjbC5jb25jYXQoaW91dDIuYm9keSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHdhdEJ1aWxkZXIucHJvdG90eXBlLmFkZFN0bXRzID0gZnVuY3Rpb24gKHN0bXRzKSB7XG4gICAgICAgIGlmIChzdG10cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFzdFN0bXQgPSBzdG10c1tzdG10cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0U3RtdC50YWcgPT0gXCJleHByXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFN0bXQuZXhwci50eXBlXyAhPSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcGxSZXR1cm4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG10cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcykgeyByZXR1cm4gYWNjLmFkZFN0bXQocyk7IH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3YXRCdWlsZGVyLnByb3RvdHlwZS5hZGRTdG10ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgc3dpdGNoIChzdG10LnRhZykge1xuICAgICAgICAgICAgY2FzZSBcImRlZmluZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEZ1bmMoc3RtdCk7XG4gICAgICAgICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2VlIGlmIHlvdSBjYW4gb3B0aW1pemUgYXdheSB0aGUgbGFzdCB0d28gaW5zdHJ1Y3Rpb25zIHdoZW4gdGhlcmVcbiAgICAgICAgICAgICAgICAvLyBpcyBubyBicmFuY2hpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRFeHByKHN0bXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRJbnN0cihbXCIobG9jYWwuc2V0ICRfX19SRVRfVkFMKVwiLFxuICAgICAgICAgICAgICAgICAgICBcIihpMzIuY29uc3QgMSlcIixcbiAgICAgICAgICAgICAgICAgICAgXCIobG9jYWwuc2V0ICRfX19FQVJMWV9SRVQpXCJdKTtcbiAgICAgICAgICAgIGNhc2UgXCJhc3NpZ25cIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV4cHIoc3RtdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZEluc3RyKFtcIihsb2NhbC5zZXQgJFwiICsgc3RtdC5uYW1lICsgXCIpXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJleHByXCI6XG4gICAgICAgICAgICAgICAgLy8gdGhlIHR5cGVjaGVja2VyIHNob3VsZCBwcmV2ZW50IHRoaXMgRVhDRVBUIGZvciBhIGxvbmUgZXhwcmVzc2lvbiBhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgdGhlIHByb2dyYW0gd2hpY2ggd2lsbCBiZSBpbXBsaWNpdGx5IHJldHVybmVkXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBpbnRvIGEgcHJpbnQgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuZXhwci50eXBlXyA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRFeHByKHN0bXQuZXhwcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRFeHByKHN0bXQuZXhwcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRJbnN0cihbXCIobG9jYWwuc2V0ICRfX19JTVBMX1JFVClcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpZlwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuYWRkRXhwcihzdG10LnByZWQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRJbnN0cihbXCIoaWZcIiwgXCIodGhlblwiXSkgLy8gdHlwZWNoZWNrZXIgZGlzYWxsb3dzIGVtcHR5IGJvZHkxXG4gICAgICAgICAgICAgICAgICAgIC5hZGRTdG10cyhzdG10LmJvZHkxKTtcbiAgICAgICAgICAgICAgICB0bXAuYm9keVt0bXAuYm9keS5sZW5ndGggLSAxXSA9IHRtcC5ib2R5W3RtcC5ib2R5Lmxlbmd0aCAtIDFdICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keTIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wXyA9IHRtcC5hZGRJbnN0cihbXCIoZWxzZVwiXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRTdG10cyhzdG10LmJvZHkyKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wXy5ib2R5W3RtcF8uYm9keS5sZW5ndGggLSAxXSA9IHRtcF8uYm9keVt0bXBfLmJvZHkubGVuZ3RoIC0gMV0gKyBcIikpXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXBfO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmJvZHlbdG1wLmJvZHkubGVuZ3RoIC0gMV0gPSB0bXAuYm9keVt0bXAuYm9keS5sZW5ndGggLSAxXSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ3aGlsZVwiOiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHhvciBhbmQgc3dpdGNoIDEgYW5kIDAgaW4gYnJfaWYgYW5kIGJyIGFmdGVyIHdyaXRpbmdcbiAgICAgICAgICAgICAgICAvLyB0ZXN0cyBmb3IgbW9yZSBvcHRpbWl6ZWQgY29kZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV4cHIoc3RtdC5wcmVkKVxuICAgICAgICAgICAgICAgICAgICAuYWRkSW5zdHIoW1wiKGlmXCIsIFwiKHRoZW5cIiwgXCIobG9vcFwiXSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZFN0bXRzKHN0bXQuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZEV4cHIoc3RtdC5wcmVkKVxuICAgICAgICAgICAgICAgICAgICAuYWRkSW5zdHIoW1wiKGkzMi5jb25zdCAxKVwiLCBcIihpMzIueG9yKVwiLCBcIihicl9pZiAxKVwiLCBcIihiciAwKSkpKVwiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicGFzc1wiOiByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHdhdEJ1aWxkZXI7XG59KCkpO1xuLy8gc28gdXMgbWVyZSBodW1hbnMgY2FuIHVuZGVyc3RhbmQgdGhlIG91dHB1dFxuZnVuY3Rpb24gaW5kZW50KGNvZGUpIHtcbiAgICB2YXIgaW5kZW50ZWQgPSBjb2RlLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzKSB7XG4gICAgICAgIHZhciBjbnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNfMSA9IHM7IF9pIDwgc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGMgPSBzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBjbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBjbnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZW50THZsID0gY250ICsgYWNjWzBdO1xuICAgICAgICB2YXIgY29kZV8gPSBhY2NbMV0uY29uY2F0KFtcIiAgXCIucmVwZWF0KGFjY1swXSkgKyBzXSk7XG4gICAgICAgIHJldHVybiBbaW5kZW50THZsLCBjb2RlX107XG4gICAgfSwgWzAsIFtdXSk7XG4gICAgcmV0dXJuIGluZGVudGVkWzFdO1xufVxuO1xuZnVuY3Rpb24gY29tcGlsZShzb3VyY2UpIHtcbiAgICB2YXIgYXN0ID0gcGFyc2VyXzEucGFyc2VQcm9ncmFtKHNvdXJjZSk7XG4gICAgdmFyIHR5cGVkQVNUID0gdHlwZWNoZWNrZXJfMS5idWlsZFR5cGVkQVNUKGFzdCk7XG4gICAgLy8gbnVtYmVyIG9mIGRlZmluZSBzdGF0ZW1lbnRzXG4gICAgdmFyIG4gPSBhc3RfMS5jb3VudERlZkRlY2xTdG10cyh0eXBlZEFTVCk7XG4gICAgdmFyIGRlZlN0bXRzID0gdHlwZWRBU1Quc2xpY2UoMCwgbik7XG4gICAgdmFyIHJlc3QgPSB0eXBlZEFTVC5zbGljZShuKTtcbiAgICB2YXIgaW91dCA9IGRlZlN0bXRzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudGFnID09IFwiYXNzaWduXCI7IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcykge1xuICAgICAgICBpZiAocy50YWcgIT0gXCJhc3NpZ25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcGlsZXIgZXJyb3IuIENoZWNrIGNvZGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2MuYWRkU3RtdChzKVxuICAgICAgICAgICAgLmFkZERlY2woW1wiKGxvY2FsICRcIiArIHMubmFtZSArIFwiIGkzMilcIl0pO1xuICAgIH0sIG5ldyB3YXRCdWlsZGVyKVxuICAgICAgICAuYWRkU3RtdHMoZGVmU3RtdHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRhZyA9PSBcImRlZmluZVwiOyB9KSlcbiAgICAgICAgLmFkZFN0bXRzKHJlc3QpO1xuICAgIHZhciBwcm9nQm9keSA9IGlvdXQuZGVjbC5jb25jYXQoaW91dC5ib2R5KTtcbiAgICBpZiAoIWlvdXQuaW1wbFJldHVybikge1xuICAgICAgICBwcm9nQm9keVtwcm9nQm9keS5sZW5ndGggLSAxXSArPSBcIikpXCI7XG4gICAgfVxuICAgIHZhciBvdXQgPSAoaW91dC5pbXBsUmV0dXJuKSA/IFwiKHJlc3VsdCBpMzIpXCIgOiBcIlwiO1xuICAgIHZhciBjb2RlID0gW1wiKG1vZHVsZVwiXS5jb25jYXQoW1wiKGZ1bmMgJHByaW50STMyIChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJwcmludEkzMlxcXCIpIChwYXJhbSBpMzIpKVwiXSwgW1wiKGZ1bmMgJHByaW50Qm9vbCAoaW1wb3J0IFxcXCJpbXBvcnRzXFxcIiBcXFwicHJpbnRCb29sXFxcIikgKHBhcmFtIGkzMikpXCJdLCBbXCIoZnVuYyAkcHJpbnROb25lIChpbXBvcnQgXFxcImltcG9ydHNcXFwiIFxcXCJwcmludE5vbmVcXFwiKSlcIl0sIFtcIihmdW5jICRwb3cgKGltcG9ydCBcXFwiaW1wb3J0c1xcXCIgXFxcInBvd1xcXCIpIChwYXJhbSBpMzIpIChwYXJhbSBpMzIpIChyZXN1bHQgaTMyKSlcIl0sIGlvdXQuZGVmcywgW1wiKGZ1bmMgKGV4cG9ydCBcXFwiX3N0YXJ0XFxcIikgXCIgKyBvdXRdLCBbXCIobG9jYWwgJF9fX0lNUExfUkVUIGkzMilcIl0sIHByb2dCb2R5LCAoaW91dC5pbXBsUmV0dXJuKSA/IFtcIihsb2NhbC5nZXQgJF9fX0lNUExfUkVUKSkpXCJdIDogW1wiXCJdKTtcbiAgICByZXR1cm4gaW5kZW50KGNvZGUpLmpvaW4oXCJcXG5cIik7XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmlhcnlPcFR5cGVFcnJvciA9IGV4cG9ydHMuUGFyc2VFcnJvciA9IGV4cG9ydHMuRnVuY0NhbGxUeXBFcnJvciA9IGV4cG9ydHMuR2VuZXJhbFR5cGVFcnJvciA9IGV4cG9ydHMuTWlzc2luZ1JldHVybiA9IGV4cG9ydHMuTm90RGVjbGFyZWRJblNjb3BlID0gZXhwb3J0cy5Ob3RBVmFyaWFibGUgPSBleHBvcnRzLk5vdEFGdW5jdGlvbk9yQ2xhc3MgPSBleHBvcnRzLkR1cGxpY2F0ZURlY2xhcmF0aW9uID0gZXhwb3J0cy5Db25kaXRpb25hbEV4cHJUeXBlRXJyb3IgPSBleHBvcnRzLkNvbXBpbGVyRXJyb3IgPSBleHBvcnRzLkJpbmFyeU9wVHlwZUVycm9yID0gdm9pZCAwO1xudmFyIEJpbmFyeU9wVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5hcnlPcFR5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5hcnlPcFR5cGVFcnJvcihvcCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJDYW5ub3QgYXBwbHkgb3BlcmF0b3IgYFwiICsgb3AgKyBcImAgb24gdHlwZXMgYFwiICsgdDEgKyBcImAgYW5kIGBcIiArIHQyICsgXCJgXCIpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdCaW5hcnlPcFR5cGVFcnJvcic7XG4gICAgICAgIF90aGlzLm9wID0gb3A7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCaW5hcnlPcFR5cGVFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQmluYXJ5T3BUeXBlRXJyb3IgPSBCaW5hcnlPcFR5cGVFcnJvcjtcbnZhciBDb21waWxlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBpbGVyRXJyb3IoKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTm90QVZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uYW1lID0gJ0NvbXBpbGVyRXJyb3InO1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZXJFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQ29tcGlsZXJFcnJvciA9IENvbXBpbGVyRXJyb3I7XG52YXIgQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25kaXRpb25hbEV4cHJUeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yKGNvbmRpdGlvbmFsVHlwZSkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiBjYW5ub3QgYmUgb2YgdHlwZSBgXCIgKyBjb25kaXRpb25hbFR5cGUgKyBcImBcIikgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTm90QVZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uYW1lID0gJ0NvbmRpdGlvbmFsRXhwclR5cGVFcnJvcic7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbmFsVHlwZSA9IGNvbmRpdGlvbmFsVHlwZTtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwclR5cGVFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yID0gQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yO1xudmFyIER1cGxpY2F0ZURlY2xhcmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEdXBsaWNhdGVEZWNsYXJhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEdXBsaWNhdGVEZWNsYXJhdGlvbihpZGVudCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiRHVwbGljYXRlIGRlY2xhcmF0aW9uIG9mIGlkZW50aWZpZXIgaW4gc2FtZSBzY29wZTogXCIgKyBpZGVudCkgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgRHVwbGljYXRlRGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5hbWUgPSAnRHVwbGljYXRlRGVjbGFyYXRpb24nO1xuICAgICAgICBfdGhpcy5pZGVudCA9IGlkZW50O1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRHVwbGljYXRlRGVjbGFyYXRpb247XG59KEVycm9yKSk7XG5leHBvcnRzLkR1cGxpY2F0ZURlY2xhcmF0aW9uID0gRHVwbGljYXRlRGVjbGFyYXRpb247XG52YXIgTm90QUZ1bmN0aW9uT3JDbGFzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90QUZ1bmN0aW9uT3JDbGFzcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RBRnVuY3Rpb25PckNsYXNzKG9iak5hbWUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIk5vdCBhIGZ1bmN0aW9uIG9yIGNsYXNzOiBcIiArIG9iak5hbWUpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdEFWYXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdOb3RBRnVuY3Rpb25PckNsYXNzJztcbiAgICAgICAgX3RoaXMub2JqTmFtZSA9IG9iak5hbWU7XG4gICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb3RBRnVuY3Rpb25PckNsYXNzO1xufShFcnJvcikpO1xuZXhwb3J0cy5Ob3RBRnVuY3Rpb25PckNsYXNzID0gTm90QUZ1bmN0aW9uT3JDbGFzcztcbnZhciBOb3RBVmFyaWFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdEFWYXJpYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RBVmFyaWFibGUodmFyTmFtZSkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiTm90IGEgdmFyaWFibGU6IFwiICsgdmFyTmFtZSkgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTm90QVZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uYW1lID0gJ05vdEFWYXJpYWJsZSc7XG4gICAgICAgIF90aGlzLnZhck5hbWUgPSB2YXJOYW1lO1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTm90QVZhcmlhYmxlO1xufShFcnJvcikpO1xuZXhwb3J0cy5Ob3RBVmFyaWFibGUgPSBOb3RBVmFyaWFibGU7XG52YXIgTm90RGVjbGFyZWRJblNjb3BlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3REZWNsYXJlZEluU2NvcGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm90RGVjbGFyZWRJblNjb3BlKHZhck5hbWUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIkNhbm5vdCBhc3NpZ24gdG8gdmFyaWFibGUgdGhhdCBpcyBub3QgZXhwbGljaXRseSBkZWNhbGFyZWQgaW4gdGhpcyBzY29wZTogXCIgKyB2YXJOYW1lKSB8fCB0aGlzO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBOb3REZWNsYXJlZEluU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5hbWUgPSAnTm90RGVjbGFyZWRJblNjb3BlJztcbiAgICAgICAgX3RoaXMudmFyTmFtZSA9IHZhck5hbWU7XG4gICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IF9uZXdUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb3REZWNsYXJlZEluU2NvcGU7XG59KEVycm9yKSk7XG5leHBvcnRzLk5vdERlY2xhcmVkSW5TY29wZSA9IE5vdERlY2xhcmVkSW5TY29wZTtcbnZhciBNaXNzaW5nUmV0dXJuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaXNzaW5nUmV0dXJuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1pc3NpbmdSZXR1cm4oZikge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChmID09PSB2b2lkIDApIHsgZiA9IFwiY29udGFpbnNcIjsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIkFsbCBwYXRocyBpbiB0aGlzIGZ1bmN0aW9uL21ldGhvZCBtdXN0IGhhdmUgYSByZXR1cm4gc3RhdGVtZW50OiBcIiArIGYpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdNaXNzaW5nUmV0dXJuJztcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1pc3NpbmdSZXR1cm47XG59KEVycm9yKSk7XG5leHBvcnRzLk1pc3NpbmdSZXR1cm4gPSBNaXNzaW5nUmV0dXJuO1xudmFyIEdlbmVyYWxUeXBlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdlbmVyYWxUeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2VuZXJhbFR5cGVFcnJvcihhY3R1YWxUeXBlLCBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIkV4cGVjdGVkIHR5cGUgYFwiICsgZXhwZWN0ZWRUeXBlICsgXCJgOyBnb3QgdHlwZSBgXCIgKyBhY3R1YWxUeXBlICsgXCJgXCIpIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdHZW5lcmFsVHlwZUVycm9yJztcbiAgICAgICAgX3RoaXMuYWN0dWFsVHlwZSA9IGFjdHVhbFR5cGU7XG4gICAgICAgIF90aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYWxUeXBlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkdlbmVyYWxUeXBlRXJyb3IgPSBHZW5lcmFsVHlwZUVycm9yO1xudmFyIEZ1bmNDYWxsVHlwRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmNDYWxsVHlwRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVuY0NhbGxUeXBFcnJvcihhY3R1YWxUeXBlLCBleHBlY3RlZFR5cGUsIHBhcmFtTikge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiRXhwZWN0ZWQgdHlwZSBgXCIgKyBleHBlY3RlZFR5cGUgKyBcImA7IGdvdCB0eXBlIGBcIiArIGFjdHVhbFR5cGUgKyBcImBcIikgfHwgdGhpcztcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgRnVuY0NhbGxUeXBFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdGdW5jQ2FsbFR5cEVycm9yJztcbiAgICAgICAgX3RoaXMuYWN0dWFsVHlwZSA9IGFjdHVhbFR5cGU7XG4gICAgICAgIF90aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgX3RoaXMucGFyYW1OID0gcGFyYW1OO1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBfbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRnVuY0NhbGxUeXBFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuRnVuY0NhbGxUeXBFcnJvciA9IEZ1bmNDYWxsVHlwRXJyb3I7XG52YXIgUGFyc2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJzZUVycm9yKHRva2VuKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJQYXJzZSBlcnJvciBuZWFyIHRva2VuIFwiICsgdG9rZW4pIHx8IHRoaXM7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE5vdERlY2xhcmVkSW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubmFtZSA9ICdQYXJzZUVycm9yJztcbiAgICAgICAgX3RoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlBhcnNlRXJyb3IgPSBQYXJzZUVycm9yO1xudmFyIFVuaWFyeU9wVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbmlhcnlPcFR5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmlhcnlPcFR5cGVFcnJvcihvcCwgdCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiQ2Fubm90IGFwcGx5IG9wZXJhdG9yIGBcIiArIG9wICsgXCJgIG9uIHR5cGUgYFwiICsgdCArIFwiYFwiKSB8fCB0aGlzO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBOb3REZWNsYXJlZEluU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5hbWUgPSAnVW5pYXJ5T3BUeXBlRXJyb3InO1xuICAgICAgICBfdGhpcy5vcCA9IG9wO1xuICAgICAgICBfdGhpcy50ID0gdDtcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gX25ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVuaWFyeU9wVHlwZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5VbmlhcnlPcFR5cGVFcnJvciA9IFVuaWFyeU9wVHlwZUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYXZlcnNlRXhwciA9IGV4cG9ydHMudHJhdmVyc2VQYXJhbWV0ZXJzID0gZXhwb3J0cy50cmF2ZXJzZVN0bXQgPSBleHBvcnRzLnBhcnNlRm9sbG93aW5nU3RtdHMgPSBleHBvcnRzLnBhcnNlUHJvZ3JhbSA9IHZvaWQgMDtcbnZhciBsZXplcl9weXRob25fMSA9IHJlcXVpcmUoXCJsZXplci1weXRob25cIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBwYXJzZVByb2dyYW0oc291cmNlKSB7XG4gICAgdmFyIHQgPSBsZXplcl9weXRob25fMS5wYXJzZXIucGFyc2Uoc291cmNlKS5jdXJzb3IoKTtcbiAgICAvLyBUaGUgdG9wIG5vZGUgaW4gdGhlIHByb2dyYW0gaXMgYSBTY3JpcHQgbm9kZSB3aXRoIGEgbGlzdCBvZiBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHZhcmlvdXMgc3RhdGVtZW50c1xuICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgIHJldHVybiBwYXJzZUZvbGxvd2luZ1N0bXRzKHNvdXJjZSwgdCk7XG59XG5leHBvcnRzLnBhcnNlUHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbTtcbmZ1bmN0aW9uIHBhcnNlRm9sbG93aW5nU3RtdHMocywgdCkge1xuICAgIHZhciBzdG10cyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHN0bXQgPSB0cmF2ZXJzZVN0bXQocywgdCk7XG4gICAgICAgIHN0bXRzLnB1c2goc3RtdCk7XG4gICAgICAgIC8vIGRyb3AgYWxsIHN0YXRlbWVudHMgYWZ0ZXIgcGFzcyBvciBlYXJseSByZXR1cm5cbiAgICAgICAgaWYgKHN0bXQudGFnID09IFwicGFzc1wiIHx8IHN0bXQudGFnID09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAodC5uZXh0U2libGluZygpKTsgLy8gdC5uZXh0U2libGluZygpIHJldHVybnMgZmFsc2Ugd2hlbiBpdCByZWFjaGVzXG4gICAgLy8gIHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICByZXR1cm4gc3RtdHM7XG59XG5leHBvcnRzLnBhcnNlRm9sbG93aW5nU3RtdHMgPSBwYXJzZUZvbGxvd2luZ1N0bXRzO1xuLypcbiAgSW52YXJpYW50IOKAkyB0IG11c3QgZm9jdXMgb24gdGhlIHNhbWUgbm9kZSBhdCB0aGUgZW5kIG9mIHRoZSB0cmF2ZXJzYWxcbiovXG5mdW5jdGlvbiB0cmF2ZXJzZVN0bXQocywgdCkge1xuICAgIHN3aXRjaCAodC50eXBlLm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgcmV0dXJuIGtleXdvcmRcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJyZXR1cm5cIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkFzc2lnblN0YXRlbWVudFwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gZm9jdXNlZCBvbiBuYW1lICh0aGUgZmlyc3QgY2hpbGQpXG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGRlY2xhcmVkIHR5cGUgKGlmIGFueSlcbiAgICAgICAgICAgIHZhciB0eXBlXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQuZmlyc3RDaGlsZCgpKSB7IC8vIDogaW4gdGhlIHR5cGUgZGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyB0aGUgYWN0dWFsIGRlY2xhcmVkIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnN0ciA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdHIgPT0gXCJib29sXCIgfHwgc3Vic3RyID09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzdHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBmb2N1c2VkIG9uID0gc2lnbi4gTWF5IG5lZWQgdGhpcyBmb3IgY29tcGxleCB0YXNrcywgbGlrZSArPSFcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZm9jdXNlZCBvbiB0aGUgdmFsdWUgZXhwcmVzc2lvblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJhc3NpZ25cIiwgbmFtZTogbmFtZV8xLCB0eXBlXzogdHlwZV8sIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6IHtcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBUaGUgY2hpbGQgaXMgc29tZSBraW5kIG9mIGV4cHJlc3Npb24sIHRoZVxuICAgICAgICAgICAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCBpcyBqdXN0IGEgd3JhcHBlciB3aXRoIG5vIGluZm9ybWF0aW9uXG4gICAgICAgICAgICB2YXIgZXhwciA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiZXhwclwiLCBleHByOiBleHByIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIklmU3RhdGVtZW50XCI6IHtcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBpZiBzdGF0ZW1lbnRcbiAgICAgICAgICAgIHZhciB0cmF2ZXJzZUlmc18xID0gZnVuY3Rpb24gKHMsIHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKFtcImlmXCIsIFwiZWxpZlwiXSkuaW5jbHVkZXModC5ub2RlLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyB0aGUgcHJlZGljYXRlXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVkID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyA6IGJlZm9yZSB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIHRoZSBmaXJzdCBzdGF0ZW1lbnQgb2YgdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkxID0gcGFyc2VGb2xsb3dpbmdTdG10cyhzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9keSBpbW1lZGlhdGVseSBhZnRlciBpZiBjYW5ub3QgYmUgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkxLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VFcnJvcihcIkRFREVOVFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBCb2R5XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gZWxpZi9lbHNlIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbeyB0YWc6IFwiaWZcIiwgcHJlZDogcHJlZCwgYm9keTE6IGJvZHkxLCBib2R5MjogdHJhdmVyc2VJZnNfMShzLCB0KSB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodC5ub2RlLnR5cGUubmFtZSA9PSBcImVsc2VcIikgeyAvLyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIDogYmVmb3JlIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGZpcnN0IHN0YXRlbWVudCBvZiB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keV8xID0gcGFyc2VGb2xsb3dpbmdTdG10cyhzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHlfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaWZzdG10ID0gdHJhdmVyc2VJZnNfMShzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gaWZzdG10WzBdO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gd2hpbGVcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gcHJlZGljYXRlXG4gICAgICAgICAgICB2YXIgcHJlZCA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gQm9keVxuICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7IC8vIGNvbG9uXG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIHN0YXRlbWVudFxuICAgICAgICAgICAgdmFyIGJvZHlfMiA9IHBhcnNlRm9sbG93aW5nU3RtdHMocywgdCk7XG4gICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhZzogXCJ3aGlsZVwiLCBwcmVkOiBwcmVkLCBib2R5OiBib2R5XzIgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUGFzc1N0YXRlbWVudFwiOiByZXR1cm4geyB0YWc6IFwicGFzc1wiIH07XG4gICAgICAgIGNhc2UgXCJGdW5jdGlvbkRlZmluaXRpb25cIjpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvbiBkZWZcbiAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gbmFtZSBvZiBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIG5hbWVfMiA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIFBhcmFtTGlzdFxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0cmF2ZXJzZVBhcmFtZXRlcnMocywgdCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgb3V0cHV0VHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQubm9kZS50eXBlLm5hbWUgPT0gXCJUeXBlRGVmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gdGhlIGFjdHVhbCBkZWNsYXJlZCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdHIgPSBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pO1xuICAgICAgICAgICAgICAgICAgICB0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RyID09IFwiYm9vbFwiIHx8IHN1YnN0ciA9PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic3RyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gQm9keVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dFR5cGVfMSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIG9uIDpcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBwYXJzZUZvbGxvd2luZ1N0bXRzKHMsIHQpO1xuICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VFcnJvcihcIkVPRlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHQucGFyZW50KCk7IC8vIFBvcCB0byBCb2R5XG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gRnVuY3Rpb25EZWZpbml0aW9uXG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiZGVmaW5lXCIsIG5hbWU6IG5hbWVfMiwgcGFyYW1ldGVyczogcGFyYW1ldGVycywgb3V0cHV0VHlwZTogb3V0cHV0VHlwZSwgYm9keTogYm9keSB9O1xuICAgIH1cbn1cbmV4cG9ydHMudHJhdmVyc2VTdG10ID0gdHJhdmVyc2VTdG10O1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJhbWV0ZXJzKHMsIHQpIHtcbiAgICB2YXIgcGFyYW1ldGVycyA9IFtdO1xuICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1c2VzIG9uIG9wZW4gcGFyZW5cbiAgICBkbyB7XG4gICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXNlcyBvbiBhIFZhcmlhYmxlTmFtZVxuICAgICAgICB2YXIgbmFtZV8zID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgaWYgKG5hbWVfMyA9PSBcIilcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1c2VzIG9uIGEgdHlwZWRlZiwgaWYgYW55XG4gICAgICAgIGlmICh0Lm5vZGUudHlwZS5uYW1lID09IFwiVHlwZURlZlwiKSB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gOiBpbiB0aGUgdHlwZSBkZWNsYXJhdGlvblxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyB0aGUgYWN0dWFsIGRlY2xhcmVkIHR5cGVcbiAgICAgICAgICAgIHZhciB0eXBlXyA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICB0LnBhcmVudCgpOyAvLyBiYWNrIHRvIHBhcmFtZXRlclxuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHsgbmFtZTogbmFtZV8zLCB0eXBlXzogdHlwZV8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZSBlcnJvciBuZWFyIHRva2VuIFJQQVJFTjogXCIgKyBzLnN1YnN0cmluZyh0Lm5vZGUuZnJvbSwgdC5ub2RlLnRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiAsIG9yIClcbiAgICB9IHdoaWxlIChzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pICE9IFwiKVwiKTtcbiAgICB0LnBhcmVudCgpOyAvLyBQb3AgdG8gUGFyYW1MaXN0XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5leHBvcnRzLnRyYXZlcnNlUGFyYW1ldGVycyA9IHRyYXZlcnNlUGFyYW1ldGVycztcbmZ1bmN0aW9uIHRyYXZlcnNlRXhwcihzLCB0KSB7XG4gICAgc3dpdGNoICh0LnR5cGUubmFtZSkge1xuICAgICAgICBjYXNlIFwiTnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhZzogXCJsaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlXzogXCJpbnRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcIkJvb2xlYW5cIjoge1xuICAgICAgICAgICAgdmFyIGJvb2wgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVHJ1ZVwiOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkZhbHNlXCI6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IFwibGl0ZXJhbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBib29sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlXzogXCJib29sXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIlZhcmlhYmxlTmFtZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiBcImlkXCIsIG5hbWU6IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byksIHR5cGVfOiBcIlwiIH07XG4gICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gRm9jdXMgbmFtZVxuICAgICAgICAgICAgdmFyIG5hbWVfNCA9IHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50byk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7IC8vIEZvY3VzIEFyZ0xpc3RcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpOyAvLyBGb2N1cyBvcGVuIHBhcmVuXG4gICAgICAgICAgICB2YXIgYXJnTGlzdCA9IFtdO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHQubmV4dFNpYmxpbmcoKTsgLy8gRm9jdXMgb24gcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgYXJnTGlzdC5wdXNoKHRyYXZlcnNlRXhwcihzLCB0KSk7XG4gICAgICAgICAgICAgICAgdC5uZXh0U2libGluZygpOyAvLyBGb2N1cyBvbiAsIG9yIClcbiAgICAgICAgICAgIH0gd2hpbGUgKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykgIT0gXCIpXCIpO1xuICAgICAgICAgICAgdC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiY2FsbFwiLCBuYW1lOiBuYW1lXzQsIGFyZ3VtZW50czogYXJnTGlzdCwgdHlwZV86IFwiXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6IHtcbiAgICAgICAgICAgIHQuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgdmFyIHVuaW9wID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi1cIjogcmV0dXJuIFwibmVnXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub3RcIjogcmV0dXJuIFwibm90XCI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQgYXQgXCIgKyB0LmZyb20gKyBcIiBcIiArIHQudG8gKyBcIjogXCIgKyBzLnN1YnN0cmluZyh0LmZyb20sIHQudG8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIGFyZyA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwidW5pb3BcIiwgYXJnOiBhcmcsIHVuaW9wOiB1bmlvcCwgdHlwZV86IFwiXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIHZhciBhcmcxID0gdHJhdmVyc2VFeHByKHMsIHQpO1xuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIGJpbm9wID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gcy5zdWJzdHJpbmcodC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgICAgICB2YXIgaW50T3BzID0gW1wiK1wiLCBcIi1cIiwgXCIqXCIsIFwiLy9cIiwgXCIlXCIsIFwiPT1cIiwgXCIhPVwiLCBcIj49XCIsIFwiPD1cIiwgXCI+XCIsIFwiPFwiXTtcbiAgICAgICAgICAgICAgICBpZiAoaW50T3BzLmluY2x1ZGVzKHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCBhdCBcIiArIHQuZnJvbSArIFwiIFwiICsgdC50byArIFwiOiBcIiArIHMuc3Vic3RyaW5nKHQuZnJvbSwgdC50bykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB0Lm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgICB2YXIgYXJnMiA9IHRyYXZlcnNlRXhwcihzLCB0KTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwiYmlub3BcIiwgYXJnMTogYXJnMSwgYXJnMjogYXJnMiwgYmlub3A6IGJpbm9wLCB0eXBlXzogXCJcIiB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOiB7XG4gICAgICAgICAgICB0LmZpcnN0Q2hpbGQoKTsgLy8gZm9jdXNlcyBvbiBcIihcIlxuICAgICAgICAgICAgdC5uZXh0U2libGluZygpO1xuICAgICAgICAgICAgdmFyIGUgPSB0cmF2ZXJzZUV4cHIocywgdCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIHQucGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4geyB0YWc6IFwicGFyZW5zXCIsIGV4cHI6IGUsIHR5cGVfOiBcIlwiIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnRyYXZlcnNlRXhwciA9IHRyYXZlcnNlRXhwcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucnVuID0gZXhwb3J0cy5ydW5QeXRob24gPSBleHBvcnRzLmltcG9ydE9iamVjdCA9IHZvaWQgMDtcbnZhciB3YWJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndhYnRcIikpO1xudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9jb21waWxlclwiKTtcbmV4cG9ydHMuaW1wb3J0T2JqZWN0ID0ge1xuICAgIGltcG9ydHM6IHtcbiAgICAgICAgLy8gd2UgdHlwaWNhbGx5IGRlZmluZSBwcmludCB0byBtZWFuIGxvZ2dpbmcgdG8gdGhlIGNvbnNvbGUuIFRvIG1ha2UgdGVzdGluZ1xuICAgICAgICAvLyB0aGUgY29tcGlsZXIgZWFzaWVyLCB3ZSBkZWZpbmUgcHJpbnQgc28gaXQgbG9ncyB0byBhIHN0cmluZyBvYmplY3QuXG4gICAgICAgIC8vICBXZSBjYW4gdGhlbiBleGFtaW5lIG91dHB1dCB0byBzZWUgd2hhdCB3b3VsZCBoYXZlIGJlZW4gcHJpbnRlZCBpbiB0aGVcbiAgICAgICAgLy8gIGNvbnNvbGUuXG4gICAgICAgIHByaW50STMyOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICBleHBvcnRzLmltcG9ydE9iamVjdC5vdXRwdXQgKz0gYXJnO1xuICAgICAgICAgICAgZXhwb3J0cy5pbXBvcnRPYmplY3Qub3V0cHV0ICs9IFwiXFxuXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHByaW50Qm9vbDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgaWYgKGFyZyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5pbXBvcnRPYmplY3Qub3V0cHV0ICs9IFwiVHJ1ZVxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJnID09IDApIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmltcG9ydE9iamVjdC5vdXRwdXQgKz0gXCJGYWxzZVxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGluZyBwcmludEJvb2wgb24gYW4gaTMyIGFyZ3VtZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmludE5vbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuaW1wb3J0T2JqZWN0Lm91dHB1dCArPSBcIk5vbmVcXG5cIjtcbiAgICAgICAgfSxcbiAgICAgICAgcG93OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KHgsIHkpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgb3V0cHV0OiBcIlwiXG59O1xuZnVuY3Rpb24gcnVuUHl0aG9uKHB5dGhvblNyb3VjZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdhdDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgd2F0ID0gY29tcGlsZXJfMS5jb21waWxlKHB5dGhvblNyb3VjZSk7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcnVuKHdhdCldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucnVuUHl0aG9uID0gcnVuUHl0aG9uO1xuZnVuY3Rpb24gcnVuKHdhdFNvdXJjZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdhYnRBcGksIHBhcnNlZCwgYmluYXJ5LCB3YXNtTW9kdWxlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWJ0XzEuZGVmYXVsdCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHdhYnRBcGkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHdhYnRBcGkucGFyc2VXYXQoXCJleGFtcGxlXCIsIHdhdFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeSA9IHBhcnNlZC50b0JpbmFyeSh7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeS5idWZmZXIsIGV4cG9ydHMuaW1wb3J0T2JqZWN0KV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB3YXNtTW9kdWxlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5leHQgbGluZSBpcyB3YXNtLWludGVycFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgd2FzbU1vZHVsZS5pbnN0YW5jZS5leHBvcnRzLl9zdGFydCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJ1biA9IHJ1bjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5mZXJFeHByVHlwZSA9IGV4cG9ydHMuY2hlY2tSZXR1cm5UeXBlID0gZXhwb3J0cy5maWxsSW5TdG10c1R5cGVJbmZvID0gZXhwb3J0cy5idWlsZFR5cGVkQVNUID0gdm9pZCAwO1xudmFyIGFzdF8xID0gcmVxdWlyZShcIi4vYXN0XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLy8gRklYTUU6IHRoZSByaHMgb2YgdmFyaWFibGUgZGVjbGFyYXRpb24gY2FuIG9ubHkgYmUgbGl0ZXJhbHNcbmZ1bmN0aW9uIGJ1aWxkVHlwZWRBU1QocHJvZykge1xuICAgIHZhciBidWlsdGluID0gbmV3IE1hcDtcbiAgICBidWlsdGluLnNldChcInByaW50XCIsIHsgcGFyYW1ldGVyVHlwZXM6IFtcInBvbHltb3JwaGljXCJdLCBvdXRwdXRUeXBlOiBcIm5vbmVcIiB9KTtcbiAgICBidWlsdGluLnNldChcImFic1wiLCB7IHBhcmFtZXRlclR5cGVzOiBbXCJpbnRcIl0sIG91dHB1dFR5cGU6IFwiaW50XCIgfSk7XG4gICAgYnVpbHRpbi5zZXQoXCJtYXhcIiwgeyBwYXJhbWV0ZXJUeXBlczogW1wiaW50XCIsIFwiaW50XCJdLCBvdXRwdXRUeXBlOiBcImludFwiIH0pO1xuICAgIGJ1aWx0aW4uc2V0KFwibWluXCIsIHsgcGFyYW1ldGVyVHlwZXM6IFtcImludFwiLCBcImludFwiXSwgb3V0cHV0VHlwZTogXCJpbnRcIiB9KTtcbiAgICBidWlsdGluLnNldChcInBvd1wiLCB7IHBhcmFtZXRlclR5cGVzOiBbXCJpbnRcIiwgXCJpbnRcIl0sIG91dHB1dFR5cGU6IFwiaW50XCIgfSk7XG4gICAgcmV0dXJuIGZpbGxJblN0bXRzVHlwZUluZm8ocHJvZywgbmV3IE1hcCwgYnVpbHRpbiwgXCJub25lXCIpO1xufVxuZXhwb3J0cy5idWlsZFR5cGVkQVNUID0gYnVpbGRUeXBlZEFTVDtcbi8vIEEgZmFpbHVyZSBpbiB0aGUgdHlwZWNoZWNraW5nIHByb2Nlc3MgbGVhZHMgdG8gYW4gdW5yZWNvdmVyYWJsZSBmYWlsdXJlIHNvIHdlXG4vLyBtaWdodCBhcyB3ZWxsIHRocm93IGFuIGVycm9yIGFuZCBleGl0LiBBIHBhc3MgYXQgdGhpcyBzdGFnZSBob3dldmVyIGRvZXMgbm90XG4vLyB3YXJyYW50IGFueSBhY3Rpb24uXG5mdW5jdGlvbiBmaWxsSW5TdG10c1R5cGVJbmZvKHN0bXRzLCBvdXRlclZhclNjb3BlLCBvdXRlckZ1bmNTY29wZSwgcmV0VHlwZSkge1xuICAgIC8vIEFsbCB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbnMgYW5kIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBtdXN0IGJlIGF0IHRoZSB0b3BcbiAgICAvLyBvZiB0aGUgc2NvcGUuIFRoZSBvcmRlciBvZiBkZWZzIG9yIGRlY2xzIGRvZXNuJ3QgbWF0dGVyLS10aGV5IGNhbiBldmVuIGJlXG4gICAgLy8gaW50ZXJ3ZWF2ZWQsIGFzIGxvbmcgYXMgbm8gY29tcHV0YXRpb24gaGFwcGVucyBiZWZvcmUgdGhlbiBlbmQgb2YgdGhpc1xuICAgIC8vIGJsb2NrLiBXZSdsbCBjYWxsIHRoaXMgdGhlIHByZWFtYmxlLlxuICAgIC8vIEdldCB0aGUgc3RhdGVtZW50IG51bWJlciB3aGVyZSB0aGUgcHJlYW1ibGUgZW5kc1xuICAgIHZhciBuID0gYXN0XzEuY291bnREZWZEZWNsU3RtdHMoc3RtdHMpO1xuICAgIC8vIGV4dHJhY3QgdGhlIGFzc2lnbm1lbnQgYW5kIGRlZmluaXRpb24gc3RhdGVtZW50c1xuICAgIHZhciBkZWNsQmxvY2sgPSBzdG10cy5zbGljZSgwLCBuKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudGFnID09IFwiYXNzaWduXCI7IH0pO1xuICAgIHZhciBkZWZCbG9jayA9IHN0bXRzLnNsaWNlKDAsIG4pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50YWcgPT0gXCJkZWZpbmVcIjsgfSk7XG4gICAgLy8gY2hlY2sgZm9yIGRlcGxpY2F0ZSBkZWNsYXJhdGlvbiBvZiBpZGVudGlmaWVyc1xuICAgIHZhciBpZGVudHMgPSBuZXcgTWFwO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdG10cy5zbGljZSgwLCBuKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHN0bXQgPSBfYVtfaV07XG4gICAgICAgIGlmIChzdG10LnRhZyAhPSBcImFzc2lnblwiICYmIHN0bXQudGFnICE9IFwiZGVmaW5lXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIGVycm9yLiBDaGVjayBjb2RlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChpZGVudHMuaGFzKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5EdXBsaWNhdGVEZWNsYXJhdGlvbihzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWRlbnRzLnNldChzdG10Lm5hbWUsIHN0bXQpO1xuICAgIH1cbiAgICAvLyBLZWVwIGEgdGFibGUgb2YgdmFyaWFibGVzIGFuZCB0aGVpciB0eXBlc1xuICAgIC8vIE5vdGU6IGRlZmluaXRpb25zIGluIHRoZSBjdXJyZW50IHNjb3BlIHdpbGwgb3ZlcndyaXRlIGRlZmluaXRpb25zIGZyb21cbiAgICAvLyBvdXRlcnNjb3BlIGlmIHRoZXJlIGFyZSBjb25mbGljdHNcbiAgICB2YXIgdmFyU2NvcGUgPSBkZWNsQmxvY2subWFwKGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIGlmIChzdG10LnRhZyAhPSBcImFzc2lnblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21waWxlciBlcnJvci4gQ2hlY2sgY29kZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoc3RtdC50eXBlXyA9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90QVZhcmlhYmxlKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC8vIE1lcmdlIHdpdGggb3V0ZXIgc2NvcGUuIE92ZXJ3cml0ZSB0eXBlIGRlY2xhcmF0aW9ucyBpZiBuZWNlc3NhcnkuXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgdCkge1xuICAgICAgICBtYXAuc2V0KHQubmFtZSwgdC50eXBlXyk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgb3V0ZXJWYXJTY29wZSk7XG4gICAgLy8gS2VlcCBhIHRhYmxlIG9mIGFsbCBjdXJyZW50bHkgZGVmaW5lZCBmdW5jdGlvbnMuIE92ZXJ3cml0ZSBkZWZpbml0aW9ucyBmcm9tXG4gICAgLy8gdGhlIG91dGVyIHNjb3BlIGlmIG5lY2Vzc2FyeVxuICAgIHZhciBmdW5jU2NvcGUgPSBkZWZCbG9jay5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgdCkge1xuICAgICAgICBpZiAodC50YWcgIT0gXCJkZWZpbmVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcGlsZXIgZXJyb3IuIENoZWNrIGNvZGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgdmFyIGZ0eXBlID0ge1xuICAgICAgICAgICAgcGFyYW1ldGVyVHlwZXM6IHQucGFyYW1ldGVycy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHlwZV87IH0pLFxuICAgICAgICAgICAgb3V0cHV0VHlwZTogdC5vdXRwdXRUeXBlXG4gICAgICAgIH07XG4gICAgICAgIG1hcC5zZXQodC5uYW1lLCBmdHlwZSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgb3V0ZXJGdW5jU2NvcGUpO1xuICAgIC8vIFR5cGVjaGVjayBlYWNoIHN0YXRlbWVudFxuICAgIHZhciBhZGRUeXBlcyA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIHN3aXRjaCAoc3RtdC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhc3NpZ25cIjoge1xuICAgICAgICAgICAgICAgIHZhciByaHNUeXBlID0gaW5mZXJFeHByVHlwZShzdG10LnZhbHVlLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGhzVHlwZSA9IHZhclNjb3BlLmdldChzdG10Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChyaHNUeXBlICE9IGxoc1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkdlbmVyYWxUeXBlRXJyb3IobGhzVHlwZSwgcmhzVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RtdCksIHsgdmFsdWU6IGZpbGxJbkV4cHJUeXBlSW5mbyhzdG10LnZhbHVlLCB2YXJTY29wZSwgZnVuY1Njb3BlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJleHByXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0bXQpLCB7IGV4cHI6IGZpbGxJbkV4cHJUeXBlSW5mbyhzdG10LmV4cHIsIHZhclNjb3BlLCBmdW5jU2NvcGUpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImRlZmluZVwiOiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hvY29QeSBmdW5jdGlvbnMgZG9uJ3QgY2FwdHVyZSB2YXJpYWJsZXMuIFJlc2V0IHNjb3BlIHRvIGJlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHN1cHBsaWVkIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgdmFyIHZhclNjb3BlXzEgPSBzdG10LnBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChkZWNsQmxvY2spXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgcCkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KHAubmFtZSwgcC50eXBlXyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfSwgbmV3IE1hcCk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgc3RhdGVtZW50cyBpbiB0aGUgYm9keSwgaW5jbHVkaW5nIG1hdGNoaW5nIHJldHVybiB0eXBlcyB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBzdGF0ZWQgb3V0cHV0IHR5cGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsSW5TdG10c1R5cGVJbmZvKHN0bXQuYm9keSwgdmFyU2NvcGVfMSwgZnVuY1Njb3BlLCBzdG10Lm91dHB1dFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBlcnJvcnNfMS5Ob3RBVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJTY29wZV8xLmhhcyhlcnIudmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90RGVjbGFyZWRJblNjb3BlKGVyci52YXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrUmV0dXJuVHlwZShzdG10Lm5hbWUsIHN0bXQuYm9keSwgdmFyU2NvcGVfMSwgZnVuY1Njb3BlLCBzdG10Lm91dHB1dFR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gZmlsbEluU3RtdHNUeXBlSW5mbyhzdG10LmJvZHksIHZhclNjb3BlXzEsIGZ1bmNTY29wZSwgc3RtdC5vdXRwdXRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0bXQpLCB7IGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmV0dXJuXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGluZmVyRXhwclR5cGUoc3RtdC52YWx1ZSwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldFR5cGUgIT0gdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuR2VuZXJhbFR5cGVFcnJvcihyZXRUeXBlLCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdG10KSwgeyB2YWx1ZTogZmlsbEluRXhwclR5cGVJbmZvKHN0bXQudmFsdWUsIHZhclNjb3BlLCBmdW5jU2NvcGUpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImlmXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGluZmVyRXhwclR5cGUoc3RtdC5wcmVkLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgICAgICBpZiAodCAhPSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJlZCA9IGZpbGxJbkV4cHJUeXBlSW5mbyhzdG10LnByZWQsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgICAgIHZhciBib2R5MSA9IGZpbGxJblN0bXRzVHlwZUluZm8oc3RtdC5ib2R5MSwgdmFyU2NvcGUsIGZ1bmNTY29wZSwgcmV0VHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkyID0gZmlsbEluU3RtdHNUeXBlSW5mbyhzdG10LmJvZHkyLCB2YXJTY29wZSwgZnVuY1Njb3BlLCByZXRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0bXQpLCB7IHByZWQ6IHByZWQsIGJvZHkxOiBib2R5MSwgYm9keTI6IGJvZHkyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIndoaWxlXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGluZmVyRXhwclR5cGUoc3RtdC5wcmVkLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgICAgICBpZiAodCAhPSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29uZGl0aW9uYWxFeHByVHlwZUVycm9yKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJlZCA9IGZpbGxJbkV4cHJUeXBlSW5mbyhzdG10LnByZWQsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gZmlsbEluU3RtdHNUeXBlSW5mbyhzdG10LmJvZHksIHZhclNjb3BlLCBmdW5jU2NvcGUsIHJldFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RtdCksIHsgcHJlZDogcHJlZCwgYm9keTogYm9keSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJwYXNzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgfTtcbiAgICByZXR1cm4gc3RtdHMubWFwKGFkZFR5cGVzKTtcbn1cbmV4cG9ydHMuZmlsbEluU3RtdHNUeXBlSW5mbyA9IGZpbGxJblN0bXRzVHlwZUluZm87XG5mdW5jdGlvbiBjaGVja1JldHVyblR5cGUobmFtZSwgc3RtdHMsIHZhclNjb3BlLCBmdW5jU2NvcGUsIHJldFR5cGUpIHtcbiAgICB2YXIgY2hlY2tMYXN0U3RtdFJldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN0bXRzLmxlbmd0aCA9PSAwIHNob3VsZCBiZSBjYXVnaHQgYmUgYSBQYXJzZUVycm9yXG4gICAgICAgIHZhciBsYXN0U3RtdCA9IHN0bXRzW3N0bXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFN0bXQudGFnID09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgIHZhciB0ID0gaW5mZXJFeHByVHlwZShsYXN0U3RtdC52YWx1ZSwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICBpZiAocmV0VHlwZSAhPSB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkdlbmVyYWxUeXBlRXJyb3IodCwgcmV0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG5vIHJldHVybiBzaW5jZSBcInJldHVyblwiIGlzIGFsd2F5cyB0aGUgbGFzdCBzdGF0ZW1lbnRcbiAgICAgICAgICAgIGlmIChyZXRUeXBlICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk1pc3NpbmdSZXR1cm4obmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIG5vIG5lc3RlZCBzdGF0ZW1lbnRzIChhc2lkZSBmcm9tIGZ1bmMgZGVmcywgd2hpY2ggZG9uJ3QgY291bnQpXG4gICAgaWYgKHN0bXRzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRhZyAhPSBcImlmXCIgJiYgcy50YWcgIT0gXCJ3aGlsZVwiOyB9KSkge1xuICAgICAgICBjaGVja0xhc3RTdG10UmV0VHlwZSgpO1xuICAgICAgICAvLyBUaGVyZSBleGlzdHMgYXQgbGVhc3Qgb25lIGlmIG9yIHdoaWxlIHN0YXRlbWVudCBpbiB0aGUgYXJyYXlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBjaGVjayBuZXN0ZWQgc3RhdGVtZW50c1xuICAgICAgICAgICAgdmFyIHN0bXRHcm91cHMgPSBzdG10cy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudGFnID09IFwiaWZcIiB8fCBzLnRhZyA9PSBcIndoaWxlXCI7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocy50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlmXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3MuYm9keTEsIHMuYm9keTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcy5ib2R5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0bXRHcm91cHNfMSA9IHN0bXRHcm91cHM7IF9pIDwgc3RtdEdyb3Vwc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gc3RtdEdyb3Vwc18xW19pXTtcbiAgICAgICAgICAgICAgICBjaGVja1JldHVyblR5cGUobmFtZSwgcywgdmFyU2NvcGUsIGZ1bmNTY29wZSwgcmV0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGVycm9yc18xLk1pc3NpbmdSZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBjaGVja0xhc3RTdG10UmV0VHlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1JldHVyblR5cGUgPSBjaGVja1JldHVyblR5cGU7XG5mdW5jdGlvbiBmaWxsSW5FeHByVHlwZUluZm8oZXhwciwgdmFyU2NvcGUsIGZ1bmNTY29wZSkge1xuICAgIC8vIGxldmVyYWdlIHRoZSB0eXBlIGNoZWtjaW5nIGNvZGUgaW4gdGhlIGluZmVyZW5jZSBhbGdvcml0aG1cbiAgICBzd2l0Y2ggKGV4cHIudGFnKSB7XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gZXhwci5hcmd1bWVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBmaWxsSW5FeHByVHlwZUluZm8oZSwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7IH0pO1xuICAgICAgICAgICAgdmFyIHR5cGVfID0gaW5mZXJFeHByVHlwZShleHByLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXhwciksIHsgYXJndW1lbnRzOiBhcmdzLCB0eXBlXzogdHlwZV8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaW9wXCI6IHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBmaWxsSW5FeHByVHlwZUluZm8oZXhwci5hcmcsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgdmFyIHR5cGVfID0gaW5mZXJFeHByVHlwZShleHByLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXhwciksIHsgYXJnOiBhcmcsIHR5cGVfOiB0eXBlXyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmlub3BcIjoge1xuICAgICAgICAgICAgdmFyIGFyZzEgPSBmaWxsSW5FeHByVHlwZUluZm8oZXhwci5hcmcxLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHZhciBhcmcyID0gZmlsbEluRXhwclR5cGVJbmZvKGV4cHIuYXJnMiwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICB2YXIgdHlwZV8gPSBpbmZlckV4cHJUeXBlKGV4cHIsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBleHByKSwgeyBhcmcxOiBhcmcxLCBhcmcyOiBhcmcyLCB0eXBlXzogdHlwZV8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhcmVuc1wiOiB7XG4gICAgICAgICAgICB2YXIgZSA9IGZpbGxJbkV4cHJUeXBlSW5mbyhleHByLmV4cHIsIHZhclNjb3BlLCBmdW5jU2NvcGUpO1xuICAgICAgICAgICAgdmFyIHR5cGVfID0gaW5mZXJFeHByVHlwZShleHByLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXhwciksIHsgZXhwcjogZSwgdHlwZV86IHR5cGVfIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cHIpLCB7IHR5cGVfOiBpbmZlckV4cHJUeXBlKGV4cHIsIHZhclNjb3BlLCBmdW5jU2NvcGUpIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZmVyRXhwclR5cGUoZXhwciwgdmFyU2NvcGUsIGZ1bmNTY29wZSkge1xuICAgIHN3aXRjaCAoZXhwci50YWcpIHtcbiAgICAgICAgY2FzZSBcImxpdGVyYWxcIjoge1xuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSBleHByLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIChsaXRlcmFsLnRhZyA9PSBcIm51bWJlclwiKSA/IFwiaW50XCIgOiBsaXRlcmFsLnRhZztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaWRcIjogcmV0dXJuIHZhclNjb3BlLmdldChleHByLm5hbWUpO1xuICAgICAgICBjYXNlIFwiY2FsbFwiOiB7XG4gICAgICAgICAgICBpZiAoZnVuY1Njb3BlLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ0eXBlID0gZnVuY1Njb3BlLmdldChleHByLm5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHBhcmFtZXRlciB0eXBlc1xuICAgICAgICAgICAgICAgIHZhciB6aXBwZWQgPSBmdHlwZS5wYXJhbWV0ZXJUeXBlcy5tYXAoZnVuY3Rpb24gKGssIGkpIHsgcmV0dXJuIFtpLCBrLCBleHByLmFyZ3VtZW50c1tpXV07IH0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgemlwcGVkXzEgPSB6aXBwZWQ7IF9pIDwgemlwcGVkXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IHppcHBlZF8xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtTiA9IHR1cGxlWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSB0dXBsZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQyID0gaW5mZXJFeHByVHlwZSh0dXBsZVsyXSwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0MSAhPSB0MiAmJiB0MSAhPSBcInBvbHltb3JwaGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5GdW5jQ2FsbFR5cEVycm9yKHQxLCB0MiwgcGFyYW1OKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnR5cGUub3V0cHV0VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RBRnVuY3Rpb25PckNsYXNzKGV4cHIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaW9wXCI6IHtcbiAgICAgICAgICAgIHZhciB0ID0gaW5mZXJFeHByVHlwZShleHByLmFyZywgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIudW5pb3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibm90XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgIT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbmlhcnlPcFR5cGVFcnJvcihcIm5vdFwiLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJvb2xcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwibmVnXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgIT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuaWFyeU9wVHlwZUVycm9yKFwibmVnXCIsIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJpbm9wXCI6IHtcbiAgICAgICAgICAgIHZhciB0MSA9IGluZmVyRXhwclR5cGUoZXhwci5hcmcxLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHZhciB0MiA9IGluZmVyRXhwclR5cGUoZXhwci5hcmcyLCB2YXJTY29wZSwgZnVuY1Njb3BlKTtcbiAgICAgICAgICAgIHZhciBpbnRPcHMgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvL1wiLCBcIiVcIiwgXCI9PVwiLCBcIiE9XCIsIFwiPj1cIiwgXCI8PVwiLCBcIj5cIiwgXCI8XCJdO1xuICAgICAgICAgICAgaWYgKGludE9wcy5pbmNsdWRlcyhleHByLmJpbm9wKSkge1xuICAgICAgICAgICAgICAgIGlmICh0MSAhPSBcImludFwiIHx8IHQyICE9IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gZXhwci5iaW5vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkJpbmFyeU9wVHlwZUVycm9yKG9wLCB0MSwgdDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvL1wiLCBcIiVcIl0pLmluY2x1ZGVzKGV4cHIuYmlub3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJvb2xcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGUgXCJpc1wiIG9wZXJhdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodDEgPT0gXCJpbnRcIiB8fCB0MSA9PSBcImJvb2xcIiB8fCB0MiA9PSBcImludFwiIHx8IHQyID09IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5CaW5hcnlPcFR5cGVFcnJvcihcImlzXCIsIHQxLCB0Mik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJib29sXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJwYXJlbnNcIjpcbiAgICAgICAgICAgIHJldHVybiBpbmZlckV4cHJUeXBlKGV4cHIuZXhwciwgdmFyU2NvcGUsIGZ1bmNTY29wZSk7XG4gICAgfVxufVxuZXhwb3J0cy5pbmZlckV4cHJUeXBlID0gaW5mZXJFeHByVHlwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21waWxlcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZXJcIik7XG52YXIgcnVubmVyXzEgPSByZXF1aXJlKFwiLi9ydW5uZXJcIik7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBydW5CdXR0b24sIHVzZXJDb2RlLCBpbXBvcnRPYmplY3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBydW5CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJ1blwiKTtcbiAgICAgICAgdXNlckNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInVzZXItY29kZVwiKTtcbiAgICAgICAgaW1wb3J0T2JqZWN0ID0ge1xuICAgICAgICAgICAgaW1wb3J0czoge1xuICAgICAgICAgICAgICAgIHByaW50OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9nZ2luZyBmcm9tIFdBU006IFwiLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIikuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWx0LmlubmVyVGV4dCA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dHB1dDogXCJcIlxuICAgICAgICB9O1xuICAgICAgICBydW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSwgd2F0LCBjb2RlLCBvdXRwdXQsIHJlc3VsdCwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbSA9IHVzZXJDb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0ID0gY29tcGlsZXJfMS5jb21waWxlKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2VuZXJhdGVkLWNvZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gd2F0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBydW5uZXJfMS5ydW4od2F0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50ZXh0Q29udGVudCA9IFN0cmluZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6IGJsYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50ZXh0Q29udGVudCA9IFN0cmluZyhlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6IHJlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgfSk7XG59KTsgfSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHdhYnQ7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL3dlYnN0YXJ0LnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==